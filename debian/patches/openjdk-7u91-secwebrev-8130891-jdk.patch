# HG changeset patch
# User bpb
# Date 1438881226 25200
#      Thu Aug 06 10:13:46 2015 -0700
# Node ID 22ae2d11ff54b758b648b5fcd6ea90e03a4c6781
# Parent  ba3539237537a6302c8534753a2f28418185b578
8130891: (bf) More direct buffering
Summary: Improve non-byte direct buffering.
Reviewed-by: alanb, jeff, ahgross, robm, rriggs

Index: openjdk/jdk/src/share/classes/java/nio/Direct-X-Buffer.java.template
===================================================================
--- openjdk/jdk/src/share/classes/java/nio/Direct-X-Buffer.java.template.orig
+++ openjdk/jdk/src/share/classes/java/nio/Direct-X-Buffer.java.template
@@ -242,7 +242,7 @@ class Direct$Type$Buffer$RW$$BO$
     }
 
     private long ix(int i) {
-        return address + (i << $LG_BYTES_PER_VALUE$);
+        return address + ((long)i << $LG_BYTES_PER_VALUE$);
     }
 
     public $type$ get() {
@@ -255,7 +255,7 @@ class Direct$Type$Buffer$RW$$BO$
 
     public $Type$Buffer get($type$[] dst, int offset, int length) {
 #if[rw]
-        if ((length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
+        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
             checkBounds(offset, length, dst.length);
             int pos = position();
             int lim = limit();
@@ -267,13 +267,13 @@ class Direct$Type$Buffer$RW$$BO$
 #if[!byte]
             if (order() != ByteOrder.nativeOrder())
                 Bits.copyTo$Memtype$Array(ix(pos), dst,
-                                          offset << $LG_BYTES_PER_VALUE$,
-                                          length << $LG_BYTES_PER_VALUE$);
+                                          (long)offset << $LG_BYTES_PER_VALUE$,
+                                          (long)length << $LG_BYTES_PER_VALUE$);
             else
 #end[!byte]
                 Bits.copyToArray(ix(pos), dst, arrayBaseOffset,
-                                 offset << $LG_BYTES_PER_VALUE$,
-                                 length << $LG_BYTES_PER_VALUE$);
+                                 (long)offset << $LG_BYTES_PER_VALUE$,
+                                 (long)length << $LG_BYTES_PER_VALUE$);
             position(pos + length);
         } else {
             super.get(dst, offset, length);
@@ -323,7 +323,7 @@ class Direct$Type$Buffer$RW$$BO$
 
             if (srem > rem)
                 throw new BufferOverflowException();
-            unsafe.copyMemory(sb.ix(spos), ix(pos), srem << $LG_BYTES_PER_VALUE$);
+            unsafe.copyMemory(sb.ix(spos), ix(pos), (long)srem << $LG_BYTES_PER_VALUE$);
             sb.position(spos + srem);
             position(pos + srem);
         } else if (src.hb != null) {
@@ -347,7 +347,7 @@ class Direct$Type$Buffer$RW$$BO$
 
     public $Type$Buffer put($type$[] src, int offset, int length) {
 #if[rw]
-        if ((length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
+        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
             checkBounds(offset, length, src.length);
             int pos = position();
             int lim = limit();
@@ -358,12 +358,16 @@ class Direct$Type$Buffer$RW$$BO$
 
 #if[!byte]
             if (order() != ByteOrder.nativeOrder())
-                Bits.copyFrom$Memtype$Array(src, offset << $LG_BYTES_PER_VALUE$,
-                                            ix(pos), length << $LG_BYTES_PER_VALUE$);
+                Bits.copyFrom$Memtype$Array(src,
+                                            (long)offset << $LG_BYTES_PER_VALUE$,
+                                            ix(pos),
+                                            (long)length << $LG_BYTES_PER_VALUE$);
             else
 #end[!byte]
-                Bits.copyFromArray(src, arrayBaseOffset, offset << $LG_BYTES_PER_VALUE$,
-                                   ix(pos), length << $LG_BYTES_PER_VALUE$);
+                Bits.copyFromArray(src, arrayBaseOffset,
+                                   (long)offset << $LG_BYTES_PER_VALUE$,
+                                   ix(pos),
+                                   (long)length << $LG_BYTES_PER_VALUE$);
             position(pos + length);
         } else {
             super.put(src, offset, length);
@@ -381,7 +385,7 @@ class Direct$Type$Buffer$RW$$BO$
         assert (pos <= lim);
         int rem = (pos <= lim ? lim - pos : 0);
 
-        unsafe.copyMemory(ix(pos), ix(0), rem << $LG_BYTES_PER_VALUE$);
+        unsafe.copyMemory(ix(pos), ix(0), (long)rem << $LG_BYTES_PER_VALUE$);
         position(rem);
         limit(capacity());
         discardMark();
