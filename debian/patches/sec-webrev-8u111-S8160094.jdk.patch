# HG changeset patch
# User ksrini
# Date 1467749227 25200
#      Tue Jul 05 13:07:07 2016 -0700
# Node ID 6be8f327c0a06badff48e62b8504081db6b0a448
# Parent  9cb11ad7fc323d9ab9fdb67cd94907786d5335ee
8160094: Improve pack200 layout
Reviewed-by: jrose, mschoene

---
 openjdk/jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp |   17 +++++++++-
 openjdk/jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp    |    4 +-
 2 files changed, 18 insertions(+), 3 deletions(-)

--- openjdk/jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp.orig
+++ openjdk/jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -2620,6 +2620,7 @@ void unpacker::putlayout(band** body) {
         }
         assert(!b.le_bci || prevBCI == (int)to_bci(prevBII));
 
+        CHECK;
         switch (b.le_len) {
         case 0: break;
         case 1: putu1(x); break;
@@ -3711,6 +3712,10 @@ uint unpacker::to_bci(uint bii) {
   uint  len =         bcimap.length();
   uint* map = (uint*) bcimap.base();
   assert(len > 0);  // must be initialized before using to_bci
+  if (len == 0) {
+    abort("bad bcimap");
+    return 0;
+  }
   if (bii < len)
     return map[bii];
   // Else it's a fractional or out-of-range BCI.
@@ -3733,6 +3738,7 @@ void unpacker::put_stackmap_type() {
     break;
   case 8: // (8) [PH]
     putu2(to_bci(code_StackMapTable_P.getInt()));
+    CHECK;
     break;
   }
 }
@@ -3780,6 +3786,7 @@ void unpacker::write_bc_ops() {
   CHECK;
 
   for (int curIP = 0; ; curIP++) {
+    CHECK;
     int curPC = (int)(wpoffset() - codeBase);
     bcimap.add(curPC);
     ensure_put_space(10);  // covers most instrs w/o further bounds check
@@ -4009,6 +4016,7 @@ void unpacker::write_bc_ops() {
     int   curIP  = code_fixup_source.get(i);
     int   destIP = curIP + bc_label.getInt();
     int   span   = to_bci(destIP) - to_bci(curIP);
+    CHECK;
     switch (type) {
     case 2: putu2_at(bp, (ushort)span); break;
     case 4: putu4_at(bp,         span); break;
@@ -4196,11 +4204,13 @@ int unpacker::write_attrs(int attrc, jul
           if (tag <= 127) {
             // (64-127)  [(2)]
             if (tag >= 64)  put_stackmap_type();
+            CHECK_0;
           } else if (tag <= 251) {
             // (247)     [(1)(2)]
             // (248-251) [(1)]
             if (tag >= 247)  putu2(code_StackMapTable_offset.getInt());
             if (tag == 247)  put_stackmap_type();
+            CHECK_0;
           } else if (tag <= 254) {
             // (252)     [(1)(2)]
             // (253)     [(1)(2)(2)]
@@ -4227,6 +4237,7 @@ int unpacker::write_attrs(int attrc, jul
         putu2(count = code_LineNumberTable_N.getInt());
         for (j = 0; j < count; j++) {
           putu2(to_bci(code_LineNumberTable_bci_P.getInt()));
+          CHECK_0;
           putu2(code_LineNumberTable_line.getInt());
         }
         break;
@@ -4237,9 +4248,11 @@ int unpacker::write_attrs(int attrc, jul
         for (j = 0; j < count; j++) {
           int bii = code_LocalVariableTable_bci_P.getInt();
           int bci = to_bci(bii);
+          CHECK_0;
           putu2(bci);
           bii    += code_LocalVariableTable_span_O.getInt();
           putu2(to_bci(bii) - bci);
+          CHECK_0;
           putref(code_LocalVariableTable_name_RU.getRefN());
           CHECK_0;
           putref(code_LocalVariableTable_type_RS.getRefN());
@@ -4254,9 +4267,11 @@ int unpacker::write_attrs(int attrc, jul
         for (j = 0; j < count; j++) {
           int bii = code_LocalVariableTypeTable_bci_P.getInt();
           int bci = to_bci(bii);
+          CHECK_0;
           putu2(bci);
           bii    += code_LocalVariableTypeTable_span_O.getInt();
           putu2(to_bci(bii) - bci);
+          CHECK_0;
           putref(code_LocalVariableTypeTable_name_RU.getRefN());
           CHECK_0;
           putref(code_LocalVariableTypeTable_type_RS.getRefN());
--- openjdk/jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp.orig
+++ openjdk/jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -342,7 +342,7 @@ uLong jar::get_dostime(int modtime) {
   struct tm* s = gmtime_r(&t, &sbuf);
   if (s == NULL) {
     fprintf(u->errstrm, "Error: gmtime failure, invalid input archive\n");
-    exit(2);
+    exit(-1);
   }
   modtime_cache = modtime;
   dostime_cache = dostime(s->tm_year + 1900, s->tm_mon + 1, s->tm_mday,
