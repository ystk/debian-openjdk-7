# HG changeset patch
# User robm
# Date 1486658062 0
#      Thu Feb 09 16:34:22 2017 +0000
# Node ID 8a2c97926e639a341396cee3364b51bdf28ee350
# Parent  1e8e0cac4ef48caf73d77f86710350858c4a0d7c
8172299: Improve class processing
Reviewed-by: rriggs

--- openjdk/jdk/src/share/classes/java/io/ObjectInputStream.java.orig
+++ openjdk/jdk/src/share/classes/java/io/ObjectInputStream.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1772,12 +1772,19 @@ public class ObjectInputStream
         } catch (ClassNotFoundException ex) {
             resolveEx = ex;
         }
-        skipCustomData();
 
-        desc.initProxy(cl, resolveEx, readClassDesc(false));
+        // Call filterCheck on the class before reading anything else
+        filterCheck(cl, -1);
+
+        skipCustomData();
 
-        // Call filterCheck on the definition
-        filterCheck(desc.forClass(), -1);
+        try {
+            totalObjectRefs++;
+            depth++;
+            desc.initProxy(cl, resolveEx, readClassDesc(false));
+        } finally {
+            depth--;
+        }
 
         handles.finish(descHandle);
         passHandle = descHandle;
@@ -1822,12 +1829,19 @@ public class ObjectInputStream
         } catch (ClassNotFoundException ex) {
             resolveEx = ex;
         }
-        skipCustomData();
 
-        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));
+        // Call filterCheck on the class before reading anything else
+        filterCheck(cl, -1);
+
+        skipCustomData();
 
-        // Call filterCheck on the definition
-        filterCheck(desc.forClass(), -1);
+        try {
+            totalObjectRefs++;
+            depth++;
+            desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));
+        } finally {
+            depth--;
+        }
 
         handles.finish(descHandle);
         passHandle = descHandle;
--- openjdk/jdk/test/java/io/Serializable/serialFilter/SerialFilterTest.java.orig
+++ openjdk/jdk/test/java/io/Serializable/serialFilter/SerialFilterTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -144,17 +144,17 @@ public class SerialFilterTest implements
 
         Object[][] objects = {
                 { null, 0, -1, 0, 0, 0,
-                    new HashSet<>()},        // no callback, no values
-                { objArray, 3, 7, 8, 2, 55,
-                        new HashSet<>(Arrays.asList(objArray.getClass()))},
-                { Object[].class, 1, -1, 1, 1, 40,
-                            new HashSet<>(Arrays.asList(Object[].class))},
-                { new SerialFilterTest(), 1, -1, 1, 1, 37,
-                                new HashSet<>(Arrays.asList(SerialFilterTest.class))},
-                { new byte[14], 2, 14, 1, 1, 27,
-                                    new HashSet<>(Arrays.asList(byteArray.getClass()))},
-                { deepHashSet(10), 48, -1, 49, 11, 619,
-                                        new HashSet<>(Arrays.asList(HashSet.class))},
+                        Arrays.asList()},        // no callback, no values
+                { objArray, 3, 7, 9, 2, 55,
+                        Arrays.asList(objArray.getClass(), objArray.getClass())},
+                { Object[].class, 1, -1, 1, 1, 38,
+                        Arrays.asList(Object[].class)},
+                { new SerialFilterTest(), 1, -1, 1, 1, 35,
+                        Arrays.asList(SerialFilterTest.class)},
+                { new byte[14], 2, 14, 2, 1, 27,
+                        Arrays.asList(byteArray.getClass(), byteArray.getClass())},
+                { deepHashSet(10), 48, -1, 50, 11, 619,
+                        Arrays.asList(HashSet.class)},
         };
         return objects;
     }
@@ -193,11 +193,12 @@ public class SerialFilterTest implements
     @Test(dataProvider="Objects")
     public static void t1(Object object,
             long count, long maxArray, long maxRefs, long maxDepth, long maxBytes,
-            Set<Class<?>> classes) throws IOException {
+            List<Class<?>> classes) throws IOException {
         byte[] bytes = writeObjects(object);
         Validator validator = new Validator();
         validate(bytes, validator);
         System.out.printf("v: %s%n", validator);
+
         Assert.assertEquals(validator.count, count, "callback count wrong");
         Assert.assertEquals(validator.classes, classes, "classes mismatch");
         Assert.assertEquals(validator.maxArray, maxArray, "maxArray mismatch");
@@ -395,7 +396,7 @@ public class SerialFilterTest implements
      */
     static class Validator implements ObjectInputFilter {
         long count;          // Count of calls to checkInput
-        HashSet<Class<?>> classes = new HashSet<>();
+        List<Class<?>> classes = new ArrayList<>();
         long maxArray = -1;
         long maxRefs;
         long maxDepth;
@@ -406,12 +407,16 @@ public class SerialFilterTest implements
 
         @Override
         public ObjectInputFilter.Status checkInput(FilterInfo filter) {
+            Class<?> serialClass = filter.serialClass();
+            System.out.printf("     checkInput: class: %s, arrayLen: %d, refs: %d, depth: %d, bytes; %d%n",
+                    serialClass, filter.arrayLength(), filter.references(),
+                    filter.depth(), filter.streamBytes());
             count++;
-            if (filter.serialClass() != null) {
-                if (Proxy.isProxyClass(filter.serialClass())) {
+            if (serialClass != null) {
+                if (Proxy.isProxyClass(serialClass)) {
                     classes.add(Proxy.class);
                 } else {
-                    classes.add(filter.serialClass());
+                    classes.add(serialClass);
                 }
 
             }
@@ -574,7 +579,8 @@ public class SerialFilterTest implements
             // a stream of exactly the size requested.
             return genMaxBytesObject(allowed, value);
         } else if (pattern.startsWith("maxrefs=")) {
-            Object[] array = new Object[allowed ? (int)value - 1 : (int)value];
+            // 4 references to classes in addition to the array contents
+            Object[] array = new Object[allowed ? (int)value - 4 : (int)value - 3];
             for (int i = 0; i < array.length; i++) {
                 array[i] = otherObject;
             }
@@ -782,4 +788,25 @@ public class SerialFilterTest implements
             return streamBytes;
         }
     }
+
+    // Deeper superclass hierarchy
+    static class A implements Serializable {
+        private static final long serialVersionUID = 1L;
+    };
+    static class B extends A {
+        private static final long serialVersionUID = 2L;
+    }
+    static class C extends B {
+        private static final long serialVersionUID = 3L;
+    }
+    static class D extends C {
+        private static final long serialVersionUID = 4L;
+    }
+    static class E extends D {
+        private static final long serialVersionUID = 5L;
+    }
+    static class F extends E {
+        private static final long serialVersionUID = 6L;
+    }
+
 }
