# HG changeset patch
# User aefimov
# Date 1430222663 -10800
#      Tue Apr 28 15:04:23 2015 +0300
# Node ID 5f65805254c3644c4d3a17807755af239d9df966
# Parent  c54df9f952d1e028b63fe8884e35ef687c7a12be
8068842: Better JAXP data handling
Reviewed-by: joehw, dfuchs, lancea

Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/lib/ExsltSets.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/lib/ExsltSets.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/lib/ExsltSets.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,10 +22,10 @@
  */
 package com.sun.org.apache.xalan.internal.lib;
 
-import java.util.Hashtable;
-
 import com.sun.org.apache.xml.internal.utils.DOMHelper;
 import com.sun.org.apache.xpath.internal.NodeSet;
+import java.util.HashMap;
+import java.util.Map;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
@@ -192,7 +192,7 @@ public class ExsltSets extends ExsltBase
     NodeSet dist = new NodeSet();
     dist.setShouldCacheNodes(true);
 
-    Hashtable stringTable = new Hashtable();
+    Map<String, Node> stringTable = new HashMap<>();
 
     for (int i = 0; i < nl.getLength(); i++)
     {
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/lib/Extensions.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/lib/Extensions.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/lib/Extensions.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,28 +22,24 @@
  */
 package com.sun.org.apache.xalan.internal.lib;
 
-import java.util.Hashtable;
-import java.util.StringTokenizer;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-
 import com.sun.org.apache.xalan.internal.extensions.ExpressionContext;
+import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
 import com.sun.org.apache.xalan.internal.xslt.EnvironmentCheck;
 import com.sun.org.apache.xpath.internal.NodeSet;
 import com.sun.org.apache.xpath.internal.objects.XBoolean;
 import com.sun.org.apache.xpath.internal.objects.XNumber;
 import com.sun.org.apache.xpath.internal.objects.XObject;
-import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
-
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.StringTokenizer;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
 import org.w3c.dom.Document;
 import org.w3c.dom.DocumentFragment;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.w3c.dom.Text;
 import org.w3c.dom.traversal.NodeIterator;
-
 import org.xml.sax.SAXNotSupportedException;
 
 /**
@@ -313,7 +309,7 @@ public class Extensions
 
       // If reflection failed, fallback to our internal EnvironmentCheck
       EnvironmentCheck envChecker = new EnvironmentCheck();
-      Hashtable h = envChecker.getEnvironmentHash();
+      Map<String, Object> h = envChecker.getEnvironmentHash();
       resultNode = factoryDocument.createElement("checkEnvironmentExtension");
       envChecker.appendEnvironmentReport(resultNode, factoryDocument, h);
       envChecker = null;
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xslt/EnvironmentCheck.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -24,17 +24,17 @@ package com.sun.org.apache.xalan.interna
 
 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
 import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
-
 import java.io.File;
 import java.io.FileWriter;
 import java.io.PrintWriter;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
-import java.util.Enumeration;
-import java.util.Hashtable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import java.util.StringTokenizer;
-import java.util.Vector;
-
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
@@ -171,7 +171,7 @@ public class EnvironmentCheck
       outWriter = pw;
 
     // Setup a hash to store various environment information in
-    Hashtable hash = getEnvironmentHash();
+    Map<String, Object> hash = getEnvironmentHash();
 
     // Check for ERROR keys in the hashtable, and print report
     boolean environmentHasErrors = writeEnvironmentReport(hash);
@@ -214,13 +214,13 @@ public class EnvironmentCheck
    * point out the most common classpath and system property
    * problems that we've seen.</p>
    *
-   * @return Hashtable full of useful environment info about Xalan
-   * and related system properties, etc.
+   * @return Map full of useful environment info about Xalan and related
+   * system properties, etc.
    */
-  public Hashtable getEnvironmentHash()
+  public Map<String, Object> getEnvironmentHash()
   {
     // Setup a hash to store various environment information in
-    Hashtable hash = new Hashtable();
+    Map<String, Object> hash = new HashMap<>();
 
     // Call various worker methods to fill in the hash
     //  These are explicitly separate for maintenance and so
@@ -242,22 +242,22 @@ public class EnvironmentCheck
    * Dump a basic Xalan environment report to outWriter.
    *
    * <p>This dumps a simple header and then each of the entries in
-   * the Hashtable to our PrintWriter; it does special processing
+   * the Map to our PrintWriter; it does special processing
    * for entries that are .jars found in the classpath.</p>
    *
-   * @param h Hashtable of items to report on; presumably
+   * @param h Map of items to report on; presumably
    * filled in by our various check*() methods
    * @return true if your environment appears to have no major
    * problems; false if potential environment problems found
-   * @see #appendEnvironmentReport(Node, Document, Hashtable)
+   * @see #appendEnvironmentReport(Node, Document, Map)
    * for an equivalent that appends to a Node instead
    */
-  protected boolean writeEnvironmentReport(Hashtable h)
+  protected boolean writeEnvironmentReport(Map<String, Object> h)
   {
 
     if (null == h)
     {
-      logMsg("# ERROR: writeEnvironmentReport called with null Hashtable");
+      logMsg("# ERROR: writeEnvironmentReport called with null Map");
       return false;
     }
 
@@ -267,39 +267,28 @@ public class EnvironmentCheck
       "#---- BEGIN writeEnvironmentReport($Revision: 1.10 $): Useful stuff found: ----");
 
     // Fake the Properties-like output
-    for (Enumeration keys = h.keys();
-         keys.hasMoreElements();
-        /* no increment portion */
-        )
-    {
-      Object key = keys.nextElement();
-      String keyStr = (String) key;
-      try
-      {
-        // Special processing for classes found..
-        if (keyStr.startsWith(FOUNDCLASSES))
-        {
-          Vector v = (Vector) h.get(keyStr);
-          errors |= logFoundJars(v, keyStr);
-        }
-        // ..normal processing for all other entries
-        else
-        {
-          // Note: we could just check for the ERROR key by itself,
-          //    since we now set that, but since we have to go
-          //    through the whole hash anyway, do it this way,
-          //    which is safer for maintenance
-          if (keyStr.startsWith(ERROR))
-          {
-            errors = true;
-          }
-          logMsg(keyStr + "=" + h.get(keyStr));
+    for (Map.Entry<String, Object> entry : h.entrySet()) {
+        String keyStr = entry.getKey();
+        try {
+            // Special processing for classes found..
+            if (keyStr.startsWith(FOUNDCLASSES)) {
+                List<Map> v = (ArrayList<Map>)entry.getValue();
+                errors |= logFoundJars(v, keyStr);
+            }
+            // ..normal processing for all other entries
+            else {
+                // Note: we could just check for the ERROR key by itself,
+                //    since we now set that, but since we have to go
+                //    through the whole hash anyway, do it this way,
+                //    which is safer for maintenance
+                if (keyStr.startsWith(ERROR)) {
+                    errors = true;
+                }
+                logMsg(keyStr + "=" + h.get(keyStr));
+            }
+        } catch (Exception e) {
+            logMsg("Reading-" + keyStr + "= threw: " + e.toString());
         }
-      }
-      catch (Exception e)
-      {
-        logMsg("Reading-" + key + "= threw: " + e.toString());
-      }
     }
 
     logMsg(
@@ -350,14 +339,14 @@ public class EnvironmentCheck
    * Takes the information encoded from a checkPathForJars()
    * call and dumps it out to our PrintWriter.
    *
-   * @param v Vector of Hashtables of .jar file info
+   * @param v List of Maps of .jar file info
    * @param desc description to print out in header
    *
    * @return false if OK, true if any .jars were reported
    * as having errors
    * @see #checkPathForJars(String, String[])
    */
-  protected boolean logFoundJars(Vector v, String desc)
+  protected boolean logFoundJars(List<Map> v, String desc)
   {
 
     if ((null == v) || (v.size() < 1))
@@ -367,32 +356,20 @@ public class EnvironmentCheck
 
     logMsg("#---- BEGIN Listing XML-related jars in: " + desc + " ----");
 
-    for (int i = 0; i < v.size(); i++)
-    {
-      Hashtable subhash = (Hashtable) v.elementAt(i);
-
-      for (Enumeration keys = subhash.keys();
-           keys.hasMoreElements();
-           /* no increment portion */
-          )
-      {
-        Object key = keys.nextElement();
-        String keyStr = (String) key;
-        try
-        {
-          if (keyStr.startsWith(ERROR))
-          {
-            errors = true;
-          }
-          logMsg(keyStr + "=" + subhash.get(keyStr));
-
-        }
-        catch (Exception e)
-        {
-          errors = true;
-          logMsg("Reading-" + key + "= threw: " + e.toString());
+    for (Map<String, String> v1 : v) {
+        for (Map.Entry<String, String> entry : v1.entrySet()) {
+            String keyStr = entry.getKey();
+            try {
+                if (keyStr.startsWith(ERROR)) {
+                    errors = true;
+                }
+                logMsg(keyStr + "=" + entry.getValue());
+
+            } catch (Exception e) {
+                errors = true;
+                logMsg("Reading-" + keyStr + "= threw: " + e.toString());
+            }
         }
-      }
     }
 
     logMsg("#----- END Listing XML-related jars in: " + desc + " -----");
@@ -410,10 +387,10 @@ public class EnvironmentCheck
    * @param container Node to append our report to
    * @param factory Document providing createElement, etc. services
    * @param h Hash presumably from {@link #getEnvironmentHash()}
-   * @see #writeEnvironmentReport(Hashtable)
+   * @see #writeEnvironmentReport(Map)
    * for an equivalent that writes to a PrintWriter instead
    */
-  public void appendEnvironmentReport(Node container, Document factory, Hashtable h)
+  public void appendEnvironmentReport(Node container, Document factory, Map<String, Object> h)
   {
     if ((null == container) || (null == factory))
     {
@@ -430,7 +407,7 @@ public class EnvironmentCheck
       {
         Element statusNode = factory.createElement("status");
         statusNode.setAttribute("result", "ERROR");
-        statusNode.appendChild(factory.createTextNode("appendEnvironmentReport called with null Hashtable!"));
+        statusNode.appendChild(factory.createTextNode("appendEnvironmentReport called with null Map!"));
         envCheckNode.appendChild(statusNode);
         return;
       }
@@ -440,47 +417,35 @@ public class EnvironmentCheck
       Element hashNode = factory.createElement("environment");
       envCheckNode.appendChild(hashNode);
 
-      for (Enumeration keys = h.keys();
-           keys.hasMoreElements();
-          /* no increment portion */
-          )
-      {
-        Object key = keys.nextElement();
-        String keyStr = (String) key;
-        try
-        {
-          // Special processing for classes found..
-          if (keyStr.startsWith(FOUNDCLASSES))
-          {
-            Vector v = (Vector) h.get(keyStr);
-            // errors |= logFoundJars(v, keyStr);
-            errors |= appendFoundJars(hashNode, factory, v, keyStr);
-          }
-          // ..normal processing for all other entries
-          else
-          {
-            // Note: we could just check for the ERROR key by itself,
-            //    since we now set that, but since we have to go
-            //    through the whole hash anyway, do it this way,
-            //    which is safer for maintenance
-            if (keyStr.startsWith(ERROR))
-            {
+      for (Map.Entry<String, Object> entry : h.entrySet()) {
+          String keyStr = entry.getKey();
+          try {
+              // Special processing for classes found..
+              if (keyStr.startsWith(FOUNDCLASSES)) {
+                  List<Map> v = (List<Map>)entry.getValue();
+                  // errors |= logFoundJars(v, keyStr);
+                  errors |= appendFoundJars(hashNode, factory, v, keyStr);
+              } // ..normal processing for all other entries
+              else {
+                  // Note: we could just check for the ERROR key by itself,
+                  //    since we now set that, but since we have to go
+                  //    through the whole hash anyway, do it this way,
+                  //    which is safer for maintenance
+                  if (keyStr.startsWith(ERROR)) {
+                      errors = true;
+                  }
+                  Element node = factory.createElement("item");
+                  node.setAttribute("key", keyStr);
+                  node.appendChild(factory.createTextNode((String) h.get(keyStr)));
+                  hashNode.appendChild(node);
+              }
+          } catch (Exception e) {
               errors = true;
-            }
-            Element node = factory.createElement("item");
-            node.setAttribute("key", keyStr);
-            node.appendChild(factory.createTextNode((String)h.get(keyStr)));
-            hashNode.appendChild(node);
+              Element node = factory.createElement("item");
+              node.setAttribute("key", keyStr);
+              node.appendChild(factory.createTextNode(ERROR + " Reading " + keyStr + " threw: " + e.toString()));
+              hashNode.appendChild(node);
           }
-        }
-        catch (Exception e)
-        {
-          errors = true;
-          Element node = factory.createElement("item");
-          node.setAttribute("key", keyStr);
-          node.appendChild(factory.createTextNode(ERROR + " Reading " + key + " threw: " + e.toString()));
-          hashNode.appendChild(node);
-        }
       } // end of for...
 
       Element statusNode = factory.createElement("status");
@@ -502,7 +467,7 @@ public class EnvironmentCheck
    *
    * @param container Node to append our report to
    * @param factory Document providing createElement, etc. services
-   * @param v Vector of Hashtables of .jar file info
+   * @param v Map of Maps of .jar file info
    * @param desc description to print out in header
    *
    * @return false if OK, true if any .jars were reported
@@ -510,7 +475,7 @@ public class EnvironmentCheck
    * @see #checkPathForJars(String, String[])
    */
   protected boolean appendFoundJars(Node container, Document factory,
-        Vector v, String desc)
+        List<Map> v, String desc)
   {
 
     if ((null == v) || (v.size() < 1))
@@ -518,37 +483,25 @@ public class EnvironmentCheck
 
     boolean errors = false;
 
-    for (int i = 0; i < v.size(); i++)
-    {
-      Hashtable subhash = (Hashtable) v.elementAt(i);
-
-      for (Enumeration keys = subhash.keys();
-           keys.hasMoreElements();
-           /* no increment portion */
-          )
-      {
-        Object key = keys.nextElement();
-        try
-        {
-          String keyStr = (String) key;
-          if (keyStr.startsWith(ERROR))
-          {
-            errors = true;
-          }
-          Element node = factory.createElement("foundJar");
-          node.setAttribute("name", keyStr.substring(0, keyStr.indexOf("-")));
-          node.setAttribute("desc", keyStr.substring(keyStr.indexOf("-") + 1));
-          node.appendChild(factory.createTextNode((String)subhash.get(keyStr)));
-          container.appendChild(node);
-        }
-        catch (Exception e)
-        {
-          errors = true;
-          Element node = factory.createElement("foundJar");
-          node.appendChild(factory.createTextNode(ERROR + " Reading " + key + " threw: " + e.toString()));
-          container.appendChild(node);
+    for (Map<String, String> v1 : v) {
+        for (Map.Entry<String, String> entry : v1.entrySet()) {
+            String keyStr = entry.getKey();
+            try {
+                if (keyStr.startsWith(ERROR)) {
+                    errors = true;
+                }
+                Element node = factory.createElement("foundJar");
+                node.setAttribute("name", keyStr.substring(0, keyStr.indexOf("-")));
+                node.setAttribute("desc", keyStr.substring(keyStr.indexOf("-") + 1));
+                node.appendChild(factory.createTextNode(entry.getValue()));
+                container.appendChild(node);
+            } catch (Exception e) {
+                errors = true;
+                Element node = factory.createElement("foundJar");
+                node.appendChild(factory.createTextNode(ERROR + " Reading " + keyStr + " threw: " + e.toString()));
+                container.appendChild(node);
+            }
         }
-      }
     }
     return errors;
   }
@@ -562,15 +515,15 @@ public class EnvironmentCheck
    * //@todo NOTE: We don't actually search java.ext.dirs for
    * //  *.jar files therein! This should be updated
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    * @see #jarNames
    * @see #checkPathForJars(String, String[])
    */
-  protected void checkSystemProperties(Hashtable h)
+  protected void checkSystemProperties(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     // Grab java version for later use
     try
@@ -598,22 +551,22 @@ public class EnvironmentCheck
 
       h.put("java.class.path", cp);
 
-      Vector classpathJars = checkPathForJars(cp, jarNames);
+      List<Map> classpathJars = checkPathForJars(cp, jarNames);
 
-      if (null != classpathJars)
-        h.put(FOUNDCLASSES + "java.class.path", classpathJars);
+      if (null != classpathJars) {
+          h.put(FOUNDCLASSES + "java.class.path", classpathJars);
+      }
 
       // Also check for JDK 1.2+ type classpaths
       String othercp = SecuritySupport.getSystemProperty("sun.boot.class.path");
 
-      if (null != othercp)
-      {
-        h.put("sun.boot.class.path", othercp);
-
-        classpathJars = checkPathForJars(othercp, jarNames);
+      if (null != othercp) {
+          h.put("sun.boot.class.path", othercp);
+          classpathJars = checkPathForJars(othercp, jarNames);
 
-        if (null != classpathJars)
-          h.put(FOUNDCLASSES + "sun.boot.class.path", classpathJars);
+          if (null != classpathJars) {
+              h.put(FOUNDCLASSES + "sun.boot.class.path", classpathJars);
+          }
       }
 
       //@todo NOTE: We don't actually search java.ext.dirs for
@@ -654,20 +607,20 @@ public class EnvironmentCheck
    * @param cp classpath to search
    * @param jars array of .jar base filenames to look for
    *
-   * @return Vector of Hashtables filled with info about found .jars
+   * @return List of Maps filled with info about found .jars
    * @see #jarNames
-   * @see #logFoundJars(Vector, String)
-   * @see #appendFoundJars(Node, Document, Vector, String )
+   * @see #logFoundJars(Map, String)
+   * @see #appendFoundJars(Node, Document, Map, String )
    * @see #getApparentVersion(String, long)
    */
-  protected Vector checkPathForJars(String cp, String[] jars)
+  protected List<Map> checkPathForJars(String cp, String[] jars)
   {
 
     if ((null == cp) || (null == jars) || (0 == cp.length())
             || (0 == jars.length))
       return null;
 
-    Vector v = new Vector();
+    List<Map> v = new ArrayList<>();
     StringTokenizer st = new StringTokenizer(cp, File.pathSeparator);
 
     while (st.hasMoreTokens())
@@ -687,37 +640,32 @@ public class EnvironmentCheck
 
             // If any requested jarName exists, report on
             //  the details of that .jar file
-            try
-            {
-              Hashtable h = new Hashtable(2);
-              // Note "-" char is looked for in appendFoundJars
-              h.put(jars[i] + "-path", f.getAbsolutePath());
-
-              // We won't bother reporting on the xalan.jar apparent version
-              // since this requires knowing the jar size of the xalan.jar
-              // before we build it.
-              // For other jars, eg. xml-apis.jar and xercesImpl.jar, we
-              // report the apparent version of the file we've found
-              if (!("xalan.jar".equalsIgnoreCase(jars[i]))) {
-                h.put(jars[i] + "-apparent.version",
-                    getApparentVersion(jars[i], f.length()));
-              }
-              v.addElement(h);
-            }
-            catch (Exception e)
-            {
+            try {
+                Map<String, String> h = new HashMap<>(2);
+                // Note "-" char is looked for in appendFoundJars
+                h.put(jars[i] + "-path", f.getAbsolutePath());
+
+                // We won't bother reporting on the xalan.jar apparent version
+                // since this requires knowing the jar size of the xalan.jar
+                // before we build it.
+                // For other jars, eg. xml-apis.jar and xercesImpl.jar, we
+                // report the apparent version of the file we've found
+                if (!("xalan.jar".equalsIgnoreCase(jars[i]))) {
+                    h.put(jars[i] + "-apparent.version",
+                            getApparentVersion(jars[i], f.length()));
+                }
+                v.add(h);
+            } catch (Exception e) {
 
-              /* no-op, don't add it  */
+                /* no-op, don't add it  */
             }
-          }
-          else
-          {
-            Hashtable h = new Hashtable(2);
+          } else {
+            Map<String, String> h = new HashMap<>(2);
             // Note "-" char is looked for in appendFoundJars
             h.put(jars[i] + "-path", WARNING + " Classpath entry: "
-                  + filename + " does not exist");
+                    + filename + " does not exist");
             h.put(jars[i] + "-apparent.version", CLASS_NOTPRESENT);
-            v.addElement(h);
+            v.add(h);
           }
         }
       }
@@ -748,8 +696,8 @@ public class EnvironmentCheck
   {
     // If we found a matching size and it's for our
     //  jar, then return it's description
-    // Lookup in static jarVersions Hashtable
-    String foundSize = (String) jarVersions.get(new Long(jarSize));
+    // Lookup in static JARVERSIONS Map
+    String foundSize = JARVERSIONS.get(new Long(jarSize));
 
     if ((null != foundSize) && (foundSize.startsWith(jarName)))
     {
@@ -783,13 +731,13 @@ public class EnvironmentCheck
    * and not found; only tests the interfaces, and does not
    * check for reference implementation versions.
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    */
-  protected void checkJAXPVersion(Hashtable h)
+  protected void checkJAXPVersion(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     Class clazz = null;
 
@@ -814,13 +762,13 @@ public class EnvironmentCheck
    *
    * Looks for version info in xalan.jar from Xalan-J products.
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    */
-  protected void checkProcessorVersion(Hashtable h)
+  protected void checkProcessorVersion(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     try
     {
@@ -900,13 +848,13 @@ public class EnvironmentCheck
    *
    * //@todo actually look up version info in crimson manifest
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    */
-  protected void checkParserVersion(Hashtable h)
+  protected void checkParserVersion(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     try
     {
@@ -961,13 +909,13 @@ public class EnvironmentCheck
   /**
    * Report product version information from Ant.
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    */
-  protected void checkAntVersion(Hashtable h)
+  protected void checkAntVersion(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     try
     {
@@ -991,13 +939,13 @@ public class EnvironmentCheck
   /**
    * Report version info from DOM interfaces.
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    */
-  protected boolean checkDOML3(Hashtable h)
+  protected boolean checkDOML3(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     final String DOM_CLASS = "org.w3c.dom.Document";
     final String DOM_LEVEL3_METHOD = "getDoctype";  // no parameter
@@ -1026,13 +974,13 @@ public class EnvironmentCheck
    * level 2 working draft, the DOM level 2 final draft,
    * and not found.
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    */
-  protected void checkDOMVersion(Hashtable h)
+  protected void checkDOMVersion(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     final String DOM_LEVEL2_CLASS = "org.w3c.dom.Document";
     final String DOM_LEVEL2_METHOD = "createElementNS";  // String, String
@@ -1102,13 +1050,13 @@ public class EnvironmentCheck
    * Currently distinguishes between SAX 2, SAX 2.0beta2,
    * SAX1, and not found.
    *
-   * @param h Hashtable to put information in
+   * @param h Map to put information in
    */
-  protected void checkSAXVersion(Hashtable h)
+  protected void checkSAXVersion(Map<String, Object> h)
   {
 
     if (null == h)
-      h = new Hashtable();
+      h = new HashMap<>();
 
     final String SAX_VERSION1_CLASS = "org.xml.sax.Parser";
     final String SAX_VERSION1_METHOD = "parse";  // String
@@ -1188,17 +1136,17 @@ public class EnvironmentCheck
    *
    * @see #getApparentVersion(String, long)
    */
-  private static Hashtable jarVersions = new Hashtable();
+  private static final Map<Long, String> JARVERSIONS;
 
   /**
-   * Static initializer for jarVersions table.
+   * Static initializer for JARVERSIONS table.
    * Doing this just once saves time and space.
    *
    * @see #getApparentVersion(String, long)
    */
   static
   {
-    // Note: hackish Hashtable, this could use improvement
+    Map<Long, String> jarVersions = new HashMap<>();
     jarVersions.put(new Long(857192), "xalan.jar from xalan-j_1_1");
     jarVersions.put(new Long(440237), "xalan.jar from xalan-j_1_2");
     jarVersions.put(new Long(436094), "xalan.jar from xalan-j_1_2_1");
@@ -1287,6 +1235,8 @@ public class EnvironmentCheck
     // jakarta-ant: since many people use ant these days
     jarVersions.put(new Long(136198), "parser.jar from jakarta-ant-1.3 or 1.2");
     jarVersions.put(new Long(5537), "jaxp.jar from jakarta-ant-1.3 or 1.2");
+
+    JARVERSIONS = Collections.unmodifiableMap(jarVersions);
   }
 
   /** Simple PrintWriter we send output to; defaults to System.out.  */
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/DOM.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/DOM.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/DOM.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,14 +23,12 @@
 
 package com.sun.org.apache.xalan.internal.xsltc;
 
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
-
+import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
+import java.util.Map;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
-import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
-
 /**
  * @author Jacek Ambroziak
  * @author Santiago Pericas-Geertsen
@@ -103,5 +101,5 @@ public interface DOM {
     public int getNSType(int node);
     public int getDocument();
     public String getUnparsedEntityURI(String name);
-    public Hashtable getElementsWithIDs();
+    public Map<String, Integer> getElementsWithIDs();
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/ApplyTemplates.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/ApplyTemplates.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/ApplyTemplates.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,9 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.INVOKEINTERFACE;
 import com.sun.org.apache.bcel.internal.generic.INVOKEVIRTUAL;
@@ -41,6 +38,8 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
 import com.sun.org.apache.xml.internal.utils.XML11Char;
+import java.util.Iterator;
+import java.util.Vector;
 
 /**
  * @author Jacek Ambroziak
@@ -122,9 +121,9 @@ final class ApplyTemplates extends Instr
 
         // check if sorting nodes is required
         final Vector sortObjects = new Vector();
-        final Enumeration children = elements();
-        while (children.hasMoreElements()) {
-            final Object child = children.nextElement();
+        final Iterator<SyntaxTreeNode> children = elements();
+        while (children.hasNext()) {
+            final SyntaxTreeNode child = children.next();
             if (child instanceof Sort) {
                 sortObjects.addElement(child);
             }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/AttributeSet.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/AttributeSet.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/AttributeSet.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,9 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.INVOKESPECIAL;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
@@ -37,6 +34,8 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
 import com.sun.org.apache.xml.internal.utils.XML11Char;
+import java.util.Iterator;
+import java.util.List;
 
 /**
  * @author Jacek Ambroziak
@@ -111,10 +110,10 @@ final class AttributeSet extends TopLeve
 
         // Parse the contents of this node. All child elements must be
         // <xsl:attribute> elements. Other elements cause an error.
-        final Vector contents = getContents();
+        final List<SyntaxTreeNode> contents = getContents();
         final int count = contents.size();
         for (int i=0; i<count; i++) {
-            SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
+            SyntaxTreeNode child = contents.get(i);
             if (child instanceof XslAttribute) {
                 parser.getSymbolTable().setCurrentNode(child);
                 child.parseContents(parser);
@@ -181,9 +180,9 @@ final class AttributeSet extends TopLeve
         if (_useSets != null) _useSets.translate(classGen, methodGen);
 
         // Translate all local attributes
-        final Enumeration attributes = elements();
-        while (attributes.hasMoreElements()) {
-            SyntaxTreeNode element = (SyntaxTreeNode)attributes.nextElement();
+        final Iterator<SyntaxTreeNode> attributes = elements();
+        while (attributes.hasNext()) {
+            SyntaxTreeNode element = attributes.next();
             if (element instanceof XslAttribute) {
                 final XslAttribute attribute = (XslAttribute)element;
                 attribute.translate(classGen, methodGen);
@@ -198,10 +197,10 @@ final class AttributeSet extends TopLeve
     public String toString() {
         StringBuffer buf = new StringBuffer("attribute-set: ");
         // Translate all local attributes
-        final Enumeration attributes = elements();
-        while (attributes.hasMoreElements()) {
+        final Iterator<SyntaxTreeNode> attributes = elements();
+        while (attributes.hasNext()) {
             final XslAttribute attribute =
-                (XslAttribute)attributes.nextElement();
+                (XslAttribute)attributes.next();
             buf.append(attribute);
         }
         return(buf.toString());
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/AttributeValueTemplate.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/AttributeValueTemplate.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/AttributeValueTemplate.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,11 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Vector;
-import java.util.StringTokenizer;
-import java.util.NoSuchElementException;
-
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.INVOKESPECIAL;
 import com.sun.org.apache.bcel.internal.generic.INVOKEVIRTUAL;
@@ -39,6 +34,10 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.StringTokenizer;
 
 /**
  * @author Jacek Ambroziak
@@ -206,12 +205,12 @@ final class AttributeValueTemplate exten
     }
 
     public Type typeCheck(SymbolTable stable) throws TypeCheckError {
-        final Vector contents = getContents();
+        final List<SyntaxTreeNode> contents = getContents();
         final int n = contents.size();
         for (int i = 0; i < n; i++) {
-            final Expression exp = (Expression)contents.elementAt(i);
+            final Expression exp = (Expression)contents.get(i);
             if (!exp.typeCheck(stable).identicalTo(Type.String)) {
-                contents.setElementAt(new CastExpr(exp, Type.String), i);
+                contents.set(i, new CastExpr(exp, Type.String));
             }
         }
         return _type = Type.String;
@@ -251,9 +250,9 @@ final class AttributeValueTemplate exten
             il.append(DUP);
             il.append(new INVOKESPECIAL(initBuffer));
             // StringBuffer is on the stack
-            final Enumeration elements = elements();
-            while (elements.hasMoreElements()) {
-                final Expression exp = (Expression)elements.nextElement();
+            final Iterator<SyntaxTreeNode> elements = elements();
+            while (elements.hasNext()) {
+                final Expression exp = (Expression)elements.next();
                 exp.translate(classGen, methodGen);
                 il.append(append);
             }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/CastExpr.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/CastExpr.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/CastExpr.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -51,7 +51,7 @@ final class CastExpr extends Expression
     /**
      * Legal conversions between internal types.
      */
-    static private MultiHashtable InternalTypeMap = new MultiHashtable();
+    private static final MultiHashtable<Type, Type> InternalTypeMap = new MultiHashtable<>();
 
     static {
         // Possible type conversions between internal types
@@ -118,6 +118,8 @@ final class CastExpr extends Expression
         InternalTypeMap.put(Type.Object, Type.String);
 
         InternalTypeMap.put(Type.Void, Type.String);
+
+        InternalTypeMap.makeUnmodifiable();
     }
 
     private boolean _typeTest = false;
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Choose.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Choose.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Choose.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,9 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.BranchHandle;
 import com.sun.org.apache.bcel.internal.generic.GOTO;
 import com.sun.org.apache.bcel.internal.generic.IFEQ;
@@ -37,6 +34,9 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.Vector;
 
 /**
  * @author Jacek Ambroziak
@@ -62,15 +62,15 @@ final class Choose extends Instruction {
     public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
         final Vector whenElements = new Vector();
         Otherwise otherwise = null;
-        Enumeration elements = elements();
+        Iterator<SyntaxTreeNode> elements = elements();
 
         // These two are for reporting errors only
         ErrorMsg error = null;
         final int line = getLineNumber();
 
         // Traverse all child nodes - must be either When or Otherwise
-        while (elements.hasMoreElements()) {
-            Object element = elements.nextElement();
+        while (elements.hasNext()) {
+            SyntaxTreeNode element = elements.next();
             // Add a When child element
             if (element instanceof When) {
                 whenElements.addElement(element);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/ForEach.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/ForEach.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/ForEach.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,9 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.BranchHandle;
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.GOTO;
@@ -42,6 +39,8 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
+import java.util.Iterator;
+import java.util.Vector;
 
 /**
  * @author Jacek Ambroziak
@@ -97,9 +96,9 @@ final class ForEach extends Instruction
 
         // Collect sort objects associated with this instruction
         final Vector sortObjects = new Vector();
-        Enumeration children = elements();
-        while (children.hasMoreElements()) {
-            final Object child = children.nextElement();
+        Iterator<SyntaxTreeNode> children = elements();
+        while (children.hasNext()) {
+            final SyntaxTreeNode child = children.next();
             if (child instanceof Sort) {
                 sortObjects.addElement(child);
             }
@@ -187,7 +186,7 @@ final class ForEach extends Instruction
                                    MethodGenerator methodGen) {
         final int n = elementCount();
         for (int i = 0; i < n; i++) {
-            final Object child = getContents().elementAt(i);
+            final SyntaxTreeNode child = getContents().get(i);
             if (child instanceof Variable) {
                 Variable var = (Variable)child;
                 var.initialize(classGen, methodGen);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -23,13 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.IFEQ;
 import com.sun.org.apache.bcel.internal.generic.INVOKEINTERFACE;
@@ -43,6 +36,7 @@ import com.sun.org.apache.bcel.internal.
 import com.sun.org.apache.bcel.internal.generic.NEW;
 import com.sun.org.apache.bcel.internal.generic.PUSH;
 import com.sun.org.apache.xalan.internal.utils.FeatureManager;
+import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.BooleanType;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
@@ -54,8 +48,15 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ReferenceType;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
-import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
 import com.sun.org.apache.xalan.internal.utils.Objects;
+import java.util.Vector;
 
 /**
  * @author Jacek Ambroziak
@@ -138,23 +139,23 @@ class FunctionCall extends Expression {
     private boolean       _isStatic = false;
 
     // Legal conversions between internal and Java types.
-    private static final MultiHashtable _internal2Java = new MultiHashtable();
+    private static final MultiHashtable<Type, JavaType> _internal2Java = new MultiHashtable<>();
 
     // Legal conversions between Java and internal types.
-    private static final Hashtable _java2Internal = new Hashtable();
+    private static final Map<Class<?>, Type> JAVA2INTERNAL;
 
     // The mappings between EXSLT extension namespaces and implementation classes
-    private static final Hashtable _extensionNamespaceTable = new Hashtable();
+    private static final Map<String, String> EXTENSIONNAMESPACE;
 
     // Extension functions that are implemented in BasisLibrary
-    private static final Hashtable _extensionFunctionTable = new Hashtable();
+    private static final Map<String, String> EXTENSIONFUNCTION;
     /**
      * inner class to used in internal2Java mappings, contains
      * the Java type and the distance between the internal type and
      * the Java type.
      */
     static class JavaType {
-        public Class  type;
+        public Class<?>  type;
         public int distance;
 
         public JavaType(Class type, int distance){
@@ -168,8 +169,15 @@ class FunctionCall extends Expression {
         }
 
         @Override
-        public boolean equals(Object query){
-            return query != null && query.equals(type);
+        public boolean equals(Object query) {
+            if (query == null) {
+                return false;
+            }
+            if (query.getClass().isAssignableFrom(JavaType.class)) {
+                return ((JavaType)query).type.equals(type);
+            } else {
+                return query.equals(type);
+            }
         }
     }
 
@@ -180,99 +188,112 @@ class FunctionCall extends Expression {
      * These two tables are used when calling external (Java) functions.
      */
     static {
+        final Class<?> nodeClass, nodeListClass;
         try {
-            final Class nodeClass     = Class.forName("org.w3c.dom.Node");
-            final Class nodeListClass = Class.forName("org.w3c.dom.NodeList");
-
-            // -- Internal to Java --------------------------------------------
-
-            // Type.Boolean -> { boolean(0), Boolean(1), Object(2) }
-            _internal2Java.put(Type.Boolean, new JavaType(Boolean.TYPE, 0));
-            _internal2Java.put(Type.Boolean, new JavaType(Boolean.class, 1));
-            _internal2Java.put(Type.Boolean, new JavaType(Object.class, 2));
-
-            // Type.Real -> { double(0), Double(1), float(2), long(3), int(4),
-            //                short(5), byte(6), char(7), Object(8) }
-            _internal2Java.put(Type.Real, new JavaType(Double.TYPE, 0));
-            _internal2Java.put(Type.Real, new JavaType(Double.class, 1));
-            _internal2Java.put(Type.Real, new JavaType(Float.TYPE, 2));
-            _internal2Java.put(Type.Real, new JavaType(Long.TYPE, 3));
-            _internal2Java.put(Type.Real, new JavaType(Integer.TYPE, 4));
-            _internal2Java.put(Type.Real, new JavaType(Short.TYPE, 5));
-            _internal2Java.put(Type.Real, new JavaType(Byte.TYPE, 6));
-            _internal2Java.put(Type.Real, new JavaType(Character.TYPE, 7));
-            _internal2Java.put(Type.Real, new JavaType(Object.class, 8));
-
-            // Type.Int must be the same as Type.Real
-            _internal2Java.put(Type.Int, new JavaType(Double.TYPE, 0));
-            _internal2Java.put(Type.Int, new JavaType(Double.class, 1));
-            _internal2Java.put(Type.Int, new JavaType(Float.TYPE, 2));
-            _internal2Java.put(Type.Int, new JavaType(Long.TYPE, 3));
-            _internal2Java.put(Type.Int, new JavaType(Integer.TYPE, 4));
-            _internal2Java.put(Type.Int, new JavaType(Short.TYPE, 5));
-            _internal2Java.put(Type.Int, new JavaType(Byte.TYPE, 6));
-            _internal2Java.put(Type.Int, new JavaType(Character.TYPE, 7));
-            _internal2Java.put(Type.Int, new JavaType(Object.class, 8));
-
-            // Type.String -> { String(0), Object(1) }
-            _internal2Java.put(Type.String, new JavaType(String.class, 0));
-            _internal2Java.put(Type.String, new JavaType(Object.class, 1));
-
-            // Type.NodeSet -> { NodeList(0), Node(1), Object(2), String(3) }
-            _internal2Java.put(Type.NodeSet, new JavaType(nodeListClass, 0));
-            _internal2Java.put(Type.NodeSet, new JavaType(nodeClass, 1));
-            _internal2Java.put(Type.NodeSet, new JavaType(Object.class, 2));
-            _internal2Java.put(Type.NodeSet, new JavaType(String.class, 3));
-
-            // Type.Node -> { Node(0), NodeList(1), Object(2), String(3) }
-            _internal2Java.put(Type.Node, new JavaType(nodeListClass, 0));
-            _internal2Java.put(Type.Node, new JavaType(nodeClass, 1));
-            _internal2Java.put(Type.Node, new JavaType(Object.class, 2));
-            _internal2Java.put(Type.Node, new JavaType(String.class, 3));
-
-            // Type.ResultTree -> { NodeList(0), Node(1), Object(2), String(3) }
-            _internal2Java.put(Type.ResultTree, new JavaType(nodeListClass, 0));
-            _internal2Java.put(Type.ResultTree, new JavaType(nodeClass, 1));
-            _internal2Java.put(Type.ResultTree, new JavaType(Object.class, 2));
-            _internal2Java.put(Type.ResultTree, new JavaType(String.class, 3));
-
-            _internal2Java.put(Type.Reference, new JavaType(Object.class, 0));
-
-            // Possible conversions between Java and internal types
-            _java2Internal.put(Boolean.TYPE, Type.Boolean);
-            _java2Internal.put(Void.TYPE, Type.Void);
-            _java2Internal.put(Character.TYPE, Type.Real);
-            _java2Internal.put(Byte.TYPE, Type.Real);
-            _java2Internal.put(Short.TYPE, Type.Real);
-            _java2Internal.put(Integer.TYPE, Type.Real);
-            _java2Internal.put(Long.TYPE, Type.Real);
-            _java2Internal.put(Float.TYPE, Type.Real);
-            _java2Internal.put(Double.TYPE, Type.Real);
-
-            _java2Internal.put(String.class, Type.String);
-
-            _java2Internal.put(Object.class, Type.Reference);
-
-            // Conversions from org.w3c.dom.Node/NodeList to internal NodeSet
-            _java2Internal.put(nodeListClass, Type.NodeSet);
-            _java2Internal.put(nodeClass, Type.NodeSet);
-
-            // Initialize the extension namespace table
-            _extensionNamespaceTable.put(EXT_XALAN, "com.sun.org.apache.xalan.internal.lib.Extensions");
-            _extensionNamespaceTable.put(EXSLT_COMMON, "com.sun.org.apache.xalan.internal.lib.ExsltCommon");
-            _extensionNamespaceTable.put(EXSLT_MATH, "com.sun.org.apache.xalan.internal.lib.ExsltMath");
-            _extensionNamespaceTable.put(EXSLT_SETS, "com.sun.org.apache.xalan.internal.lib.ExsltSets");
-            _extensionNamespaceTable.put(EXSLT_DATETIME, "com.sun.org.apache.xalan.internal.lib.ExsltDatetime");
-            _extensionNamespaceTable.put(EXSLT_STRINGS, "com.sun.org.apache.xalan.internal.lib.ExsltStrings");
-
-            // Initialize the extension function table
-            _extensionFunctionTable.put(EXSLT_COMMON + ":nodeSet", "nodeset");
-            _extensionFunctionTable.put(EXSLT_COMMON + ":objectType", "objectType");
-            _extensionFunctionTable.put(EXT_XALAN + ":nodeset", "nodeset");
+            nodeClass     = Class.forName("org.w3c.dom.Node");
+            nodeListClass = Class.forName("org.w3c.dom.NodeList");
         }
         catch (ClassNotFoundException e) {
-            System.err.println(e);
+            ErrorMsg err = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR,"org.w3c.dom.Node or NodeList");
+            throw new ExceptionInInitializerError(err.toString());
         }
+
+        // -- Internal to Java --------------------------------------------
+
+        // Type.Boolean -> { boolean(0), Boolean(1), Object(2) }
+        _internal2Java.put(Type.Boolean, new JavaType(Boolean.TYPE, 0));
+        _internal2Java.put(Type.Boolean, new JavaType(Boolean.class, 1));
+        _internal2Java.put(Type.Boolean, new JavaType(Object.class, 2));
+
+        // Type.Real -> { double(0), Double(1), float(2), long(3), int(4),
+        //                short(5), byte(6), char(7), Object(8) }
+        _internal2Java.put(Type.Real, new JavaType(Double.TYPE, 0));
+        _internal2Java.put(Type.Real, new JavaType(Double.class, 1));
+        _internal2Java.put(Type.Real, new JavaType(Float.TYPE, 2));
+        _internal2Java.put(Type.Real, new JavaType(Long.TYPE, 3));
+        _internal2Java.put(Type.Real, new JavaType(Integer.TYPE, 4));
+        _internal2Java.put(Type.Real, new JavaType(Short.TYPE, 5));
+        _internal2Java.put(Type.Real, new JavaType(Byte.TYPE, 6));
+        _internal2Java.put(Type.Real, new JavaType(Character.TYPE, 7));
+        _internal2Java.put(Type.Real, new JavaType(Object.class, 8));
+
+        // Type.Int must be the same as Type.Real
+        _internal2Java.put(Type.Int, new JavaType(Double.TYPE, 0));
+        _internal2Java.put(Type.Int, new JavaType(Double.class, 1));
+        _internal2Java.put(Type.Int, new JavaType(Float.TYPE, 2));
+        _internal2Java.put(Type.Int, new JavaType(Long.TYPE, 3));
+        _internal2Java.put(Type.Int, new JavaType(Integer.TYPE, 4));
+        _internal2Java.put(Type.Int, new JavaType(Short.TYPE, 5));
+        _internal2Java.put(Type.Int, new JavaType(Byte.TYPE, 6));
+        _internal2Java.put(Type.Int, new JavaType(Character.TYPE, 7));
+        _internal2Java.put(Type.Int, new JavaType(Object.class, 8));
+
+        // Type.String -> { String(0), Object(1) }
+        _internal2Java.put(Type.String, new JavaType(String.class, 0));
+        _internal2Java.put(Type.String, new JavaType(Object.class, 1));
+
+        // Type.NodeSet -> { NodeList(0), Node(1), Object(2), String(3) }
+        _internal2Java.put(Type.NodeSet, new JavaType(nodeListClass, 0));
+        _internal2Java.put(Type.NodeSet, new JavaType(nodeClass, 1));
+        _internal2Java.put(Type.NodeSet, new JavaType(Object.class, 2));
+        _internal2Java.put(Type.NodeSet, new JavaType(String.class, 3));
+
+        // Type.Node -> { Node(0), NodeList(1), Object(2), String(3) }
+        _internal2Java.put(Type.Node, new JavaType(nodeListClass, 0));
+        _internal2Java.put(Type.Node, new JavaType(nodeClass, 1));
+        _internal2Java.put(Type.Node, new JavaType(Object.class, 2));
+        _internal2Java.put(Type.Node, new JavaType(String.class, 3));
+
+        // Type.ResultTree -> { NodeList(0), Node(1), Object(2), String(3) }
+        _internal2Java.put(Type.ResultTree, new JavaType(nodeListClass, 0));
+        _internal2Java.put(Type.ResultTree, new JavaType(nodeClass, 1));
+        _internal2Java.put(Type.ResultTree, new JavaType(Object.class, 2));
+        _internal2Java.put(Type.ResultTree, new JavaType(String.class, 3));
+
+        _internal2Java.put(Type.Reference, new JavaType(Object.class, 0));
+
+        _internal2Java.makeUnmodifiable();
+
+        Map<Class<?>, Type> java2Internal = new HashMap<>();
+        Map<String, String> extensionNamespaceTable = new HashMap<>();
+        Map<String, String> extensionFunctionTable = new HashMap<>();
+
+        // Possible conversions between Java and internal types
+        java2Internal.put(Boolean.TYPE, Type.Boolean);
+        java2Internal.put(Void.TYPE, Type.Void);
+        java2Internal.put(Character.TYPE, Type.Real);
+        java2Internal.put(Byte.TYPE, Type.Real);
+        java2Internal.put(Short.TYPE, Type.Real);
+        java2Internal.put(Integer.TYPE, Type.Real);
+        java2Internal.put(Long.TYPE, Type.Real);
+        java2Internal.put(Float.TYPE, Type.Real);
+        java2Internal.put(Double.TYPE, Type.Real);
+
+        java2Internal.put(String.class, Type.String);
+
+        java2Internal.put(Object.class, Type.Reference);
+
+        // Conversions from org.w3c.dom.Node/NodeList to internal NodeSet
+        java2Internal.put(nodeListClass, Type.NodeSet);
+        java2Internal.put(nodeClass, Type.NodeSet);
+
+        // Initialize the extension namespace table
+        extensionNamespaceTable.put(EXT_XALAN, "com.sun.org.apache.xalan.internal.lib.Extensions");
+        extensionNamespaceTable.put(EXSLT_COMMON, "com.sun.org.apache.xalan.internal.lib.ExsltCommon");
+        extensionNamespaceTable.put(EXSLT_MATH, "com.sun.org.apache.xalan.internal.lib.ExsltMath");
+        extensionNamespaceTable.put(EXSLT_SETS, "com.sun.org.apache.xalan.internal.lib.ExsltSets");
+        extensionNamespaceTable.put(EXSLT_DATETIME, "com.sun.org.apache.xalan.internal.lib.ExsltDatetime");
+        extensionNamespaceTable.put(EXSLT_STRINGS, "com.sun.org.apache.xalan.internal.lib.ExsltStrings");
+
+        // Initialize the extension function table
+        extensionFunctionTable.put(EXSLT_COMMON + ":nodeSet", "nodeset");
+        extensionFunctionTable.put(EXSLT_COMMON + ":objectType", "objectType");
+        extensionFunctionTable.put(EXT_XALAN + ":nodeset", "nodeset");
+
+        JAVA2INTERNAL = Collections.unmodifiableMap(java2Internal);
+        EXTENSIONNAMESPACE = Collections.unmodifiableMap(extensionNamespaceTable);
+        EXTENSIONFUNCTION = Collections.unmodifiableMap(extensionFunctionTable);
+
     }
 
     public FunctionCall(QName fname, Vector arguments) {
@@ -304,7 +325,7 @@ class FunctionCall extends Expression {
 
     public String getClassNameFromUri(String uri)
     {
-        String className = (String)_extensionNamespaceTable.get(uri);
+        String className = EXTENSIONNAMESPACE.get(uri);
 
         if (className != null)
             return className;
@@ -384,7 +405,7 @@ class FunctionCall extends Expression {
                         local = replaceDash(local);
                     }
 
-                    String extFunction = (String)_extensionFunctionTable.get(namespace + ":" + local);
+                    String extFunction = EXTENSIONFUNCTION.get(namespace + ":" + local);
                     if (extFunction != null) {
                         _fname = new QName(null, null, extFunction);
                         return typeCheckStandard(stable);
@@ -464,15 +485,15 @@ class FunctionCall extends Expression {
                 (Constructor)constructors.elementAt(i);
             final Class[] paramTypes = constructor.getParameterTypes();
 
-            Class extType = null;
+            Class<?> extType;
             int currConstrDistance = 0;
             for (j = 0; j < nArgs; j++) {
                 // Convert from internal (translet) type to external (Java) type
                 extType = paramTypes[j];
                 final Type intType = (Type)argsType.elementAt(j);
-                Object match = _internal2Java.maps(intType, extType);
+                JavaType match = _internal2Java.maps(intType, new JavaType(extType, 0));
                 if (match != null) {
-                    currConstrDistance += ((JavaType)match).distance;
+                    currConstrDistance += match.distance;
                 }
                 else if (intType instanceof ObjectType) {
                     ObjectType objectType = (ObjectType)intType;
@@ -597,9 +618,9 @@ class FunctionCall extends Expression {
                 // Convert from internal (translet) type to external (Java) type
                 extType = paramTypes[j];
                 final Type intType = (Type)argsType.elementAt(j);
-                Object match = _internal2Java.maps(intType, extType);
+                JavaType match = _internal2Java.maps(intType, new JavaType(extType, 0));
                 if (match != null) {
-                    currMethodDistance += ((JavaType)match).distance;
+                    currMethodDistance += match.distance;
                 }
                 else {
                     // no mapping available
@@ -631,7 +652,7 @@ class FunctionCall extends Expression {
                   // Check if the return type can be converted
                   extType = method.getReturnType();
 
-                  _type = (Type) _java2Internal.get(extType);
+                  _type = JAVA2INTERNAL.get(extType);
                   if (_type == null) {
                       _type = Type.newObjectType(extType);
                   }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Import.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Import.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Import.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -31,10 +31,7 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
-import java.io.File;
-import java.net.URL;
-import java.net.MalformedURLException;
-import java.util.Enumeration;
+import java.util.Iterator;
 import javax.xml.XMLConstants;
 import org.xml.sax.InputSource;
 import org.xml.sax.XMLReader;
@@ -133,10 +130,10 @@ final class Import extends TopLevelEleme
             parser.setCurrentStylesheet(_imported);
             _imported.parseContents(parser);
 
-            final Enumeration elements = _imported.elements();
+            final Iterator<SyntaxTreeNode> elements = _imported.elements();
             final Stylesheet topStylesheet = parser.getTopLevelStylesheet();
-            while (elements.hasMoreElements()) {
-                final Object element = elements.nextElement();
+            while (elements.hasNext()) {
+                final SyntaxTreeNode element = elements.next();
                 if (element instanceof TopLevelElement) {
                     if (element instanceof Variable) {
                         topStylesheet.addVariable((Variable) element);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Include.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Include.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Include.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -31,11 +31,7 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.Enumeration;
+import java.util.Iterator;
 import javax.xml.XMLConstants;
 import org.xml.sax.InputSource;
 import org.xml.sax.XMLReader;
@@ -133,10 +129,10 @@ final class Include extends TopLevelElem
             parser.setCurrentStylesheet(_included);
             _included.parseContents(parser);
 
-            final Enumeration elements = _included.elements();
+            final Iterator<SyntaxTreeNode> elements = _included.elements();
             final Stylesheet topStylesheet = parser.getTopLevelStylesheet();
-            while (elements.hasMoreElements()) {
-                final Object element = elements.nextElement();
+            while (elements.hasNext()) {
+                final SyntaxTreeNode element = elements.next();
                 if (element instanceof TopLevelElement) {
                     if (element instanceof Variable) {
                         topStylesheet.addVariable((Variable) element);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Key.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Key.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Key.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -23,8 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.BranchHandle;
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.GOTO;
@@ -226,7 +224,7 @@ final class Key extends TopLevelElement
         // AbstractTranslet.buildKeyIndex(name,node_id,value) => void
         final int key = cpg.addMethodref(TRANSLET_CLASS,
                                          "buildKeyIndex",
-                                         "("+STRING_SIG+"I"+OBJECT_SIG+")V");
+                                         "("+STRING_SIG+"I"+STRING_SIG+")V");
 
         // AbstractTranslet.SetKeyIndexDom(name, Dom) => void
         final int keyDom = cpg.addMethodref(TRANSLET_CLASS,
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/LiteralElement.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/LiteralElement.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/LiteralElement.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -23,10 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.bcel.internal.generic.PUSH;
@@ -36,9 +32,13 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
-
 import com.sun.org.apache.xml.internal.serializer.ElemDesc;
 import com.sun.org.apache.xml.internal.serializer.ToHTMLStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 /**
  * @author Jacek Ambroziak
@@ -49,8 +49,8 @@ final class LiteralElement extends Instr
 
     private String _name;
     private LiteralElement _literalElemParent = null;
-    private Vector _attributeElements = null;
-    private Hashtable _accessedPrefixes = null;
+    private List<SyntaxTreeNode> _attributeElements = null;
+    private Map<String, String> _accessedPrefixes = null;
 
     // True if all attributes of this LRE are unique, i.e. they all have
     // different names. This flag is set to false if some attribute
@@ -85,14 +85,13 @@ final class LiteralElement extends Instr
                 return result;
             }
         }
-        return _accessedPrefixes != null ?
-            (String) _accessedPrefixes.get(prefix) : null;
+        return _accessedPrefixes != null ? _accessedPrefixes.get(prefix) : null;
     }
 
     /**
      * Method used to keep track of what namespaces that are references by
      * this literal element and its attributes. The output must contain a
-     * definition for each namespace, so we stuff them in a hashtable.
+     * definition for each namespace, so we stuff them in a map.
      */
     public void registerNamespace(String prefix, String uri,
                                   SymbolTable stable, boolean declared) {
@@ -107,12 +106,12 @@ final class LiteralElement extends Instr
 
         // Check if we have any declared namesaces
         if (_accessedPrefixes == null) {
-            _accessedPrefixes = new Hashtable();
+            _accessedPrefixes = new HashMap<>();
         }
         else {
             if (!declared) {
                 // Check if this node has a declaration for this namespace
-                final String old = (String)_accessedPrefixes.get(prefix);
+                final String old = _accessedPrefixes.get(prefix);
                 if (old != null) {
                     if (old.equals(uri))
                         return;
@@ -169,7 +168,7 @@ final class LiteralElement extends Instr
      */
     public void addAttribute(SyntaxTreeNode attribute) {
         if (_attributeElements == null) {
-            _attributeElements = new Vector(2);
+            _attributeElements = new ArrayList<>(2);
         }
         _attributeElements.add(attribute);
     }
@@ -179,9 +178,9 @@ final class LiteralElement extends Instr
      */
     public void setFirstAttribute(SyntaxTreeNode attribute) {
         if (_attributeElements == null) {
-            _attributeElements = new Vector(2);
+            _attributeElements = new ArrayList<>(2);
         }
-        _attributeElements.insertElementAt(attribute,0);
+        _attributeElements.add(0, attribute);
     }
 
     /**
@@ -191,10 +190,7 @@ final class LiteralElement extends Instr
     public Type typeCheck(SymbolTable stable) throws TypeCheckError {
         // Type-check all attributes
         if (_attributeElements != null) {
-            final int count = _attributeElements.size();
-            for (int i = 0; i < count; i++) {
-                SyntaxTreeNode node =
-                    (SyntaxTreeNode)_attributeElements.elementAt(i);
+            for (SyntaxTreeNode node : _attributeElements) {
                 node.typeCheck(stable);
             }
         }
@@ -207,15 +203,13 @@ final class LiteralElement extends Instr
      * and assembles a list of all prefixes that (for the given node) maps
      * to _ANY_ namespace URI. Used by literal result elements to determine
      */
-    public Enumeration getNamespaceScope(SyntaxTreeNode node) {
-        Hashtable all = new Hashtable();
+    public Set<Map.Entry<String, String>> getNamespaceScope(SyntaxTreeNode node) {
+        Map<String, String> all = new HashMap<>();
 
         while (node != null) {
-            Hashtable mapping = node.getPrefixMapping();
+            Map<String, String> mapping = node.getPrefixMapping();
             if (mapping != null) {
-                Enumeration prefixes = mapping.keys();
-                while (prefixes.hasMoreElements()) {
-                    String prefix = (String)prefixes.nextElement();
+                for( String prefix : mapping.keySet()) {
                     if (!all.containsKey(prefix)) {
                         all.put(prefix, mapping.get(prefix));
                     }
@@ -223,7 +217,7 @@ final class LiteralElement extends Instr
             }
             node = node.getParent();
         }
-        return(all.keys());
+        return all.entrySet();
     }
 
     /**
@@ -288,9 +282,9 @@ final class LiteralElement extends Instr
 
         // Register all namespaces that are in scope, except for those that
         // are listed in the xsl:stylesheet element's *-prefixes attributes
-        final Enumeration include = getNamespaceScope(this);
-        while (include.hasMoreElements()) {
-            final String prefix = (String)include.nextElement();
+        Set<Map.Entry<String, String>> include = getNamespaceScope(this);
+        for (Map.Entry<String, String> entry : include) {
+            final String prefix = entry.getKey();
             if (!prefix.equals("xml")) {
                 final String uri = lookupNamespace(prefix);
                 if (uri != null && !stable.isExcludedNamespace(uri)) {
@@ -356,11 +350,10 @@ final class LiteralElement extends Instr
         // Compile code to emit namespace attributes
         if (_accessedPrefixes != null) {
             boolean declaresDefaultNS = false;
-            Enumeration e = _accessedPrefixes.keys();
 
-            while (e.hasMoreElements()) {
-                final String prefix = (String)e.nextElement();
-                final String uri = (String)_accessedPrefixes.get(prefix);
+            for (Map.Entry<String, String> entry : _accessedPrefixes.entrySet()) {
+                final String prefix = entry.getKey();
+                final String uri = entry.getValue();
 
                 if (uri != Constants.EMPTYSTRING ||
                         prefix != Constants.EMPTYSTRING)
@@ -391,10 +384,7 @@ final class LiteralElement extends Instr
 
         // Output all attributes
         if (_attributeElements != null) {
-            final int count = _attributeElements.size();
-            for (int i = 0; i < count; i++) {
-                SyntaxTreeNode node =
-                    (SyntaxTreeNode)_attributeElements.elementAt(i);
+            for (SyntaxTreeNode node : _attributeElements) {
                 if (!(node instanceof XslAttribute)) {
                     node.translate(classGen, methodGen);
                 }
@@ -445,18 +435,18 @@ final class LiteralElement extends Instr
 
          if (_attributeElements != null) {
              int numAttrs = _attributeElements.size();
-             Hashtable attrsTable = null;
+             Map<String, SyntaxTreeNode> attrsTable = null;
              for (int i = 0; i < numAttrs; i++) {
-                 SyntaxTreeNode node = (SyntaxTreeNode)_attributeElements.elementAt(i);
+                 SyntaxTreeNode node = _attributeElements.get(i);
 
                  if (node instanceof UseAttributeSets) {
                      return false;
                  }
                  else if (node instanceof XslAttribute) {
                      if (attrsTable == null) {
-                        attrsTable = new Hashtable();
+                        attrsTable = new HashMap<>();
                          for (int k = 0; k < i; k++) {
-                             SyntaxTreeNode n = (SyntaxTreeNode)_attributeElements.elementAt(k);
+                             SyntaxTreeNode n = _attributeElements.get(k);
                              if (n instanceof LiteralAttribute) {
                                  LiteralAttribute literalAttr = (LiteralAttribute)n;
                                  attrsTable.put(literalAttr.getName(), literalAttr);
@@ -491,10 +481,8 @@ final class LiteralElement extends Instr
      * <xsl:attribute> children of the current node are not included in the check.
      */
     private boolean canProduceAttributeNodes(SyntaxTreeNode node, boolean ignoreXslAttribute) {
-        Vector contents = node.getContents();
-        int size = contents.size();
-        for (int i = 0; i < size; i++) {
-            SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
+        List<SyntaxTreeNode> contents = node.getContents();
+        for (SyntaxTreeNode child : contents) {
             if (child instanceof Text) {
                 Text text = (Text)child;
                 if (text.isIgnore())
@@ -532,10 +520,8 @@ final class LiteralElement extends Instr
                 return true;
             }
             else if (child instanceof Choose) {
-                Vector chooseContents = child.getContents();
-                int num = chooseContents.size();
-                for (int k = 0; k < num; k++) {
-                    SyntaxTreeNode chooseChild = (SyntaxTreeNode)chooseContents.elementAt(k);
+                List<SyntaxTreeNode> chooseContents = child.getContents();
+                for (SyntaxTreeNode chooseChild : chooseContents) {
                     if (chooseChild instanceof When || chooseChild instanceof Otherwise) {
                         if (canProduceAttributeNodes(chooseChild, false))
                             return true;
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Mode.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Mode.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Mode.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,12 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.Vector;
-
-import com.sun.org.apache.bcel.internal.generic.Instruction;
 import com.sun.org.apache.bcel.internal.generic.BranchHandle;
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.DUP;
@@ -38,6 +32,7 @@ import com.sun.org.apache.bcel.internal.
 import com.sun.org.apache.bcel.internal.generic.INVOKEINTERFACE;
 import com.sun.org.apache.bcel.internal.generic.INVOKEVIRTUAL;
 import com.sun.org.apache.bcel.internal.generic.ISTORE;
+import com.sun.org.apache.bcel.internal.generic.Instruction;
 import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
@@ -51,6 +46,12 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
 import com.sun.org.apache.xml.internal.dtm.Axis;
 import com.sun.org.apache.xml.internal.dtm.DTM;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.Vector;
 
 /**
  * Mode gathers all the templates belonging to a given mode;
@@ -128,22 +129,22 @@ final class Mode implements Constants {
     /**
      * A mapping between templates and test sequences.
      */
-    private Hashtable _neededTemplates = new Hashtable();
+    private Map<Template, Object> _neededTemplates = new HashMap<>();
 
     /**
      * A mapping between named templates and Mode objects.
      */
-    private Hashtable _namedTemplates = new Hashtable();
+    private Map<Template, Mode> _namedTemplates = new HashMap<>();
 
     /**
      * A mapping between templates and instruction handles.
      */
-    private Hashtable _templateIHs = new Hashtable();
+    private Map<Template, InstructionHandle> _templateIHs = new HashMap<>();
 
     /**
      * A mapping between templates and instruction lists.
      */
-    private Hashtable _templateILs = new Hashtable();
+    private Map<Template, InstructionList> _templateILs = new HashMap<>();
 
     /**
      * A reference to the pattern matching the root node.
@@ -152,14 +153,14 @@ final class Mode implements Constants {
 
     /**
      * Stores ranges of template precendences for the compilation
-     * of apply-imports (a Hashtable for historical reasons).
+     * of apply-imports.
      */
-    private Hashtable _importLevels = null;
+    private Map<Integer, Integer> _importLevels = null;
 
     /**
      * A mapping between key names and keys.
      */
-    private Hashtable _keys = null;
+    private Map<String, Key> _keys = null;
 
     /**
      * Variable index for the current node used in code generation.
@@ -195,9 +196,9 @@ final class Mode implements Constants {
 
     public String functionName(int min, int max) {
         if (_importLevels == null) {
-            _importLevels = new Hashtable();
+            _importLevels = new HashMap<>();
         }
-        _importLevels.put(new Integer(max), new Integer(min));
+        _importLevels.put(max, min);
         return _methodName + '_' + max;
     }
 
@@ -244,7 +245,7 @@ final class Mode implements Constants {
     /**
      * Process all the test patterns in this mode
      */
-    public void processPatterns(Hashtable keys) {
+    public void processPatterns(Map<String, Key> keys) {
         _keys = keys;
 
 /*
@@ -300,7 +301,7 @@ for (int i = 0; i < _templates.size(); i
      */
     private void flattenAlternative(Pattern pattern,
                                     Template template,
-                                    Hashtable keys) {
+                                    Map<String, Key> keys) {
         // Patterns on type id() and key() are special since they do not have
         // any kernel node type (it can be anything as long as the node is in
         // the id's or key's index).
@@ -560,15 +561,13 @@ for (int i = 0; i < _templates.size(); i
                                   MethodGenerator methodGen,
                                   InstructionHandle next)
     {
-        Enumeration templates = _namedTemplates.keys();
-        while (templates.hasMoreElements()) {
-            final Template template = (Template)templates.nextElement();
+        Set<Template> templates = _namedTemplates.keySet();
+        for (Template template : templates) {
             compileNamedTemplate(template, classGen);
         }
 
-        templates = _neededTemplates.keys();
-        while (templates.hasMoreElements()) {
-            final Template template = (Template)templates.nextElement();
+        templates = _neededTemplates.keySet();
+        for (Template template : templates) {
             if (template.hasContents()) {
                 // !!! TODO templates both named and matched
                 InstructionList til = template.compile(classGen, methodGen);
@@ -584,13 +583,12 @@ for (int i = 0; i < _templates.size(); i
     }
 
     private void appendTemplateCode(InstructionList body) {
-        final Enumeration templates = _neededTemplates.keys();
-        while (templates.hasMoreElements()) {
-            final Object iList =
-                _templateILs.get(templates.nextElement());
+        for (Template template : _neededTemplates.keySet()) {
+            final InstructionList iList = _templateILs.get(template);
             if (iList != null) {
-                body.append((InstructionList)iList);
+                body.append(iList);
             }
+
         }
     }
 
@@ -1043,11 +1041,8 @@ for (int i = 0; i < _templates.size(); i
 
         // Compile method(s) for <xsl:apply-imports/> for this mode
         if (_importLevels != null) {
-            Enumeration levels = _importLevels.keys();
-            while (levels.hasMoreElements()) {
-                Integer max = (Integer)levels.nextElement();
-                Integer min = (Integer)_importLevels.get(max);
-                compileApplyImports(classGen, min.intValue(), max.intValue());
+            for (Map.Entry<Integer, Integer> entry : _importLevels.entrySet()) {
+                compileApplyImports(classGen, entry.getValue(), entry.getKey());
             }
         }
     }
@@ -1055,9 +1050,7 @@ for (int i = 0; i < _templates.size(); i
     private void compileTemplateCalls(ClassGenerator classGen,
                                       MethodGenerator methodGen,
                                       InstructionHandle next, int min, int max){
-        Enumeration templates = _neededTemplates.keys();
-        while (templates.hasMoreElements()) {
-            final Template template = (Template)templates.nextElement();
+        for (Template template : _neededTemplates.keySet()) {
             final int prec = template.getImportPrecedence();
             if ((prec >= min) && (prec < max)) {
                 if (template.hasContents()) {
@@ -1081,10 +1074,10 @@ for (int i = 0; i < _templates.size(); i
         final Vector names      = xsltc.getNamesIndex();
 
         // Clear some datastructures
-        _namedTemplates = new Hashtable();
-        _neededTemplates = new Hashtable();
-        _templateIHs = new Hashtable();
-        _templateILs = new Hashtable();
+        _namedTemplates = new HashMap<>();
+        _neededTemplates = new HashMap<>();
+        _templateIHs = new HashMap<>();
+        _templateILs = new HashMap<>();
         _patternGroups = new Vector[32];
         _rootPattern = null;
 
@@ -1503,7 +1496,7 @@ for (int i = 0; i < _templates.size(); i
     }
 
     public InstructionHandle getTemplateInstructionHandle(Template template) {
-        return (InstructionHandle)_templateIHs.get(template);
+        return _templateIHs.get(template);
     }
 
     /**
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -37,9 +37,10 @@ import com.sun.org.apache.xml.internal.s
 import java.io.File;
 import java.io.IOException;
 import java.io.StringReader;
-import java.util.Dictionary;
-import java.util.Enumeration;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 import java.util.Properties;
 import java.util.Stack;
 import java.util.StringTokenizer;
@@ -77,14 +78,14 @@ public class Parser implements Constants
     private Vector _errors;           // Contains all compilation errors
     private Vector _warnings;         // Contains all compilation errors
 
-    private Hashtable   _instructionClasses; // Maps instructions to classes
-    private Hashtable   _instructionAttrs;;  // reqd and opt attrs
-    private Hashtable   _qNames;
-    private Hashtable   _namespaces;
+    private Map<String, String>   _instructionClasses; // Maps instructions to classes
+    private Map<String, String[]> _instructionAttrs;  // reqd and opt attrs
+    private Map<String, QName>   _qNames;
+    private Map<String, Map>     _namespaces;
     private QName       _useAttributeSets;
     private QName       _excludeResultPrefixes;
     private QName       _extensionElementPrefixes;
-    private Hashtable   _variableScope;
+    private Map<String, Object>   _variableScope;
     private Stylesheet  _currentStylesheet;
     private SymbolTable _symbolTable; // Maps QNames to syntax-tree nodes
     private Output      _output;
@@ -106,11 +107,11 @@ public class Parser implements Constants
     }
 
     public void init() {
-        _qNames              = new Hashtable(512);
-        _namespaces          = new Hashtable();
-        _instructionClasses  = new Hashtable();
-        _instructionAttrs    = new Hashtable();
-        _variableScope       = new Hashtable();
+        _qNames              = new HashMap<>(512);
+        _namespaces          = new HashMap<>();
+        _instructionClasses  = new HashMap<>();
+        _instructionAttrs    = new HashMap<>();
+        _variableScope       = new HashMap<>();
         _template            = null;
         _errors              = new Vector();
         _warnings            = new Vector();
@@ -169,7 +170,7 @@ public class Parser implements Constants
     }
 
     private void addVariableOrParam(VariableBase var) {
-        Object existing = _variableScope.get(var.getName());
+        Object existing = _variableScope.get(var.getName().getStringRep());
         if (existing != null) {
             if (existing instanceof Stack) {
                 Stack stack = (Stack)existing;
@@ -179,26 +180,26 @@ public class Parser implements Constants
                 Stack stack = new Stack();
                 stack.push(existing);
                 stack.push(var);
-                _variableScope.put(var.getName(), stack);
+                _variableScope.put(var.getName().getStringRep(), stack);
             }
         }
         else {
-            _variableScope.put(var.getName(), var);
+            _variableScope.put(var.getName().getStringRep(), var);
         }
     }
 
     public void removeVariable(QName name) {
-        Object existing = _variableScope.get(name);
+        Object existing = _variableScope.get(name.getStringRep());
         if (existing instanceof Stack) {
             Stack stack = (Stack)existing;
             if (!stack.isEmpty()) stack.pop();
             if (!stack.isEmpty()) return;
         }
-        _variableScope.remove(name);
+        _variableScope.remove(name.getStringRep());
     }
 
     public VariableBase lookupVariable(QName name) {
-        Object existing = _variableScope.get(name);
+        Object existing = _variableScope.get(name.getStringRep());
         if (existing instanceof VariableBase) {
             return((VariableBase)existing);
         }
@@ -305,7 +306,7 @@ public class Parser implements Constants
 
     public QName getQName(String namespace, String prefix, String localname) {
         if (namespace == null || namespace.equals(EMPTYSTRING)) {
-            QName name = (QName)_qNames.get(localname);
+            QName name = _qNames.get(localname);
             if (name == null) {
                 name = new QName(null, prefix, localname);
                 _qNames.put(localname, name);
@@ -313,7 +314,7 @@ public class Parser implements Constants
             return name;
         }
         else {
-            Dictionary space = (Dictionary)_namespaces.get(namespace);
+            Map<String, QName> space = _namespaces.get(namespace);
             String lexicalQName =
                        (prefix == null || prefix.length() == 0)
                             ? localname
@@ -321,12 +322,12 @@ public class Parser implements Constants
 
             if (space == null) {
                 final QName name = new QName(namespace, prefix, localname);
-                _namespaces.put(namespace, space = new Hashtable());
+                _namespaces.put(namespace, space = new HashMap<>());
                 space.put(lexicalQName, name);
                 return name;
             }
             else {
-                QName name = (QName)space.get(lexicalQName);
+                QName name = space.get(lexicalQName);
                 if (name == null) {
                     name = new QName(namespace, prefix, localname);
                     space.put(lexicalQName, name);
@@ -397,9 +398,9 @@ public class Parser implements Constants
             if (stylesheet != null) {
                 stylesheet.parseContents(this);
                 final int precedence = stylesheet.getImportPrecedence();
-                final Enumeration elements = stylesheet.elements();
-                while (elements.hasMoreElements()) {
-                    Object child = elements.nextElement();
+                final Iterator<SyntaxTreeNode> elements = stylesheet.elements();
+                while (elements.hasNext()) {
+                    SyntaxTreeNode child = elements.next();
                     if (child instanceof Text) {
                         final int l = getLineNumber();
                         ErrorMsg err =
@@ -609,11 +610,11 @@ public class Parser implements Constants
             String id = root.getAttribute("id");
             if (id.equals(href)) return root;
         }
-        Vector children = root.getContents();
+        List<SyntaxTreeNode> children = root.getContents();
         if (children != null) {
             final int count = children.size();
             for (int i = 0; i < count; i++) {
-                SyntaxTreeNode child = (SyntaxTreeNode)children.elementAt(i);
+                SyntaxTreeNode child = children.get(i);
                 SyntaxTreeNode node = findStylesheet(child, href);
                 if (node != null) return node;
             }
@@ -640,7 +641,7 @@ public class Parser implements Constants
     }
 
     private void initAttrTable(String elementName, String[] attrs) {
-        _instructionAttrs.put(getQName(XSLT_URI, XSL, elementName),
+        _instructionAttrs.put(getQName(XSLT_URI, XSL, elementName).getStringRep(),
                                 attrs);
     }
 
@@ -704,7 +705,7 @@ public class Parser implements Constants
 
 
     /**
-     * Initialize the _instructionClasses Hashtable, which maps XSL element
+     * Initialize the _instructionClasses map, which maps XSL element
      * names to Java classes in this package.
      */
     private void initStdClasses() {
@@ -746,12 +747,12 @@ public class Parser implements Constants
     }
 
     private void initStdClass(String elementName, String className) {
-        _instructionClasses.put(getQName(XSLT_URI, XSL, elementName),
+        _instructionClasses.put(getQName(XSLT_URI, XSL, elementName).getStringRep(),
                                 COMPILER_PACKAGE + '.' + className);
     }
 
     public boolean elementSupported(String namespace, String localName) {
-        return(_instructionClasses.get(getQName(namespace, XSL, localName)) != null);
+        return(_instructionClasses.get(getQName(namespace, XSL, localName).getStringRep()) != null);
     }
 
     public boolean functionSupported(String fname) {
@@ -764,12 +765,12 @@ public class Parser implements Constants
     }
 
     private void initExtClass(String elementName, String className) {
-        _instructionClasses.put(getQName(TRANSLET_URI, TRANSLET, elementName),
+        _instructionClasses.put(getQName(TRANSLET_URI, TRANSLET, elementName).getStringRep(),
                                 COMPILER_PACKAGE + '.' + className);
     }
 
     private void initExtClass(String namespace, String elementName, String className) {
-        _instructionClasses.put(getQName(namespace, TRANSLET, elementName),
+        _instructionClasses.put(getQName(namespace, TRANSLET, elementName).getStringRep(),
                                 COMPILER_PACKAGE + '.' + className);
     }
 
@@ -969,7 +970,7 @@ public class Parser implements Constants
     {
         SyntaxTreeNode node = null;
         QName  qname = getQName(uri, prefix, local);
-        String className = (String)_instructionClasses.get(qname);
+        String className = _instructionClasses.get(qname.getStringRep());
 
         if (className != null) {
             try {
@@ -1052,7 +1053,7 @@ public class Parser implements Constants
     {
         QName qname = node.getQName();
         boolean isStylesheet = (node instanceof Stylesheet);
-        String[] legal = (String[]) _instructionAttrs.get(qname);
+        String[] legal = _instructionAttrs.get(qname.getStringRep());
         if (versionIsOne && legal != null) {
             int j;
             final int n = attrs.getLength();
@@ -1250,7 +1251,7 @@ public class Parser implements Constants
     /************************ SAX2 ContentHandler INTERFACE *****************/
 
     private Stack _parentStack = null;
-    private Hashtable _prefixMapping = null;
+    private Map<String, String> _prefixMapping = null;
 
     /**
      * SAX2: Receive notification of the beginning of a document.
@@ -1274,7 +1275,7 @@ public class Parser implements Constants
      */
     public void startPrefixMapping(String prefix, String uri) {
         if (_prefixMapping == null) {
-            _prefixMapping = new Hashtable();
+            _prefixMapping = new HashMap<>();
         }
         _prefixMapping.put(prefix, uri);
     }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Stylesheet.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Stylesheet.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Stylesheet.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -23,14 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Vector;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.Properties;
-import java.util.StringTokenizer;
-
-import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
 import com.sun.org.apache.bcel.internal.generic.ANEWARRAY;
 import com.sun.org.apache.bcel.internal.generic.BasicType;
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
@@ -59,6 +51,14 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
 import com.sun.org.apache.xml.internal.dtm.DTM;
+import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.StringTokenizer;
+import java.util.Vector;
 
 /**
  * @author Jacek Ambroziak
@@ -121,7 +121,7 @@ public final class Stylesheet extends Sy
     /**
      * Mapping between mode names and Mode instances.
      */
-    private final Hashtable _modes = new Hashtable();
+    private final Map<String, Mode> _modes = new HashMap<>();
 
     /**
      * A reference to the default Mode object.
@@ -131,7 +131,7 @@ public final class Stylesheet extends Sy
     /**
      * Mapping between extension URIs and their prefixes.
      */
-    private final Hashtable _extensions = new Hashtable();
+    private final Map<String, String> _extensions = new HashMap<>();
 
     /**
      * Reference to the stylesheet from which this stylesheet was
@@ -164,7 +164,7 @@ public final class Stylesheet extends Sy
     /**
      * Mapping between key names and Key objects (needed by Key/IdPattern).
      */
-    private Hashtable _keys = new Hashtable();
+    private Map<String, Key> _keys = new HashMap<>();
 
     /**
      * A reference to the SourceLoader set by the user (a URIResolver
@@ -323,9 +323,9 @@ public final class Stylesheet extends Sy
         _importPrecedence = precedence;
 
         // Set import precedence for all included stylesheets
-        final Enumeration elements = elements();
-        while (elements.hasMoreElements()) {
-            SyntaxTreeNode child = (SyntaxTreeNode)elements.nextElement();
+        final Iterator<SyntaxTreeNode> elements = elements();
+        while (elements.hasNext()) {
+            SyntaxTreeNode child = elements.next();
             if (child instanceof Include) {
                 Stylesheet included = ((Include)child).getIncludedStylesheet();
                 if (included != null && included._includedFrom == this) {
@@ -573,13 +573,13 @@ public final class Stylesheet extends Sy
         stable.excludeNamespaces(excludePrefixes);
         stable.excludeNamespaces(extensionPrefixes);
 
-        final Vector contents = getContents();
+        final List<SyntaxTreeNode> contents = getContents();
         final int count = contents.size();
 
         // We have to scan the stylesheet element's top-level elements for
         // variables and/or parameters before we parse the other elements
         for (int i = 0; i < count; i++) {
-            SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
+            SyntaxTreeNode child = contents.get(i);
             if ((child instanceof VariableBase) ||
                 (child instanceof NamespaceAlias)) {
                 parser.getSymbolTable().setCurrentNode(child);
@@ -589,7 +589,7 @@ public final class Stylesheet extends Sy
 
         // Now go through all the other top-level elements...
         for (int i = 0; i < count; i++) {
-            SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
+            SyntaxTreeNode child = contents.get(i);
             if (!(child instanceof VariableBase) &&
                 !(child instanceof NamespaceAlias)) {
                 parser.getSymbolTable().setCurrentNode(child);
@@ -612,18 +612,14 @@ public final class Stylesheet extends Sy
         if (_defaultMode == null)
             _defaultMode = new Mode(null, this, Constants.EMPTYSTRING);
         _defaultMode.processPatterns(_keys);
-        final Enumeration modes = _modes.elements();
-        while (modes.hasMoreElements()) {
-            final Mode mode = (Mode)modes.nextElement();
+        for (Mode mode : _modes.values()) {
             mode.processPatterns(_keys);
         }
     }
 
     private void compileModes(ClassGenerator classGen) {
         _defaultMode.compileApplyTemplates(classGen);
-        final Enumeration modes = _modes.elements();
-        while (modes.hasMoreElements()) {
-            final Mode mode = (Mode)modes.nextElement();
+        for (Mode mode : _modes.values()) {
             mode.compileApplyTemplates(classGen);
         }
     }
@@ -636,10 +632,10 @@ public final class Stylesheet extends Sy
             return _defaultMode;
         }
         else {
-            Mode mode = (Mode)_modes.get(modeName);
+            Mode mode = _modes.get(modeName.getStringRep());
             if (mode == null) {
                 final String suffix = Integer.toString(_nextModeSerial++);
-                _modes.put(modeName, mode = new Mode(modeName, this, suffix));
+                _modes.put(modeName.getStringRep(), mode = new Mode(modeName, this, suffix));
             }
             return mode;
         }
@@ -707,9 +703,9 @@ public final class Stylesheet extends Sy
         compileTransform(classGen);
 
         // Translate all non-template elements and filter out all templates
-        final Enumeration elements = elements();
-        while (elements.hasMoreElements()) {
-            Object element = elements.nextElement();
+        final Iterator<SyntaxTreeNode> elements = elements();
+        while (elements.hasNext()) {
+            SyntaxTreeNode element = elements.next();
             // xsl:template
             if (element instanceof Template) {
                 // Separate templates by modes
@@ -1054,9 +1050,9 @@ public final class Stylesheet extends Sy
 
         // Create a new list containing variables/params + keys
         Vector varDepElements = new Vector(_globals);
-        Enumeration elements = elements();
-        while (elements.hasMoreElements()) {
-            final Object element = elements.nextElement();
+        Iterator<SyntaxTreeNode> elements = elements();
+        while (elements.hasNext()) {
+            SyntaxTreeNode element = elements.next();
             if (element instanceof Key) {
                 varDepElements.add(element);
             }
@@ -1079,8 +1075,8 @@ public final class Stylesheet extends Sy
         // Compile code for other top-level elements
         Vector whitespaceRules = new Vector();
         elements = elements();
-        while (elements.hasMoreElements()) {
-            final Object element = elements.nextElement();
+        while (elements.hasNext()) {
+            SyntaxTreeNode element = elements.next();
             // xsl:decimal-format
             if (element instanceof DecimalFormatting) {
                 ((DecimalFormatting)element).translate(classGen,toplevel);
@@ -1198,10 +1194,10 @@ public final class Stylesheet extends Sy
 
         buildKeys.addException("com.sun.org.apache.xalan.internal.xsltc.TransletException");
 
-        final Enumeration elements = elements();
-        while (elements.hasMoreElements()) {
+        final Iterator<SyntaxTreeNode> elements = elements();
+        while (elements.hasNext()) {
             // xsl:key
-            final Object element = elements.nextElement();
+            final SyntaxTreeNode element = elements.next();
             if (element instanceof Key) {
                 final Key key = (Key)element;
                 key.translate(classGen, buildKeys);
@@ -1325,8 +1321,8 @@ public final class Stylesheet extends Sy
                                                "buildKeys", keySig);
 
         // Look for top-level elements that need handling
-        final Enumeration toplevel = elements();
-        if (_globals.size() > 0 || toplevel.hasMoreElements()) {
+        final Iterator<SyntaxTreeNode> toplevel = elements();
+        if (_globals.size() > 0 || toplevel.hasNext()) {
             // Compile method for handling top-level elements
             final String topLevelSig = compileTopLevel(classGen);
             // Get a reference to that method
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SymbolTable.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SymbolTable.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SymbolTable.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,13 +23,13 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Hashtable;
+import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodType;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Stack;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
-import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodType;
-
 /**
  * @author Jacek Ambroziak
  * @author Santiago Pericas-Geertsen
@@ -37,67 +37,67 @@ import com.sun.org.apache.xalan.internal
  */
 final class SymbolTable {
 
-    // These hashtables are used for all stylesheets
-    private final Hashtable _stylesheets = new Hashtable();
-    private final Hashtable _primops     = new Hashtable();
-
-    // These hashtables are used for some stylesheets
-    private Hashtable _variables = null;
-    private Hashtable _templates = null;
-    private Hashtable _attributeSets = null;
-    private Hashtable _aliases = null;
-    private Hashtable _excludedURI = null;
-    private Stack     _excludedURIStack = null;
-    private Hashtable _decimalFormats = null;
-    private Hashtable _keys = null;
+    // These maps are used for all stylesheets
+    private final Map<String, Stylesheet> _stylesheets = new HashMap<>();
+    private final Map<String, Vector> _primops     = new HashMap<>();
+
+    // These maps are used for some stylesheets
+    private Map<String, VariableBase> _variables = null;
+    private Map<String, Template> _templates = null;
+    private Map<String, AttributeSet> _attributeSets = null;
+    private Map<String, String> _aliases = null;
+    private Map<String, Integer> _excludedURI = null;
+    private Stack<Map<String, Integer>>     _excludedURIStack = null;
+    private Map<String, DecimalFormatting> _decimalFormats = null;
+    private Map<String, Key> _keys = null;
 
     public DecimalFormatting getDecimalFormatting(QName name) {
         if (_decimalFormats == null) return null;
-        return((DecimalFormatting)_decimalFormats.get(name));
+        return(_decimalFormats.get(name.getStringRep()));
     }
 
     public void addDecimalFormatting(QName name, DecimalFormatting symbols) {
-        if (_decimalFormats == null) _decimalFormats = new Hashtable();
-        _decimalFormats.put(name, symbols);
+        if (_decimalFormats == null) _decimalFormats = new HashMap<>();
+        _decimalFormats.put(name.getStringRep(), symbols);
     }
 
     public Key getKey(QName name) {
         if (_keys == null) return null;
-        return (Key) _keys.get(name);
+        return _keys.get(name.getStringRep());
     }
 
     public void addKey(QName name, Key key) {
-        if (_keys == null) _keys = new Hashtable();
-        _keys.put(name, key);
+        if (_keys == null) _keys = new HashMap<>();
+        _keys.put(name.getStringRep(), key);
     }
 
     public Stylesheet addStylesheet(QName name, Stylesheet node) {
-        return (Stylesheet)_stylesheets.put(name, node);
+        return _stylesheets.put(name.getStringRep(), node);
     }
 
     public Stylesheet lookupStylesheet(QName name) {
-        return (Stylesheet)_stylesheets.get(name);
+        return _stylesheets.get(name.getStringRep());
     }
 
     public Template addTemplate(Template template) {
         final QName name = template.getName();
-        if (_templates == null) _templates = new Hashtable();
-        return (Template)_templates.put(name, template);
+        if (_templates == null) _templates = new HashMap<>();
+        return _templates.put(name.getStringRep(), template);
     }
 
     public Template lookupTemplate(QName name) {
         if (_templates == null) return null;
-        return (Template)_templates.get(name);
+        return _templates.get(name.getStringRep());
     }
 
     public Variable addVariable(Variable variable) {
-        if (_variables == null) _variables = new Hashtable();
+        if (_variables == null) _variables = new HashMap<>();
         final String name = variable.getName().getStringRep();
         return (Variable)_variables.put(name, variable);
     }
 
     public Param addParam(Param parameter) {
-        if (_variables == null) _variables = new Hashtable();
+        if (_variables == null) _variables = new HashMap<>();
         final String name = parameter.getName().getStringRep();
         return (Param)_variables.put(name, parameter);
     }
@@ -105,14 +105,14 @@ final class SymbolTable {
     public Variable lookupVariable(QName qname) {
         if (_variables == null) return null;
         final String name = qname.getStringRep();
-        final Object obj = _variables.get(name);
+        final VariableBase obj = _variables.get(name);
         return obj instanceof Variable ? (Variable)obj : null;
     }
 
     public Param lookupParam(QName qname) {
         if (_variables == null) return null;
         final String name = qname.getStringRep();
-        final Object obj = _variables.get(name);
+        final VariableBase obj = _variables.get(name);
         return obj instanceof Param ? (Param)obj : null;
     }
 
@@ -123,13 +123,13 @@ final class SymbolTable {
     }
 
     public AttributeSet addAttributeSet(AttributeSet atts) {
-        if (_attributeSets == null) _attributeSets = new Hashtable();
-        return (AttributeSet)_attributeSets.put(atts.getName(), atts);
+        if (_attributeSets == null) _attributeSets = new HashMap<>();
+        return _attributeSets.put(atts.getName().getStringRep(), atts);
     }
 
     public AttributeSet lookupAttributeSet(QName name) {
         if (_attributeSets == null) return null;
-        return (AttributeSet)_attributeSets.get(name);
+        return _attributeSets.get(name.getStringRep());
     }
 
     /**
@@ -138,7 +138,7 @@ final class SymbolTable {
      * is prepended.
      */
     public void addPrimop(String name, MethodType mtype) {
-        Vector methods = (Vector)_primops.get(name);
+        Vector methods = _primops.get(name);
         if (methods == null) {
             _primops.put(name, methods = new Vector());
         }
@@ -150,7 +150,7 @@ final class SymbolTable {
      * prepending the prefix <tt>PrimopPrefix</tt>.
      */
     public Vector lookupPrimop(String name) {
-        return (Vector)_primops.get(name);
+        return _primops.get(name);
     }
 
     /**
@@ -181,7 +181,7 @@ final class SymbolTable {
      * Adds an alias for a namespace prefix
      */
     public void addPrefixAlias(String prefix, String alias) {
-        if (_aliases == null) _aliases = new Hashtable();
+        if (_aliases == null) _aliases = new HashMap<>();
         _aliases.put(prefix,alias);
     }
 
@@ -190,7 +190,7 @@ final class SymbolTable {
      */
     public String lookupPrefixAlias(String prefix) {
         if (_aliases == null) return null;
-        return (String)_aliases.get(prefix);
+        return _aliases.get(prefix);
     }
 
     /**
@@ -201,15 +201,15 @@ final class SymbolTable {
         // The null-namespace cannot be excluded
         if (uri == null) return;
 
-        // Create new hashtable of exlcuded URIs if none exists
-        if (_excludedURI == null) _excludedURI = new Hashtable();
+        // Create a new map of exlcuded URIs if none exists
+        if (_excludedURI == null) _excludedURI = new HashMap<>();
 
         // Register the namespace URI
-        Integer refcnt = (Integer)_excludedURI.get(uri);
+        Integer refcnt = _excludedURI.get(uri);
         if (refcnt == null)
-            refcnt = new Integer(1);
+            refcnt = 1;
         else
-            refcnt = new Integer(refcnt.intValue() + 1);
+            refcnt = refcnt + 1;
         _excludedURI.put(uri,refcnt);
     }
 
@@ -237,8 +237,8 @@ final class SymbolTable {
      */
     public boolean isExcludedNamespace(String uri) {
         if (uri != null && _excludedURI != null) {
-            final Integer refcnt = (Integer)_excludedURI.get(uri);
-            return (refcnt != null && refcnt.intValue() > 0);
+            final Integer refcnt = _excludedURI.get(uri);
+            return (refcnt != null && refcnt > 0);
         }
         return false;
     }
@@ -257,9 +257,9 @@ final class SymbolTable {
                     uri = lookupNamespace(Constants.EMPTYSTRING);
                 else
                     uri = lookupNamespace(prefix);
-                Integer refcnt = (Integer)_excludedURI.get(uri);
+                Integer refcnt = _excludedURI.get(uri);
                 if (refcnt != null)
-                    _excludedURI.put(uri, new Integer(refcnt.intValue() - 1));
+                    _excludedURI.put(uri, refcnt - 1);
             }
         }
     }
@@ -286,7 +286,7 @@ final class SymbolTable {
      * the current stylesheet.
      */
     public void popExcludedNamespacesContext() {
-        _excludedURI = (Hashtable) _excludedURIStack.pop();
+        _excludedURI = _excludedURIStack.pop();
         if (_excludedURIStack.isEmpty()) {
             _excludedURIStack = null;
         }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SyntaxTreeNode.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SyntaxTreeNode.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/SyntaxTreeNode.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2006, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,10 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ANEWARRAY;
 import com.sun.org.apache.bcel.internal.generic.BasicType;
 import com.sun.org.apache.bcel.internal.generic.CHECKCAST;
@@ -41,14 +37,18 @@ import com.sun.org.apache.bcel.internal.
 import com.sun.org.apache.bcel.internal.generic.NEW;
 import com.sun.org.apache.bcel.internal.generic.NEWARRAY;
 import com.sun.org.apache.bcel.internal.generic.PUSH;
+import com.sun.org.apache.xalan.internal.xsltc.DOM;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
-import com.sun.org.apache.xalan.internal.xsltc.DOM;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
-
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 import org.xml.sax.Attributes;
 import org.xml.sax.helpers.AttributesImpl;
 
@@ -70,13 +70,13 @@ public abstract class SyntaxTreeNode imp
     protected SyntaxTreeNode _parent;          // Parent node
     private Stylesheet       _stylesheet;      // Stylesheet ancestor node
     private Template         _template;        // Template ancestor node
-    private final Vector _contents = new Vector(2); // Child nodes
+    private final List<SyntaxTreeNode> _contents = new ArrayList<>(2); // Child nodes
 
     // Element description data
     protected QName _qname;                    // The element QName
     private int _line;                         // Source file line number
     protected AttributesImpl _attributes = null;   // Attributes of this element
-    private   Hashtable _prefixMapping = null; // Namespace declarations
+    private   Map<String, String> _prefixMapping = null; // Namespace declarations
 
     // Sentinel - used to denote unrecognised syntaxt tree nodes.
     protected static final SyntaxTreeNode Dummy = new AbsolutePathPattern(null);
@@ -217,22 +217,22 @@ public abstract class SyntaxTreeNode imp
      * Sets the prefix mapping for the namespaces that were declared in this
      * element. This does not include all prefix mappings in scope, so one
      * may have to check ancestor elements to get all mappings that are in
-     * in scope. The prefixes must be passed in as a Hashtable that maps
+     * in scope. The prefixes must be passed in as a Map that maps
      * namespace prefixes (String objects) to namespace URIs (also String).
-     * @param mapping The Hashtable containing the mappings.
+     * @param mapping The Map containing the mappings.
      */
-    protected void setPrefixMapping(Hashtable mapping) {
+    protected void setPrefixMapping(Map<String, String> mapping) {
         _prefixMapping = mapping;
     }
 
     /**
-     * Returns a Hashtable containing the prefix mappings that were declared
+     * Returns a Map containing the prefix mappings that were declared
      * for this element. This does not include all prefix mappings in scope,
      * so one may have to check ancestor elements to get all mappings that are
      * in in scope.
      * @return Prefix mappings (for this element only).
      */
-    protected Hashtable getPrefixMapping() {
+    protected Map<String, String> getPrefixMapping() {
         return _prefixMapping;
     }
 
@@ -243,7 +243,7 @@ public abstract class SyntaxTreeNode imp
      */
     protected void addPrefixMapping(String prefix, String uri) {
         if (_prefixMapping == null)
-            _prefixMapping = new Hashtable();
+            _prefixMapping = new HashMap<>();
         _prefixMapping.put(prefix, uri);
     }
 
@@ -259,9 +259,9 @@ public abstract class SyntaxTreeNode imp
         // Initialise the output (default is 'null' for undefined)
         String uri = null;
 
-        // First look up the prefix/uri mapping in our own hashtable...
+        // First look up the prefix/uri mapping in our own map...
         if (_prefixMapping != null)
-            uri = (String)_prefixMapping.get(prefix);
+            uri = _prefixMapping.get(prefix);
         // ... but if we can't find it there we ask our parent for the mapping
         if ((uri == null) && (_parent != null)) {
             uri = _parent.lookupNamespace(prefix);
@@ -286,13 +286,12 @@ public abstract class SyntaxTreeNode imp
         // Initialise the output (default is 'null' for undefined)
         String prefix = null;
 
-        // First look up the prefix/uri mapping in our own hashtable...
+        // First look up the prefix/uri mapping in our own map...
         if ((_prefixMapping != null) &&
-            (_prefixMapping.contains(uri))) {
-            Enumeration prefixes = _prefixMapping.keys();
-            while (prefixes.hasMoreElements()) {
-                prefix = (String)prefixes.nextElement();
-                String mapsTo = (String)_prefixMapping.get(prefix);
+            (_prefixMapping.containsValue(uri))) {
+            for (Map.Entry<String, String> entry : _prefixMapping.entrySet()) {
+                prefix = entry.getKey();
+                String mapsTo = entry.getValue();
                 if (mapsTo.equals(uri)) return(prefix);
             }
         }
@@ -427,20 +426,18 @@ public abstract class SyntaxTreeNode imp
      */
     protected final void parseChildren(Parser parser) {
 
-        Vector locals = null;   // only create when needed
+        List<QName> locals = null;   // only create when needed
 
-        final int count = _contents.size();
-        for (int i=0; i<count; i++) {
-            SyntaxTreeNode child = (SyntaxTreeNode)_contents.elementAt(i);
+        for (SyntaxTreeNode child : _contents) {
             parser.getSymbolTable().setCurrentNode(child);
             child.parseContents(parser);
             // if variable or parameter, add it to scope
             final QName varOrParamName = updateScope(parser, child);
             if (varOrParamName != null) {
                 if (locals == null) {
-                    locals = new Vector(2);
+                    locals = new ArrayList<>(2);
                 }
-                locals.addElement(varOrParamName);
+                locals.add(varOrParamName);
             }
         }
 
@@ -448,9 +445,8 @@ public abstract class SyntaxTreeNode imp
 
         // after the last element, remove any locals from scope
         if (locals != null) {
-            final int nLocals = locals.size();
-            for (int i = 0; i < nLocals; i++) {
-                parser.removeVariable((QName)locals.elementAt(i));
+            for (QName varOrParamName : locals) {
+                parser.removeVariable(varOrParamName);
             }
         }
     }
@@ -487,9 +483,7 @@ public abstract class SyntaxTreeNode imp
      * @param stable The compiler/parser's symbol table
      */
     protected Type typeCheckContents(SymbolTable stable) throws TypeCheckError {
-        final int n = elementCount();
-        for (int i = 0; i < n; i++) {
-            SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
+        for (SyntaxTreeNode item : _contents) {
             item.typeCheck(stable);
         }
         return Type.Void;
@@ -513,9 +507,8 @@ public abstract class SyntaxTreeNode imp
         // Call translate() on all child nodes
         final int n = elementCount();
 
-        for (int i = 0; i < n; i++) {
+        for (SyntaxTreeNode item : _contents) {
             methodGen.markChunkStart();
-            final SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
             item.translate(classGen, methodGen);
             methodGen.markChunkEnd();
         }
@@ -526,8 +519,8 @@ public abstract class SyntaxTreeNode imp
         // references falling out-of-scope inside the for-each element.
         // (the cause of which being 'lazy' register allocation for references)
         for (int i = 0; i < n; i++) {
-            if( _contents.elementAt(i) instanceof VariableBase) {
-                final VariableBase var = (VariableBase)_contents.elementAt(i);
+            if( _contents.get(i) instanceof VariableBase) {
+                final VariableBase var = (VariableBase)_contents.get(i);
                 var.unmapRegister(methodGen);
             }
         }
@@ -543,9 +536,8 @@ public abstract class SyntaxTreeNode imp
      */
     private boolean isSimpleRTF(SyntaxTreeNode node) {
 
-        Vector contents = node.getContents();
-        for (int i = 0; i < contents.size(); i++) {
-            SyntaxTreeNode item = (SyntaxTreeNode)contents.elementAt(i);
+        List<SyntaxTreeNode> contents = node.getContents();
+        for (SyntaxTreeNode item : contents) {
             if (!isTextElement(item, false))
                 return false;
         }
@@ -564,9 +556,8 @@ public abstract class SyntaxTreeNode imp
      */
     private boolean isAdaptiveRTF(SyntaxTreeNode node) {
 
-        Vector contents = node.getContents();
-        for (int i = 0; i < contents.size(); i++) {
-            SyntaxTreeNode item = (SyntaxTreeNode)contents.elementAt(i);
+        List<SyntaxTreeNode> contents = node.getContents();
+        for (SyntaxTreeNode item : contents) {
             if (!isTextElement(item, true))
                 return false;
         }
@@ -600,9 +591,8 @@ public abstract class SyntaxTreeNode imp
             return doExtendedCheck ? isAdaptiveRTF(node) : isSimpleRTF(node);
         }
         else if (node instanceof Choose) {
-            Vector contents = node.getContents();
-            for (int i = 0; i < contents.size(); i++) {
-                SyntaxTreeNode item = (SyntaxTreeNode)contents.elementAt(i);
+            List<SyntaxTreeNode> contents = node.getContents();
+            for (SyntaxTreeNode item : contents) {
                 if (item instanceof Text ||
                      ((item instanceof When || item instanceof Otherwise)
                      && ((doExtendedCheck && isAdaptiveRTF(item))
@@ -769,9 +759,7 @@ public abstract class SyntaxTreeNode imp
      * @return 'true' if the contents of this node is context dependent.
      */
     protected boolean dependentContents() {
-        final int n = elementCount();
-        for (int i = 0; i < n; i++) {
-            final SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
+        for (SyntaxTreeNode item : _contents) {
             if (item.contextDependent()) {
                 return true;
             }
@@ -784,7 +772,7 @@ public abstract class SyntaxTreeNode imp
      * @param element is the new child node.
      */
     protected final void addElement(SyntaxTreeNode element) {
-        _contents.addElement(element);
+        _contents.add(element);
         element.setParent(this);
     }
 
@@ -794,7 +782,7 @@ public abstract class SyntaxTreeNode imp
      * @param element is the new child node.
      */
     protected final void setFirstElement(SyntaxTreeNode element) {
-        _contents.insertElementAt(element,0);
+        _contents.add(0, element);
         element.setParent(this);
     }
 
@@ -808,10 +796,10 @@ public abstract class SyntaxTreeNode imp
     }
 
     /**
-     * Returns a Vector containing all the child nodes of this node.
-     * @return A Vector containing all the child nodes of this node.
+     * Returns a List containing all the child nodes of this node.
+     * @return A List containing all the child nodes of this node.
      */
-    protected final Vector getContents() {
+    protected final List<SyntaxTreeNode> getContents() {
         return _contents;
     }
 
@@ -832,11 +820,11 @@ public abstract class SyntaxTreeNode imp
     }
 
     /**
-     * Returns an Enumeration of all child nodes of this node.
-     * @return An Enumeration of all child nodes of this node.
+     * Returns an Iterator of all child nodes of this node.
+     * @return An Iterator of all child nodes of this node.
      */
-    protected final Enumeration elements() {
-        return _contents.elements();
+    protected final Iterator<SyntaxTreeNode> elements() {
+        return _contents.iterator();
     }
 
     /**
@@ -845,7 +833,7 @@ public abstract class SyntaxTreeNode imp
      * @return The child node.
      */
     protected final Object elementAt(int pos) {
-        return _contents.elementAt(pos);
+        return _contents.get(pos);
     }
 
     /**
@@ -853,8 +841,8 @@ public abstract class SyntaxTreeNode imp
      * @return The child node.
      */
     protected final SyntaxTreeNode lastChild() {
-        if (_contents.size() == 0) return null;
-        return (SyntaxTreeNode)_contents.lastElement();
+        if (_contents.isEmpty()) return null;
+        return _contents.get(_contents.size() - 1);
     }
 
     /**
@@ -873,9 +861,7 @@ public abstract class SyntaxTreeNode imp
      * @param indent Indentation level for syntax tree levels.
      */
     protected void displayContents(int indent) {
-        final int n = elementCount();
-        for (int i = 0; i < n; i++) {
-            SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
+        for (SyntaxTreeNode item : _contents) {
             item.display(indent);
         }
     }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Template.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Template.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/Template.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,11 +23,8 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.INVOKEVIRTUAL;
-import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
@@ -37,6 +34,8 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
 import com.sun.org.apache.xml.internal.utils.XML11Char;
+import java.util.List;
+import java.util.Vector;
 
 
 /**
@@ -274,8 +273,8 @@ public final class Template extends TopL
         _priority = Double.NaN;
         _pattern = parser.parsePattern(this, "/");
 
-        final Vector contents = _stylesheet.getContents();
-        final SyntaxTreeNode root = (SyntaxTreeNode)contents.elementAt(0);
+        final List<SyntaxTreeNode> contents = _stylesheet.getContents();
+        final SyntaxTreeNode root = contents.get(0);
 
         if (root instanceof LiteralElement) {
             addElement(root);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/TestSeq.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/TestSeq.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/TestSeq.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,14 +23,13 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Dictionary;
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.GOTO_W;
 import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
+import java.util.Map;
+import java.util.Vector;
 
 /**
  * A test sequence is a sequence of patterns that
@@ -179,7 +178,7 @@ final class TestSeq {
      * this test sequence. Note that a single template can occur
      * in several test sequences if its pattern is a union.
      */
-    public void findTemplates(Dictionary templates) {
+    public void findTemplates(Map<Template, Object> templates) {
         if (_default != null) {
             templates.put(_default, this);
         }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/UnsupportedElement.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/UnsupportedElement.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/UnsupportedElement.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,19 +23,18 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 import com.sun.org.apache.bcel.internal.generic.INVOKESTATIC;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.bcel.internal.generic.PUSH;
-
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
+import java.util.List;
+import java.util.Vector;
 
 /**
  * @author Morten Jorgensen
@@ -83,11 +82,11 @@ final class UnsupportedElement extends S
      */
     private void processFallbacks(Parser parser) {
 
-        Vector children = getContents();
+        List<SyntaxTreeNode> children = getContents();
         if (children != null) {
             final int count = children.size();
             for (int i = 0; i < count; i++) {
-                SyntaxTreeNode child = (SyntaxTreeNode)children.elementAt(i);
+                SyntaxTreeNode child = children.get(i);
                 if (child instanceof Fallback) {
                     Fallback fallback = (Fallback)child;
                     fallback.activate();
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -39,13 +39,10 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.Hashtable;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Vector;
@@ -90,14 +87,14 @@ public final class XSLTC {
     // Name index tables
     private int       _nextGType;  // Next available element type
     private Vector    _namesIndex; // Index of all registered QNames
-    private Hashtable _elements;   // Hashtable of all registered elements
-    private Hashtable _attributes; // Hashtable of all registered attributes
+    private Map<String, Integer> _elements;   // Map of all registered elements
+    private Map<String, Integer> _attributes; // Map of all registered attributes
 
     // Namespace index tables
     private int       _nextNSType; // Next available namespace type
     private Vector    _namespaceIndex; // Index of all registered namespaces
-    private Hashtable _namespaces; // Hashtable of all registered namespaces
-    private Hashtable _namespacePrefixes;// Hashtable of all registered namespace prefixes
+    private Map<String, Integer> _namespaces; // Map of all registered namespaces
+    private Map<String, Integer> _namespacePrefixes;// Map of all registered namespace prefixes
 
 
     // All literal text in the stylesheet
@@ -319,13 +316,13 @@ public final class XSLTC {
      */
     private void reset() {
         _nextGType      = DTM.NTYPES;
-        _elements       = new Hashtable();
-        _attributes     = new Hashtable();
-        _namespaces     = new Hashtable();
+        _elements       = new HashMap<>();
+        _attributes     = new HashMap<>();
+        _namespaces     = new HashMap<>();
         _namespaces.put("",new Integer(_nextNSType));
         _namesIndex     = new Vector(128);
         _namespaceIndex = new Vector(32);
-        _namespacePrefixes = new Hashtable();
+        _namespacePrefixes = new HashMap<>();
         _stylesheet     = null;
         _parser.init();
         //_variableSerial     = 1;
@@ -765,9 +762,9 @@ public final class XSLTC {
      * DOM attribute types at run-time.
      */
     public int registerAttribute(QName name) {
-        Integer code = (Integer)_attributes.get(name.toString());
+        Integer code = _attributes.get(name.toString());
         if (code == null) {
-            code = new Integer(_nextGType++);
+            code = _nextGType++;
             _attributes.put(name.toString(), code);
             final String uri = name.getNamespace();
             final String local = "@"+name.getLocalPart();
@@ -788,9 +785,9 @@ public final class XSLTC {
      */
     public int registerElement(QName name) {
         // Register element (full QName)
-        Integer code = (Integer)_elements.get(name.toString());
+        Integer code = _elements.get(name.toString());
         if (code == null) {
-            _elements.put(name.toString(), code = new Integer(_nextGType++));
+            _elements.put(name.toString(), code = _nextGType++);
             _namesIndex.addElement(name.toString());
         }
         if (name.getLocalPart().equals("*")) {
@@ -806,9 +803,9 @@ public final class XSLTC {
 
     public int registerNamespacePrefix(QName name) {
 
-    Integer code = (Integer)_namespacePrefixes.get(name.toString());
+    Integer code = _namespacePrefixes.get(name.toString());
     if (code == null) {
-        code = new Integer(_nextGType++);
+        code = _nextGType++;
         _namespacePrefixes.put(name.toString(), code);
         final String uri = name.getNamespace();
         if ((uri != null) && (!uri.equals(""))){
@@ -826,9 +823,9 @@ public final class XSLTC {
      * DOM namespace types at run-time.
      */
     public int registerNamespace(String namespaceURI) {
-        Integer code = (Integer)_namespaces.get(namespaceURI);
+        Integer code = _namespaces.get(namespaceURI);
         if (code == null) {
-            code = new Integer(_nextNSType++);
+            code = _nextNSType++;
             _namespaces.put(namespaceURI,code);
             _namespaceIndex.addElement(namespaceURI);
         }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XslAttribute.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XslAttribute.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XslAttribute.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,8 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler;
 
-import java.util.Vector;
-
 import com.sun.org.apache.bcel.internal.generic.ALOAD;
 import com.sun.org.apache.bcel.internal.generic.ASTORE;
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
@@ -40,10 +38,10 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Util;
-
 import com.sun.org.apache.xml.internal.serializer.ElemDesc;
 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
 import com.sun.org.apache.xml.internal.utils.XML11Char;
+import java.util.List;
 
 /**
  * @author Jacek Ambroziak
@@ -103,9 +101,9 @@ final class XslAttribute extends Instruc
 
         // Ignore attribute if preceeded by some other type of element
         final SyntaxTreeNode parent = getParent();
-        final Vector siblings = parent.getContents();
+        final List<SyntaxTreeNode> siblings = parent.getContents();
         for (int i = 0; i < parent.elementCount(); i++) {
-            SyntaxTreeNode item = (SyntaxTreeNode)siblings.elementAt(i);
+            SyntaxTreeNode item = siblings.get(i);
             if (item == this) break;
 
             // These three objects result in one or more attribute output
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XslElement.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XslElement.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XslElement.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -26,7 +26,6 @@ package com.sun.org.apache.xalan.interna
 import com.sun.org.apache.bcel.internal.generic.ALOAD;
 import com.sun.org.apache.bcel.internal.generic.ASTORE;
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
-import com.sun.org.apache.bcel.internal.generic.ICONST;
 import com.sun.org.apache.bcel.internal.generic.INVOKESTATIC;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
@@ -285,8 +284,7 @@ final class XslElement extends Instructi
                                   MethodGenerator methodGen) {
         final int n = elementCount();
         for (int i = 0; i < n; i++) {
-            final SyntaxTreeNode item =
-                (SyntaxTreeNode)getContents().elementAt(i);
+            final SyntaxTreeNode item = getContents().get(i);
             if (_ignore && item instanceof XslAttribute) continue;
             item.translate(classGen, methodGen);
         }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -23,15 +23,6 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler.util;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
- import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Stack;
-
-
 import com.sun.org.apache.bcel.internal.Constants;
 import com.sun.org.apache.bcel.internal.classfile.Field;
 import com.sun.org.apache.bcel.internal.classfile.Method;
@@ -47,23 +38,23 @@ import com.sun.org.apache.bcel.internal.
 import com.sun.org.apache.bcel.internal.generic.GETFIELD;
 import com.sun.org.apache.bcel.internal.generic.GOTO;
 import com.sun.org.apache.bcel.internal.generic.ICONST;
-import com.sun.org.apache.bcel.internal.generic.IfInstruction;
 import com.sun.org.apache.bcel.internal.generic.ILOAD;
-import com.sun.org.apache.bcel.internal.generic.IndexedInstruction;
 import com.sun.org.apache.bcel.internal.generic.INVOKEINTERFACE;
 import com.sun.org.apache.bcel.internal.generic.INVOKESPECIAL;
 import com.sun.org.apache.bcel.internal.generic.INVOKESTATIC;
 import com.sun.org.apache.bcel.internal.generic.INVOKEVIRTUAL;
 import com.sun.org.apache.bcel.internal.generic.ISTORE;
+import com.sun.org.apache.bcel.internal.generic.IfInstruction;
+import com.sun.org.apache.bcel.internal.generic.IndexedInstruction;
 import com.sun.org.apache.bcel.internal.generic.Instruction;
 import com.sun.org.apache.bcel.internal.generic.InstructionConstants;
 import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.bcel.internal.generic.InstructionTargeter;
-import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
-import com.sun.org.apache.bcel.internal.generic.LocalVariableInstruction;
 import com.sun.org.apache.bcel.internal.generic.LLOAD;
 import com.sun.org.apache.bcel.internal.generic.LSTORE;
+import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
+import com.sun.org.apache.bcel.internal.generic.LocalVariableInstruction;
 import com.sun.org.apache.bcel.internal.generic.MethodGen;
 import com.sun.org.apache.bcel.internal.generic.NEW;
 import com.sun.org.apache.bcel.internal.generic.PUTFIELD;
@@ -71,9 +62,14 @@ import com.sun.org.apache.bcel.internal.
 import com.sun.org.apache.bcel.internal.generic.Select;
 import com.sun.org.apache.bcel.internal.generic.TargetLostException;
 import com.sun.org.apache.bcel.internal.generic.Type;
-
 import com.sun.org.apache.xalan.internal.xsltc.compiler.Pattern;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Stack;
 
 /**
  * @author Jacek Ambroziak
@@ -131,7 +127,7 @@ public class MethodGenerator extends Met
                  * times. Note that patterns whose kernels are "*", "node()"
                  * and "@*" can between shared by test sequences.
                  */
-        private Hashtable _preCompiled = new Hashtable();
+        private Map<Pattern, InstructionList> _preCompiled = new HashMap<>();
 
 
     public MethodGenerator(int access_flags, Type return_type,
@@ -715,7 +711,7 @@ public class MethodGenerator extends Met
      * test sequences to avoid compiling patterns more than once.
      */
     public InstructionList getInstructionList(Pattern pattern) {
-        return (InstructionList) _preCompiled.get(pattern);
+        return _preCompiled.get(pattern);
     }
 
     /**
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MultiHashtable.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MultiHashtable.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MultiHashtable.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -23,35 +23,72 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.compiler.util;
 
-import java.util.Hashtable;
-import java.util.Vector;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
 
 /**
  * @author Jacek Ambroziak
  * @author Santiago Pericas-Geertsen
+ * @param <K>
+ * @param <V>
  */
-public final class MultiHashtable extends Hashtable {
+public final class MultiHashtable<K,V> {
     static final long serialVersionUID = -6151608290510033572L;
-    public Object put(Object key, Object value) {
-        Vector vector = (Vector)get(key);
-        if (vector == null)
-            super.put(key, vector = new Vector());
-        vector.add(value);
-        return vector;
+
+    private final Map<K, Set<V>> map = new HashMap<>();
+    private boolean modifiable = true;
+
+    /**
+     * Associates the specified key with a set of values. If the map previously
+     * contained a mapping for the key, the value is added to the set.
+     * @param key key with which the specified value is to be associated
+     * @param value value to be added to a set that is associated with the specified key
+     * @return the set that is associated with the specified key.
+     * @throw UnsupportedOperationException is the MultiHashtable is not modifiable.
+     */
+    public Set<V> put(K key, V value) {
+        if (modifiable) {
+            Set<V> set = map.get(key);
+            if (set == null) {
+                set = new HashSet<>();
+                map.put(key, set);
+            }
+            set.add(value);
+            return set;
+        }
+        throw new UnsupportedOperationException("The MultiHashtable instance is not modifiable.");
     }
 
-    public Object maps(Object from, Object to) {
-        if (from == null) return null;
-        final Vector vector = (Vector) get(from);
-        if (vector != null) {
-            final int n = vector.size();
-            for (int i = 0; i < n; i++) {
-                final Object item = vector.elementAt(i);
-                if (item.equals(to)) {
-                    return item;
+    /**
+     * Maps a key to a value in a set that is associated with the specified key.
+     * The mapping is performed by evaluating whether an item in the set equals
+     * the specified value.
+     *
+     * @param key key with which the specified value is to be associated
+     * @param value value in a set that is associated with the specified key
+     * @return the item in the set if a match is found.
+     */
+    public V maps(K key, V value) {
+        if (key == null) return null;
+        final Set<V> set = map.get(key);
+        if (set != null) {
+            for (V v : set) {
+                if (v.equals(value)) {
+                    return v;
                 }
             }
         }
         return null;
     }
+
+    /**
+     * Makes the MultiHashtable unmodifiable.  This method allows modules to set the table
+     * as "read-only" so that only query operation, that is maps, is allowed. Any attempts
+     * to modify the returned map result in an UnsupportedOperationException.
+     */
+    public void makeUnmodifiable() {
+        modifiable = false;
+    }
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/AdaptiveResultTreeImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/AdaptiveResultTreeImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/AdaptiveResultTreeImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,18 +23,15 @@
 package com.sun.org.apache.xalan.internal.xsltc.dom;
 
 import com.sun.org.apache.xalan.internal.xsltc.DOM;
-import com.sun.org.apache.xalan.internal.xsltc.TransletException;
 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
+import com.sun.org.apache.xalan.internal.xsltc.TransletException;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
-
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisTraverser;
 import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
-import com.sun.org.apache.xml.internal.utils.XMLString;
-
 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
-
+import com.sun.org.apache.xml.internal.utils.XMLString;
+import java.util.Map;
 import javax.xml.transform.SourceLocator;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
@@ -556,7 +553,7 @@ public class AdaptiveResultTreeImpl exte
         }
     }
 
-    public Hashtable getElementsWithIDs()
+    public Map<String, Integer> getElementsWithIDs()
     {
         if (_dom != null) {
             return _dom.getElementsWithIDs();
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMAdapter.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMAdapter.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMAdapter.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -27,11 +27,10 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
 import com.sun.org.apache.xalan.internal.xsltc.TransletException;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
 import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
-
+import java.util.Map;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
@@ -462,7 +461,7 @@ public final class DOMAdapter implements
         return _dom.getUnparsedEntityURI(entity);
     }
 
-    public Hashtable getElementsWithIDs() {
+    public Map<String, Integer> getElementsWithIDs() {
         return _dom.getElementsWithIDs();
     }
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMWSFilter.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMWSFilter.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DOMWSFilter.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2002-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -26,9 +26,10 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
 import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * A wrapper class that adapts the
@@ -40,8 +41,8 @@ public class DOMWSFilter implements DTMW
     private AbstractTranslet m_translet;
     private StripFilter m_filter;
 
-    // The Hashtable for DTM to mapping array
-    private Hashtable m_mappings;
+    // The Map for DTM to mapping array
+    private Map<DTM, short[]> m_mappings;
 
     // Cache the DTM and mapping that are used last time
     private DTM m_currentDTM;
@@ -59,7 +60,7 @@ public class DOMWSFilter implements DTMW
      */
     public DOMWSFilter(AbstractTranslet translet) {
         m_translet = translet;
-        m_mappings = new Hashtable();
+        m_mappings = new HashMap<>();
 
         if (translet instanceof StripFilter) {
             m_filter = (StripFilter) translet;
@@ -91,7 +92,7 @@ public class DOMWSFilter implements DTMW
                     mapping = m_currentMapping;
                 }
                 else {
-                    mapping = (short[])m_mappings.get(dtm);
+                    mapping = m_mappings.get(dtm);
                     if (mapping == null) {
                         mapping = mappableDOM.getMapping(
                                      m_translet.getNamesArray(),
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DocumentCache.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DocumentCache.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/DocumentCache.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,29 +23,27 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.dom;
 
+import com.sun.org.apache.xalan.internal.xsltc.DOM;
+import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
+import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
+import com.sun.org.apache.xalan.internal.xsltc.Translet;
+import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
+import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
+import com.sun.org.apache.xalan.internal.xsltc.runtime.Constants;
+import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
 import java.io.File;
 import java.io.PrintWriter;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.URLDecoder;
 import java.util.Date;
-import java.util.Hashtable;
-
+import java.util.HashMap;
+import java.util.Map;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 import javax.xml.transform.TransformerException;
 import javax.xml.transform.sax.SAXSource;
-
-import com.sun.org.apache.xalan.internal.xsltc.DOM;
-import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
-import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
-import com.sun.org.apache.xalan.internal.xsltc.Translet;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Constants;
-import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
-
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
@@ -56,7 +54,7 @@ import org.xml.sax.XMLReader;
 public final class DocumentCache implements DOMCache {
 
     private int       _size;
-    private Hashtable _references;
+    private Map<String, CachedDocument> _references;
     private String[]  _URIs;
     private int       _count;
     private int       _current;
@@ -171,7 +169,7 @@ public final class DocumentCache impleme
         _count = 0;
         _current = 0;
         _size  = size;
-        _references = new Hashtable(_size+2);
+        _references = new HashMap<>(_size+2);
         _URIs = new String[_size];
 
         try {
@@ -218,7 +216,7 @@ public final class DocumentCache impleme
      *
      */
     private CachedDocument lookupDocument(String uri) {
-        return((CachedDocument)_references.get(uri));
+        return(_references.get(uri));
     }
 
     /**
@@ -231,7 +229,7 @@ public final class DocumentCache impleme
             _current = 0;
         }
         else {
-            // Remove oldest URI from reference Hashtable
+            // Remove oldest URI from reference map
             _references.remove(_URIs[_current]);
             // Insert our URI in circular buffer
             _URIs[_current] = uri;
@@ -244,7 +242,6 @@ public final class DocumentCache impleme
      *
      */
     private synchronized void replaceDocument(String uri, CachedDocument doc) {
-        CachedDocument old = (CachedDocument)_references.get(uri);
         if (doc == null)
             insertDocument(uri, doc);
         else
@@ -324,7 +321,7 @@ public final class DocumentCache impleme
                     "<td><center><b>Last modified</b></center></td></tr>");
 
         for (int i=0; i<_count; i++) {
-            CachedDocument doc = (CachedDocument)_references.get(_URIs[i]);
+            CachedDocument doc = _references.get(_URIs[i]);
             out.print("<tr><td><a href=\""+_URIs[i]+"\">"+
                       "<font size=-1>"+_URIs[i]+"</font></a></td>");
             out.print("<td><center>"+doc.getLatency()+"ms</center></td>");
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/KeyIndex.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/KeyIndex.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/KeyIndex.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2006 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,18 +23,17 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.dom;
 
-import java.util.StringTokenizer;
-
 import com.sun.org.apache.xalan.internal.xsltc.DOM;
 import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
 import com.sun.org.apache.xalan.internal.xsltc.util.IntegerArray;
-
 import com.sun.org.apache.xml.internal.dtm.Axis;
 import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMAxisIteratorBase;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.StringTokenizer;
 
 /**
  * Stores mappings of key values or IDs to DTM nodes.
@@ -49,7 +48,7 @@ public class KeyIndex extends DTMAxisIte
      * A mapping between values and nodesets for the current document.  Used
      * only while building keys.
      */
-    private Hashtable _index;
+    private Map<String, IntegerArray> _index;
 
     /**
      * The document node currently being processed.  Used only while building
@@ -60,7 +59,7 @@ public class KeyIndex extends DTMAxisIte
     /**
      * A mapping from a document node to the mapping between values and nodesets
      */
-    private Hashtable _rootToIndexMap = new Hashtable();
+    private Map<Integer, Map> _rootToIndexMap = new HashMap<>();
 
     /**
      * The node set associated to the current value passed
@@ -91,14 +90,14 @@ public class KeyIndex extends DTMAxisIte
      * Adds a node to the node list for a given value. Nodes will
      * always be added in document order.
      */
-    public void add(Object value, int node, int rootNode) {
+    public void add(String value, int node, int rootNode) {
         if (_currentDocumentNode != rootNode) {
             _currentDocumentNode = rootNode;
-            _index = new Hashtable();
-            _rootToIndexMap.put(new Integer(rootNode), _index);
+            _index = new HashMap<>();
+            _rootToIndexMap.put(rootNode, _index);
         }
 
-        IntegerArray nodes = (IntegerArray) _index.get(value);
+        IntegerArray nodes = _index.get(value);
 
         if (nodes == null) {
              nodes = new IntegerArray();
@@ -145,7 +144,7 @@ public class KeyIndex extends DTMAxisIte
                                                            " \n\t");
         while (values.hasMoreElements()) {
             final String token = (String) values.nextElement();
-            IntegerArray nodes = (IntegerArray) _index.get(token);
+            IntegerArray nodes = _index.get(token);
 
             if (nodes == null && _enhancedDOM != null
                 && _enhancedDOM.hasDOMSource()) {
@@ -178,13 +177,13 @@ public class KeyIndex extends DTMAxisIte
 
             if (ident != DTM.NULL) {
                 Integer root = new Integer(_enhancedDOM.getDocument());
-                Hashtable index = (Hashtable) _rootToIndexMap.get(root);
+                Map<String, IntegerArray> index = _rootToIndexMap.get(root);
 
                 if (index == null) {
-                    index = new Hashtable();
+                    index = new HashMap<>();
                     _rootToIndexMap.put(root, index);
                 } else {
-                    nodes = (IntegerArray) index.get(id);
+                    nodes = index.get(id);
                 }
 
                 if (nodes == null) {
@@ -207,7 +206,7 @@ public class KeyIndex extends DTMAxisIte
      * @deprecated
      */
     public void lookupKey(Object value) {
-        IntegerArray nodes = (IntegerArray) _index.get(value);
+        IntegerArray nodes = _index.get(value);
         _nodes = (nodes != null) ? (IntegerArray) nodes.clone() : null;
         _position = 0;
     }
@@ -243,8 +242,8 @@ public class KeyIndex extends DTMAxisIte
                                  .setStartNode(node).next();
 
         // Get the mapping table for the document containing the context node
-        Hashtable index =
-            (Hashtable) _rootToIndexMap.get(new Integer(rootHandle));
+        Map<String, IntegerArray> index =
+            _rootToIndexMap.get(rootHandle);
 
         // Split argument to id function into XML whitespace separated tokens
         final StringTokenizer values = new StringTokenizer(string, " \n\t");
@@ -254,7 +253,7 @@ public class KeyIndex extends DTMAxisIte
             IntegerArray nodes = null;
 
             if (index != null) {
-                nodes = (IntegerArray) index.get(token);
+                nodes = index.get(token);
             }
 
             // If input was from W3C DOM, use DOM's getElementById to do
@@ -294,13 +293,13 @@ public class KeyIndex extends DTMAxisIte
                                  .setStartNode(node).next();
 
         // Get the mapping table for the document containing the context node
-        Hashtable index =
-                    (Hashtable) _rootToIndexMap.get(new Integer(rootHandle));
+        Map<String,IntegerArray> index =
+                    _rootToIndexMap.get(new Integer(rootHandle));
 
         // Check whether the context node is present in the set of nodes
         // returned by the key function
         if (index != null) {
-            final IntegerArray nodes = (IntegerArray) index.get(value);
+            final IntegerArray nodes = index.get(value);
             return (nodes != null && nodes.indexOf(node) >= 0) ? 1 : 0;
         }
 
@@ -689,7 +688,7 @@ public class KeyIndex extends DTMAxisIte
             IntegerArray result = null;
 
             // Get mapping from key values/IDs to DTM nodes for this document
-            Hashtable index = (Hashtable)_rootToIndexMap.get(new Integer(root));
+            Map<String, IntegerArray> index = _rootToIndexMap.get(root);
 
             if (!_isKeyIterator) {
                 // For id function, tokenize argument as whitespace separated
@@ -703,7 +702,7 @@ public class KeyIndex extends DTMAxisIte
 
                     // Does the ID map to any node in the document?
                     if (index != null) {
-                        nodes = (IntegerArray) index.get(token);
+                        nodes = index.get(token);
                     }
 
                     // If input was from W3C DOM, use DOM's getElementById to do
@@ -725,7 +724,7 @@ public class KeyIndex extends DTMAxisIte
                 }
             } else if (index != null) {
                 // For key function, map key value to nodes
-                result = (IntegerArray) index.get(keyValue);
+                result = index.get(keyValue);
             }
 
             return result;
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/MultiDOM.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/MultiDOM.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/MultiDOM.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -25,18 +25,18 @@ package com.sun.org.apache.xalan.interna
 
 import com.sun.org.apache.xalan.internal.xsltc.DOM;
 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
-import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
 import com.sun.org.apache.xalan.internal.xsltc.TransletException;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
-import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.Axis;
+import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.dtm.DTMManager;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMAxisIteratorBase;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMDefaultBase;
+import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
 import com.sun.org.apache.xml.internal.utils.SuballocatedIntVector;
-
+import java.util.HashMap;
+import java.util.Map;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
@@ -56,7 +56,7 @@ public final class MultiDOM implements D
     private int _free;
     private int _size;
 
-    private Hashtable _documents = new Hashtable();
+    private Map<String, Integer> _documents = new HashMap<>();
 
     private final class AxisIterator extends DTMAxisIteratorBase {
         // constitutive data
@@ -326,10 +326,10 @@ public final class MultiDOM implements D
             domNo = domPos;
         }
 
-        // Store reference to document (URI) in hashtable
+        // Store reference to document (URI) in the Map
         if (indexByURI) {
             String uri = adapter.getDocumentURI(0);
-            _documents.put(uri, new Integer(domNo));
+            _documents.put(uri, domNo);
         }
 
         // If the dom is an AdaptiveResultTreeImpl, we need to create a
@@ -352,7 +352,7 @@ public final class MultiDOM implements D
     }
 
     public int getDocumentMask(String uri) {
-        Integer domIdx = (Integer)_documents.get(uri);
+        Integer domIdx = _documents.get(uri);
         if (domIdx == null) {
             return(-1);
         } else {
@@ -361,7 +361,7 @@ public final class MultiDOM implements D
     }
 
     public DOM getDOMAdapter(String uri) {
-        Integer domIdx = (Integer)_documents.get(uri);
+        Integer domIdx = _documents.get(uri);
         if (domIdx == null) {
             return(null);
         } else {
@@ -665,7 +665,7 @@ public final class MultiDOM implements D
     }
 
     // %HZ% Does this method make any sense here???
-    public Hashtable getElementsWithIDs() {
+    public Map<String, Integer> getElementsWithIDs() {
         return _main.getElementsWithIDs();
     }
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SAXImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SAXImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SAXImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,40 +23,35 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.dom;
 
-import java.net.URL;
-import java.net.MalformedURLException;
-import java.util.Enumeration;
-
-import javax.xml.transform.Source;
-import javax.xml.transform.dom.DOMSource;
-
 import com.sun.org.apache.xalan.internal.xsltc.DOM;
 import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
 import com.sun.org.apache.xalan.internal.xsltc.TransletException;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
-import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.Axis;
+import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.dtm.DTMManager;
 import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMAxisIterNodeList;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMDefaultBase;
-import com.sun.org.apache.xml.internal.dtm.ref.EmptyIterator;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMNodeProxy;
+import com.sun.org.apache.xml.internal.dtm.ref.EmptyIterator;
 import com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM2;
 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
 import com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler;
-import com.sun.org.apache.xml.internal.utils.XMLStringFactory;
 import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
+import com.sun.org.apache.xml.internal.utils.XMLStringFactory;
+import java.util.HashMap;
+import java.util.Map;
+import javax.xml.transform.Source;
+import javax.xml.transform.dom.DOMSource;
 import org.w3c.dom.Document;
 import org.w3c.dom.DocumentType;
-import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Entity;
-
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
 import org.xml.sax.Attributes;
 import org.xml.sax.SAXException;
 
@@ -119,7 +114,7 @@ public final class SAXImpl extends SAX2D
     private int _namesSize = -1;
 
     // Namespace related stuff
-    private Hashtable _nsIndex = new Hashtable();
+    private Map<Integer, Integer> _nsIndex = new HashMap<>();
 
     // The initial size of the text buffer
     private int _size = 0;
@@ -134,10 +129,10 @@ public final class SAXImpl extends SAX2D
     // The owner Document when the input source is DOMSource.
     private Document _document;
 
-    // The hashtable for org.w3c.dom.Node to node id mapping.
+    // The Map for org.w3c.dom.Node to node id mapping.
     // This is only used when the input is a DOMSource and the
     // buildIdIndex flag is true.
-    private Hashtable _node2Ids = null;
+    private Map<Node, Integer> _node2Ids = null;
 
     // True if the input source is a DOMSource.
     private boolean _hasDOMSource = false;
@@ -480,7 +475,7 @@ public final class SAXImpl extends SAX2D
             return 0;
         }
         int eType = getIdForNamespace(s);
-        return ((Integer)_nsIndex.get(new Integer(eType))).intValue();
+        return _nsIndex.get(new Integer(eType));
     }
 
 
@@ -679,9 +674,9 @@ public final class SAXImpl extends SAX2D
 
         for (i=0; i<nsLength; i++) {
             int eType = getIdForNamespace(namespaces[i]);
-            Integer type = (Integer)_nsIndex.get(new Integer(eType));
+            Integer type = _nsIndex.get(eType);
             if (type != null) {
-                result[type.intValue()] = (short)i;
+                result[type] = (short)i;
             }
         }
 
@@ -699,7 +694,7 @@ public final class SAXImpl extends SAX2D
 
         for (i = 0; i < length; i++) {
             int eType = getIdForNamespace(namespaces[i]);
-            Integer type = (Integer)_nsIndex.get(new Integer(eType));
+            Integer type = _nsIndex.get(eType);
             result[i] = (type == null) ? -1 : type.shortValue();
         }
 
@@ -752,7 +747,7 @@ public final class SAXImpl extends SAX2D
             else {
                 _document = node.getOwnerDocument();
             }
-            _node2Ids = new Hashtable();
+            _node2Ids = new HashMap<>();
         }
     }
 
@@ -780,8 +775,8 @@ public final class SAXImpl extends SAX2D
     {
         Node node = _document.getElementById(idString);
         if (node != null) {
-            Integer id = (Integer)_node2Ids.get(node);
-            return (id != null) ? id.intValue() : DTM.NULL;
+            Integer id = _node2Ids.get(node);
+            return (id != null) ? id : DTM.NULL;
         }
         else {
             return DTM.NULL;
@@ -880,7 +875,7 @@ public final class SAXImpl extends SAX2D
     {
         super.startDocument();
 
-        _nsIndex.put(new Integer(0), new Integer(_uriCount++));
+        _nsIndex.put(0, _uriCount++);
         definePrefixAndUri(XML_PREFIX, XML_URI);
     }
 
@@ -987,8 +982,8 @@ public final class SAXImpl extends SAX2D
     {
         // Check if the URI already exists before pushing on stack
         Integer eType = new Integer(getIdForNamespace(uri));
-        if ((Integer)_nsIndex.get(eType) == null) {
-            _nsIndex.put(eType, new Integer(_uriCount++));
+        if (_nsIndex.get(eType) == null) {
+            _nsIndex.put(eType, _uriCount++);
         }
     }
 
@@ -1840,28 +1835,11 @@ public final class SAXImpl extends SAX2D
     }
 
     /**
-     * %HZ% Need Javadoc
+     * Return the attributes map.
+     * @return the attributes map.
      */
-    public Hashtable getElementsWithIDs() {
-        if (m_idAttributes == null) {
-            return null;
-        }
-
-        // Convert a java.util.Hashtable to an xsltc.runtime.Hashtable
-        Enumeration idValues = m_idAttributes.keys();
-        if (!idValues.hasMoreElements()) {
-            return null;
-        }
-
-        Hashtable idAttrsTable = new Hashtable();
-
-        while (idValues.hasMoreElements()) {
-            Object idValue = idValues.nextElement();
-
-            idAttrsTable.put(idValue, m_idAttributes.get(idValue));
-        }
-
-        return idAttrsTable;
+    public Map<String, Integer> getElementsWithIDs() {
+        return m_idAttributes;
     }
 
     /**
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SimpleResultTreeImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SimpleResultTreeImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/dom/SimpleResultTreeImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,12 +23,10 @@
 package com.sun.org.apache.xalan.internal.xsltc.dom;
 
 import com.sun.org.apache.xalan.internal.xsltc.DOM;
-import com.sun.org.apache.xalan.internal.xsltc.TransletException;
 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
-
-import com.sun.org.apache.xml.internal.dtm.DTM;
+import com.sun.org.apache.xalan.internal.xsltc.TransletException;
 import com.sun.org.apache.xml.internal.dtm.Axis;
+import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisTraverser;
 import com.sun.org.apache.xml.internal.dtm.DTMManager;
@@ -38,14 +36,12 @@ import com.sun.org.apache.xml.internal.s
 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
 import com.sun.org.apache.xml.internal.utils.XMLString;
 import com.sun.org.apache.xml.internal.utils.XMLStringDefault;
-
+import java.util.Map;
+import javax.xml.transform.SourceLocator;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
-
 import org.xml.sax.SAXException;
 
-import javax.xml.transform.SourceLocator;
-
 /**
  * This class represents a light-weight DOM model for simple result tree fragment(RTF).
  * A simple RTF is an RTF that has only one Text node. The Text node can be produced by a
@@ -608,7 +604,7 @@ public class SimpleResultTreeImpl extend
         return null;
     }
 
-    public Hashtable getElementsWithIDs()
+    public Map<String, Integer> getElementsWithIDs()
     {
         return null;
     }
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -18,6 +18,7 @@
  * limitations under the License.
  */
 /*
+/*
  * $Id: AbstractTranslet.java,v 1.6 2006/06/19 19:49:03 spericas Exp $
  */
 
@@ -25,22 +26,6 @@ package com.sun.org.apache.xalan.interna
 
 import com.sun.org.apache.xalan.internal.XalanConstants;
 import com.sun.org.apache.xalan.internal.utils.FactoryImpl;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.BufferedOutputStream;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.Vector;
-import javax.xml.transform.Templates;
-import javax.xml.parsers.DocumentBuilderFactory;
-import org.w3c.dom.Document;
-import org.w3c.dom.DOMImplementation;
-import javax.xml.parsers.ParserConfigurationException;
-
-import com.sun.org.apache.xml.internal.dtm.DTM;
-
 import com.sun.org.apache.xalan.internal.xsltc.DOM;
 import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
 import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
@@ -49,8 +34,23 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.dom.DOMAdapter;
 import com.sun.org.apache.xalan.internal.xsltc.dom.KeyIndex;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory;
+import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Vector;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.Templates;
+import org.w3c.dom.DOMImplementation;
+import org.w3c.dom.Document;
 
 /**
  * @author Jacek Ambroziak
@@ -271,15 +271,15 @@ public abstract class AbstractTranslet i
      ************************************************************************/
 
     // Contains decimal number formatting symbols used by FormatNumberCall
-    public Hashtable _formatSymbols = null;
+    public Map<String, DecimalFormat> _formatSymbols = null;
 
     /**
-     * Adds a DecimalFormat object to the _formatSymbols hashtable.
+     * Adds a DecimalFormat object to the _formatSymbols map.
      * The entry is created with the input DecimalFormatSymbols.
      */
     public void addDecimalFormat(String name, DecimalFormatSymbols symbols) {
-        // Instanciate hashtable for formatting symbols if needed
-        if (_formatSymbols == null) _formatSymbols = new Hashtable();
+        // Instanciate map for formatting symbols if needed
+        if (_formatSymbols == null) _formatSymbols = new HashMap<>();
 
         // The name cannot be null - use empty string instead
         if (name == null) name = EMPTYSTRING;
@@ -293,7 +293,7 @@ public abstract class AbstractTranslet i
     }
 
     /**
-     * Retrieves a named DecimalFormat object from _formatSymbols hashtable.
+     * Retrieves a named DecimalFormat object from the _formatSymbols map.
      */
     public final DecimalFormat getDecimalFormat(String name) {
 
@@ -301,8 +301,8 @@ public abstract class AbstractTranslet i
             // The name cannot be null - use empty string instead
             if (name == null) name = EMPTYSTRING;
 
-            DecimalFormat df = (DecimalFormat)_formatSymbols.get(name);
-            if (df == null) df = (DecimalFormat)_formatSymbols.get(EMPTYSTRING);
+            DecimalFormat df = _formatSymbols.get(name);
+            if (df == null) df = _formatSymbols.get(EMPTYSTRING);
             return df;
         }
         return(null);
@@ -338,26 +338,19 @@ public abstract class AbstractTranslet i
                 return;
             }
             else {
-                final Hashtable elementsByID = enhancedDOM.getElementsWithIDs();
+                final Map<String, Integer> elementsByID = enhancedDOM.getElementsWithIDs();
 
                 if (elementsByID == null) {
                     return;
                 }
 
-                // Given a Hashtable of DTM nodes indexed by ID attribute values,
+                // Given a Map of DTM nodes indexed by ID attribute values,
                 // loop through the table copying information to a KeyIndex
                 // for the mapping from ID attribute value to DTM node
-                final Enumeration idValues = elementsByID.keys();
                 boolean hasIDValues = false;
-
-                while (idValues.hasMoreElements()) {
-                    final Object idValue = idValues.nextElement();
-                    final int element =
-                            document.getNodeHandle(
-                                        ((Integer)elementsByID.get(idValue))
-                                                .intValue());
-
-                    buildKeyIndex(ID_INDEX_NAME, element, idValue);
+                for (Map.Entry<String, Integer> entry : elementsByID.entrySet()) {
+                    final int element = document.getNodeHandle(entry.getValue());
+                    buildKeyIndex(ID_INDEX_NAME, element, entry.getKey());
                     hasIDValues = true;
                 }
 
@@ -425,7 +418,7 @@ public abstract class AbstractTranslet i
      ************************************************************************/
 
     // Container for all indexes for xsl:key elements
-    private Hashtable _keyIndexes = null;
+    private Map<String, KeyIndex> _keyIndexes = null;
     private KeyIndex  _emptyKeyIndex = null;
     private int       _indexSize = 0;
     private int       _currentRootForKeys = 0;
@@ -451,13 +444,8 @@ public abstract class AbstractTranslet i
      *   @param node is the node handle of the node to insert
      *   @param value is the value that will look up the node in the given index
      */
-    public void buildKeyIndex(String name, int node, Object value) {
-        if (_keyIndexes == null) _keyIndexes = new Hashtable();
-
-        KeyIndex index = (KeyIndex)_keyIndexes.get(name);
-        if (index == null) {
-            _keyIndexes.put(name, index = new KeyIndex(_indexSize));
-        }
+    public void buildKeyIndex(String name, int node, String value) {
+        KeyIndex index = buildKeyIndexHelper(name);
         index.add(value, node, _currentRootForKeys);
     }
 
@@ -467,18 +455,33 @@ public abstract class AbstractTranslet i
      *   @param dom is the DOM
      */
     public void buildKeyIndex(String name, DOM dom) {
-        if (_keyIndexes == null) _keyIndexes = new Hashtable();
+        KeyIndex index = buildKeyIndexHelper(name);
+        index.setDom(dom, dom.getDocument());
+    }
 
-        KeyIndex index = (KeyIndex)_keyIndexes.get(name);
+    /**
+     * Return KeyIndex for the buildKeyIndex methods. Note the difference from the
+     * public getKeyIndex method, this method creates a new Map if keyIndexes does
+     * not exist.
+     *
+     * @param name the name of the index (the key or ##id)
+     * @return a KeyIndex.
+     */
+    private KeyIndex buildKeyIndexHelper(String name) {
+        if (_keyIndexes == null) _keyIndexes = new HashMap<>();
+
+        KeyIndex index = _keyIndexes.get(name);
         if (index == null) {
             _keyIndexes.put(name, index = new KeyIndex(_indexSize));
         }
-        index.setDom(dom, dom.getDocument());
+        return index;
     }
 
     /**
      * Returns the index for a given key (or id).
      * The index implements our internal iterator interface
+     * @param name the name of the index (the key or ##id)
+     * @return a KeyIndex.
      */
     public KeyIndex getKeyIndex(String name) {
         // Return an empty key index iterator if none are defined
@@ -489,7 +492,7 @@ public abstract class AbstractTranslet i
         }
 
         // Look up the requested key index
-        final KeyIndex index = (KeyIndex)_keyIndexes.get(name);
+        final KeyIndex index = _keyIndexes.get(name);
 
         // Return an empty key index iterator if the requested index not found
         if (index == null) {
@@ -706,14 +709,14 @@ public abstract class AbstractTranslet i
         }
     }
 
-    private Hashtable _auxClasses = null;
+    private Map<String, Class<?>> _auxClasses = null;
 
     public void addAuxiliaryClass(Class auxClass) {
-        if (_auxClasses == null) _auxClasses = new Hashtable();
+        if (_auxClasses == null) _auxClasses = new HashMap<>();
         _auxClasses.put(auxClass.getName(), auxClass);
     }
 
-    public void setAuxiliaryClasses(Hashtable auxClasses) {
+    public void setAuxiliaryClasses(Map<String, Class<?>> auxClasses) {
         _auxClasses = auxClasses;
     }
 
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -24,39 +24,36 @@
 package com.sun.org.apache.xalan.internal.xsltc.runtime;
 
 import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.text.FieldPosition;
-import java.text.MessageFormat;
-import java.text.NumberFormat;
-import java.util.Locale;
-import java.util.ResourceBundle;
-import javax.xml.transform.dom.DOMSource;
-
 import com.sun.org.apache.xalan.internal.xsltc.DOM;
 import com.sun.org.apache.xalan.internal.xsltc.Translet;
 import com.sun.org.apache.xalan.internal.xsltc.dom.AbsoluteIterator;
-import com.sun.org.apache.xml.internal.dtm.Axis;
+import com.sun.org.apache.xalan.internal.xsltc.dom.ArrayNodeListIterator;
 import com.sun.org.apache.xalan.internal.xsltc.dom.DOMAdapter;
 import com.sun.org.apache.xalan.internal.xsltc.dom.MultiDOM;
 import com.sun.org.apache.xalan.internal.xsltc.dom.SingletonIterator;
 import com.sun.org.apache.xalan.internal.xsltc.dom.StepIterator;
-import com.sun.org.apache.xalan.internal.xsltc.dom.ArrayNodeListIterator;
+import com.sun.org.apache.xml.internal.dtm.Axis;
 import com.sun.org.apache.xml.internal.dtm.DTM;
 import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
 import com.sun.org.apache.xml.internal.dtm.DTMManager;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMDefaultBase;
 import com.sun.org.apache.xml.internal.dtm.ref.DTMNodeProxy;
-
-import org.w3c.dom.DOMException;
+import com.sun.org.apache.xml.internal.serializer.NamespaceMappings;
+import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
+import com.sun.org.apache.xml.internal.utils.XML11Char;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.text.FieldPosition;
+import java.text.MessageFormat;
+import java.text.NumberFormat;
+import java.util.Locale;
+import java.util.ResourceBundle;
+import javax.xml.transform.dom.DOMSource;
 import org.w3c.dom.Attr;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
-import com.sun.org.apache.xml.internal.serializer.NamespaceMappings;
-import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
-import com.sun.org.apache.xml.internal.utils.XML11Char;
 
 /**
  * Standard XSLT functions. All standard functions expect the current node
@@ -983,7 +980,7 @@ public final class BasisLibrary {
 
     /**
      * Utility function: used to format/adjust  a double to a string. The
-     * DecimalFormat object comes from the 'formatSymbols' hashtable in
+     * DecimalFormat object comes from the 'formatSymbols' map in
      * AbstractTranslet.
      */
     private static FieldPosition _fieldPosition = new FieldPosition(0);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/DOM2SAX.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/DOM2SAX.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/DOM2SAX.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -24,14 +24,15 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.trax;
 
+import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
+import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
 import java.io.IOException;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Stack;
 import java.util.Vector;
-
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
-
 import org.xml.sax.ContentHandler;
 import org.xml.sax.DTDHandler;
 import org.xml.sax.EntityResolver;
@@ -44,8 +45,6 @@ import org.xml.sax.SAXNotSupportedExcept
 import org.xml.sax.XMLReader;
 import org.xml.sax.ext.LexicalHandler;
 import org.xml.sax.helpers.AttributesImpl;
-import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;
 
 /**
  * @author G. Todd Miller
@@ -59,7 +58,7 @@ public class DOM2SAX implements XMLReade
     private ContentHandler _sax = null;
     private LexicalHandler _lex = null;
     private SAXImpl _saxImpl = null;
-    private Hashtable _nsPrefixes = new Hashtable();
+    private Map<String, Stack> _nsPrefixes = new HashMap<>();
 
     public DOM2SAX(Node root) {
         _dom = root;
@@ -91,7 +90,7 @@ public class DOM2SAX implements XMLReade
         throws SAXException
     {
         boolean pushed = true;
-        Stack uriStack = (Stack) _nsPrefixes.get(prefix);
+        Stack uriStack = _nsPrefixes.get(prefix);
 
         if (uriStack != null) {
             if (uriStack.isEmpty()) {
@@ -124,7 +123,7 @@ public class DOM2SAX implements XMLReade
     private void endPrefixMapping(String prefix)
         throws SAXException
     {
-        final Stack uriStack = (Stack) _nsPrefixes.get(prefix);
+        final Stack uriStack = _nsPrefixes.get(prefix);
 
         if (uriStack != null) {
             _sax.endPrefixMapping(prefix);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/StAXEvent2SAX.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/StAXEvent2SAX.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/StAXEvent2SAX.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -75,7 +75,6 @@ public class StAXEvent2SAX implements XM
     private ContentHandler _sax = null;
     private LexicalHandler _lex = null;
     private SAXImpl _saxImpl = null;
-    //private Hashtable _nsPrefixes = new Hashtable();
     private String version = null;
     private String encoding = null;
 
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/StAXStream2SAX.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/StAXStream2SAX.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/StAXStream2SAX.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,12 +25,12 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.trax;
 
+import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
 import java.io.IOException;
-import java.util.Hashtable;
-import java.util.Stack;
-import java.util.Vector;
-import java.util.Iterator;
-
+import javax.xml.namespace.QName;
+import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
 import org.xml.sax.Attributes;
 import org.xml.sax.ContentHandler;
 import org.xml.sax.DTDHandler;
@@ -45,22 +45,6 @@ import org.xml.sax.XMLReader;
 import org.xml.sax.ext.LexicalHandler;
 import org.xml.sax.ext.Locator2;
 import org.xml.sax.helpers.AttributesImpl;
-import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
-
-
-
-import javax.xml.namespace.QName;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.events.Attribute;
-import javax.xml.stream.events.Characters;
-import javax.xml.stream.events.EndElement;
-import javax.xml.stream.events.Namespace;
-import javax.xml.stream.events.ProcessingInstruction;
-import javax.xml.stream.events.StartElement;
-import javax.xml.stream.events.StartDocument;
-import javax.xml.stream.events.XMLEvent;
 
 
 
@@ -80,7 +64,6 @@ public class StAXStream2SAX implements X
     private ContentHandler _sax = null;
     private LexicalHandler _lex = null;
     private SAXImpl _saxImpl = null;
-    //private Hashtable _nsPrefixes = new Hashtable();
 
     public StAXStream2SAX(XMLStreamReader staxSrc) {
             staxStreamReader = staxSrc;
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -30,13 +30,15 @@ import com.sun.org.apache.xalan.internal
 import com.sun.org.apache.xalan.internal.xsltc.Translet;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
 import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
 import java.io.Serializable;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.util.HashMap;
+import java.util.Hashtable;
 import java.util.Map;
 import java.util.Properties;
 import javax.xml.XMLConstants;
@@ -89,7 +91,7 @@ public final class TemplatesImpl impleme
     /**
      * Contains the list of auxiliary class definitions.
      */
-    private Hashtable _auxClasses = null;
+    private Map<String, Class<?>> _auxClasses = null;
 
     /**
      * Output properties of this translet.
@@ -122,19 +124,41 @@ public final class TemplatesImpl impleme
      */
     private transient TransformerFactoryImpl _tfactory = null;
 
-    private boolean _useServicesMechanism;
+    /**
+     * A flag to determine whether the Service Mechanism is used
+     */
+    private transient boolean _useServicesMechanism;
 
     /**
      * protocols allowed for external references set by the stylesheet processing instruction, Import and Include element.
      */
-    private String _accessExternalStylesheet = XalanConstants.EXTERNAL_ACCESS_DEFAULT;
+    private transient String _accessExternalStylesheet = XalanConstants.EXTERNAL_ACCESS_DEFAULT;
 
-    static final class TransletClassLoader extends ClassLoader {
+    /**
+     * @serialField _name String The Name of the main class
+     * @serialField _bytecodes byte[][] Class definition
+     * @serialField _class Class[] The translet class definition(s).
+     * @serialField _transletIndex int The index of the main translet class
+     * @serialField _auxClasses Hashtable The list of auxiliary class definitions.
+     * @serialField _outputProperties Properties Output properties of this translet.
+     * @serialField _indentNumber int Number of spaces to add for output indentation.
+     */
+    private static final ObjectStreamField[] serialPersistentFields =
+        new ObjectStreamField[] {
+            new ObjectStreamField("_name", String.class),
+            new ObjectStreamField("_bytecodes", byte[][].class),
+            new ObjectStreamField("_class", Class[].class),
+            new ObjectStreamField("_transletIndex", int.class),
+            new ObjectStreamField("_auxClasses", Hashtable.class),
+            new ObjectStreamField("_outputProperties", Properties.class),
+            new ObjectStreamField("_indentNumber", int.class),
+        };
 
+    static final class TransletClassLoader extends ClassLoader {
         private final Map<String,Class> _loadedExternalExtensionFunctions;
 
-        TransletClassLoader(ClassLoader parent) {
-            super(parent);
+         TransletClassLoader(ClassLoader parent) {
+             super(parent);
             _loadedExternalExtensionFunctions = null;
         }
 
@@ -154,7 +178,7 @@ public final class TemplatesImpl impleme
                 ret = super.loadClass(name);
             }
             return ret;
-        }
+         }
 
         /**
          * Access to final protected superclass member from outer class.
@@ -226,7 +250,20 @@ public final class TemplatesImpl impleme
             }
         }
 
-        is.defaultReadObject();
+        // We have to read serialized fields first.
+        ObjectInputStream.GetField gf = is.readFields();
+        _name = (String)gf.get("_name", null);
+        _bytecodes = (byte[][])gf.get("_bytecodes", null);
+        _class = (Class[])gf.get("_class", null);
+        _transletIndex = gf.get("_transletIndex", -1);
+
+        Hashtable<String, Class<?>> aux = (Hashtable<String, Class<?>>)gf.get("_auxClasses", null);
+        _outputProperties = (Properties)gf.get("_outputProperties", null);
+        _indentNumber = gf.get("_indentNumber", 0);
+
+        //convert Hashtable back to HashMap
+        if (aux != null) _auxClasses = new HashMap<>(aux);
+
         if (is.readBoolean()) {
             _uriResolver = (URIResolver) is.readObject();
         }
@@ -242,7 +279,20 @@ public final class TemplatesImpl impleme
      */
     private void writeObject(ObjectOutputStream os)
         throws IOException, ClassNotFoundException {
-        os.defaultWriteObject();
+        // Convert Maps to Hashtables
+        Hashtable<String, Class<?>> aux = (_auxClasses == null)? null : new Hashtable<>(_auxClasses);
+
+        // Write serialized fields
+        ObjectOutputStream.PutField pf = os.putFields();
+        pf.put("_name", _name);
+        pf.put("_bytecodes", _bytecodes);
+        pf.put("_class", _class);
+        pf.put("_transletIndex", _transletIndex);
+        pf.put("_auxClasses", aux);
+        pf.put("_outputProperties", _outputProperties);
+        pf.put("_indentNumber", _indentNumber);
+        os.writeFields();
+
         if (_uriResolver instanceof Serializable) {
             os.writeBoolean(true);
             os.writeObject((Serializable) _uriResolver);
@@ -360,7 +410,7 @@ public final class TemplatesImpl impleme
             _class = new Class[classCount];
 
             if (classCount > 1) {
-                _auxClasses = new Hashtable();
+                _auxClasses = new HashMap<>();
             }
 
             for (int i = 0; i < classCount; i++) {
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -49,7 +49,6 @@ import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.Enumeration;
-import java.util.Hashtable;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Vector;
@@ -73,7 +72,8 @@ import javax.xml.transform.sax.SAXSource
 import javax.xml.transform.sax.SAXTransformerFactory;
 import javax.xml.transform.sax.TemplatesHandler;
 import javax.xml.transform.sax.TransformerHandler;
-import javax.xml.transform.stax.*;
+import javax.xml.transform.stax.StAXResult;
+import javax.xml.transform.stax.StAXSource;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 import org.xml.sax.InputSource;
@@ -146,13 +146,13 @@ public class TransformerFactoryImpl
     private String _jarFileName = null;
 
     /**
-     * This Hashtable is used to store parameters for locating
+     * This Map is used to store parameters for locating
      * <?xml-stylesheet ...?> processing instructions in XML docs.
      */
-    private Hashtable _piParams = null;
+    private Map<Source, PIParamWrapper> _piParams = null;
 
     /**
-     * The above hashtable stores objects of this class.
+     * The above Map stores objects of this class.
      */
     private static class PIParamWrapper {
         public String _media = null;
@@ -932,7 +932,7 @@ public class TransformerFactoryImpl
         // <?xml-stylesheet ...?> PI in an XML input document
         if ((_piParams != null) && (_piParams.get(source) != null)) {
             // Get the parameters for this Source object
-            PIParamWrapper p = (PIParamWrapper)_piParams.get(source);
+            PIParamWrapper p = _piParams.get(source);
             // Pass them on to the compiler (which will pass then to the parser)
             if (p != null) {
                 xsltc.setPIParameters(p._media, p._title, p._charset);
Index: openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -26,6 +26,22 @@ package com.sun.org.apache.xalan.interna
 import com.sun.org.apache.xalan.internal.XalanConstants;
 import com.sun.org.apache.xalan.internal.utils.FactoryImpl;
 import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
+import com.sun.org.apache.xalan.internal.xsltc.DOM;
+import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
+import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
+import com.sun.org.apache.xalan.internal.xsltc.Translet;
+import com.sun.org.apache.xalan.internal.xsltc.TransletException;
+import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
+import com.sun.org.apache.xalan.internal.xsltc.dom.DOMWSFilter;
+import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
+import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
+import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
+import com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory;
+import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
+import com.sun.org.apache.xml.internal.serializer.OutputPropertiesFactory;
+import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
+import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
+import com.sun.org.apache.xml.internal.utils.XMLReaderManager;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -38,11 +54,12 @@ import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownServiceException;
 import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Properties;
 import java.util.StringTokenizer;
 import java.util.Vector;
-import java.lang.reflect.Constructor;
-
+import javax.xml.XMLConstants;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
@@ -63,29 +80,6 @@ import javax.xml.transform.stax.StAXResu
 import javax.xml.transform.stax.StAXSource;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
-import javax.xml.XMLConstants;
-
-import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
-
-import com.sun.org.apache.xalan.internal.xsltc.DOM;
-import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
-import com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;
-import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
-import com.sun.org.apache.xalan.internal.xsltc.Translet;
-import com.sun.org.apache.xalan.internal.xsltc.TransletException;
-import com.sun.org.apache.xml.internal.serializer.OutputPropertiesFactory;
-import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
-import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
-import com.sun.org.apache.xalan.internal.xsltc.dom.DOMWSFilter;
-import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
-import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable;
-import com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory;
-
-import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
-import com.sun.org.apache.xml.internal.utils.XMLReaderManager;
-
 import org.xml.sax.ContentHandler;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
@@ -221,11 +215,11 @@ public final class TransformerImpl exten
 
     private XMLSecurityManager _securityManager;
     /**
-     * A hashtable to store parameters for the identity transform. These
+     * A map to store parameters for the identity transform. These
      * are not needed during the transformation, but we must keep track of
      * them to be fully complaint with the JAXP API.
      */
-    private Hashtable _parameters = null;
+    private Map<String, Object> _parameters = null;
 
     /**
      * This class wraps an ErrorListener into a MessageHandler in order to
@@ -828,31 +822,6 @@ public final class TransformerImpl exten
     }
 
     /**
-     * The translet stores all CDATA sections set in the <xsl:output> element
-     * in a Hashtable. This method will re-construct the whitespace separated
-     * list of elements given in the <xsl:output> element.
-     */
-    private String makeCDATAString(Hashtable cdata) {
-        // Return a 'null' string if no CDATA section elements were specified
-        if (cdata == null) return null;
-
-        StringBuffer result = new StringBuffer();
-
-        // Get an enumeration of all the elements in the hashtable
-        Enumeration elements = cdata.keys();
-        if (elements.hasMoreElements()) {
-            result.append((String)elements.nextElement());
-            while (elements.hasMoreElements()) {
-                String element = (String)elements.nextElement();
-                result.append(' ');
-                result.append(element);
-            }
-        }
-
-        return(result.toString());
-    }
-
-    /**
      * Implements JAXP's Transformer.getOutputProperties().
      * Returns a copy of the output properties for the transformation. This is
      * a set of layered properties. The first layer contains properties set by
@@ -1220,7 +1189,7 @@ public final class TransformerImpl exten
 
         if (_isIdentity) {
             if (_parameters == null) {
-                _parameters = new Hashtable();
+                _parameters = new HashMap<>();
             }
             _parameters.put(name, value);
         }
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/CoreDocumentImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/CoreDocumentImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/CoreDocumentImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -17,25 +17,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.sun.org.apache.xerces.internal.dom;
 
-import java.lang.reflect.Constructor;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import com.sun.org.apache.xerces.internal.util.URI;
 import com.sun.org.apache.xerces.internal.impl.Constants;
-
-import org.w3c.dom.DOMConfiguration;
-import org.w3c.dom.UserDataHandler;
-import com.sun.org.apache.xerces.internal.util.XMLChar;
+import com.sun.org.apache.xerces.internal.util.URI;
 import com.sun.org.apache.xerces.internal.util.XML11Char;
-import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
+import com.sun.org.apache.xerces.internal.util.XMLChar;
 import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
 import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
+import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Map;
 import org.w3c.dom.Attr;
 import org.w3c.dom.CDATASection;
 import org.w3c.dom.Comment;
+import org.w3c.dom.DOMConfiguration;
 import org.w3c.dom.DOMException;
 import org.w3c.dom.DOMImplementation;
 import org.w3c.dom.Document;
@@ -50,6 +52,7 @@ import org.w3c.dom.NodeList;
 import org.w3c.dom.Notation;
 import org.w3c.dom.ProcessingInstruction;
 import org.w3c.dom.Text;
+import org.w3c.dom.UserDataHandler;
 import org.w3c.dom.events.Event;
 import org.w3c.dom.events.EventListener;
 import org.w3c.dom.ls.DOMImplementationLS;
@@ -82,17 +85,15 @@ import org.w3c.dom.ls.LSSerializer;
  * @version $Id: CoreDocumentImpl.java,v 1.9 2010-11-01 04:39:37 joehw Exp $
  * @since  PR-DOM-Level-1-19980818.
  */
-
-
 public class CoreDocumentImpl
-extends ParentNode implements Document  {
+        extends ParentNode implements Document {
 
-        /**TODO::
-         * 1. Change XML11Char method names similar to XMLChar. That will prevent lot
-         * of dirty version checking code.
-         *
-         * 2. IMO during cloneNode qname/isXMLName check should not be made.
-         */
+    /**
+     * TODO:: 1. Change XML11Char method names similar to XMLChar. That will
+     * prevent lot of dirty version checking code.
+     *
+     * 2. IMO during cloneNode qname/isXMLName check should not be made.
+     */
     //
     // Constants
     //
@@ -130,13 +131,12 @@ extends ParentNode implements Document
     /**Experimental DOM Level 3 feature: documentURI */
     protected String fDocumentURI;
 
-        //Revisit :: change to a better data structure.
+    //Revisit :: change to a better data structure.
     /** Table for user data attached to this document nodes. */
-    protected Hashtable userData;
-
+    private Map<Node, Map<String, UserDataRecord>> nodeUserData;
 
     /** Identifiers. */
-    protected Hashtable identifiers;
+    protected Map<String, Node> identifiers;
 
     // DOM Level 3: normalizeDocument
     transient DOMNormalizer domNormalizer = null;
@@ -207,7 +207,7 @@ extends ParentNode implements Document
     // document.  Node number values are negative integers.  Nodes are
     // assigned numbers on demand.
     private int nodeCounter = 0;
-    private Hashtable nodeTable;
+    private Map<Node, Integer> nodeTable;
     private boolean xml11Version = false; //by default 1.0
     //
     // Static initialization
@@ -243,6 +243,52 @@ extends ParentNode implements Document
 
     } // static
 
+    /**
+     * @serialField docType DocumentTypeImpl document type
+     * @serialField docElement ElementImpl document element
+     * @serialField fFreeNLCache NodeListCache NodeListCache free list
+     * @serialField encoding String Document encoding
+     * @serialField actualEncoding String Document actualEncoding
+     * @serialField version String Document version
+     * @serialField standalone boolean Document standalone
+     * @serialField fDocumentURI String Document URI
+     * @serialField userData Hashtable user data attached to the nodes. Note that
+     * it was original called "userData". It has been changed to nodeUserData to
+     * avoid confusion with those that are actually values of the map.
+     * @serialField identifiers Hashtable identifiers
+     * @serialField changes int flag indicates whether the node has changed
+     * @serialField allowGrammarAccess boolean Allow grammar access
+     * @serialField errorChecking boolean Bypass error checking
+     * @serialField ancestorChecking boolean Ancestor checking
+     * @serialField xmlVersionChanged boolean Indicate whether the version has changed
+     * @serialField documentNumber int Document number
+     * @serialField nodeCounter int Node counter
+     * @serialField nodeTable Hashtable Node table
+     * @serialField xml11Version boolean XML version
+     */
+    private static final ObjectStreamField[] serialPersistentFields =
+        new ObjectStreamField[] {
+            new ObjectStreamField("docType", DocumentTypeImpl.class),
+            new ObjectStreamField("docElement", ElementImpl.class),
+            new ObjectStreamField("fFreeNLCache", NodeListCache.class),
+            new ObjectStreamField("encoding", String.class),
+            new ObjectStreamField("actualEncoding", String.class),
+            new ObjectStreamField("version", String.class),
+            new ObjectStreamField("standalone", boolean.class),
+            new ObjectStreamField("fDocumentURI", String.class),
+            new ObjectStreamField("userData", Hashtable.class),
+            new ObjectStreamField("identifiers", Hashtable.class),
+            new ObjectStreamField("changes", int.class),
+            new ObjectStreamField("allowGrammarAccess", boolean.class),
+            new ObjectStreamField("errorChecking", boolean.class),
+            new ObjectStreamField("ancestorChecking", boolean.class),
+            new ObjectStreamField("xmlVersionChanged", boolean.class),
+            new ObjectStreamField("documentNumber", int.class),
+            new ObjectStreamField("nodeCounter", int.class),
+            new ObjectStreamField("nodeTable", Hashtable.class),
+            new ObjectStreamField("xml11Version", boolean.class),
+        };
+
     //
     // Constructors
     //
@@ -343,24 +389,21 @@ extends ParentNode implements Document
         }
 
         if (deep) {
-            Hashtable reversedIdentifiers = null;
+            Map<Node, String> reversedIdentifiers = null;
 
             if (identifiers != null) {
                 // Build a reverse mapping from element to identifier.
-                reversedIdentifiers = new Hashtable();
-                Enumeration elementIds = identifiers.keys();
-                while (elementIds.hasMoreElements()) {
-                    Object elementId = elementIds.nextElement();
-                    reversedIdentifiers.put(identifiers.get(elementId),
-                    elementId);
+                reversedIdentifiers = new HashMap<>(identifiers.size());
+                for (String elementId : identifiers.keySet()) {
+                    reversedIdentifiers.put(identifiers.get(elementId), elementId);
                 }
             }
 
             // Copy children into new document.
             for (ChildNode kid = firstChild; kid != null;
-            kid = kid.nextSibling) {
+                    kid = kid.nextSibling) {
                 newdoc.appendChild(newdoc.importNode(kid, true, true,
-                reversedIdentifiers));
+                        reversedIdentifiers));
             }
         }
 
@@ -385,7 +428,7 @@ extends ParentNode implements Document
      * document element nor the document type in any way
      */
     public Node insertBefore(Node newChild, Node refChild)
-    throws DOMException {
+            throws DOMException {
 
         // Only one such child permitted
         int type = newChild.getNodeType();
@@ -447,7 +490,7 @@ extends ParentNode implements Document
      * document element nor the document type in any way
      */
     public Node replaceChild(Node newChild, Node oldChild)
-    throws DOMException {
+            throws DOMException {
 
         // Adopt orphan doctypes
         if (newChild.getOwnerDocument() == null &&
@@ -463,8 +506,8 @@ extends ParentNode implements Document
             newChild.getNodeType() == Node.ELEMENT_NODE))) {
 
             throw new DOMException(
-                DOMException.HIERARCHY_REQUEST_ERR,
-                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "HIERARCHY_REQUEST_ERR", null));
+                    DOMException.HIERARCHY_REQUEST_ERR,
+                    DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "HIERARCHY_REQUEST_ERR", null));
         }
         super.replaceChild(newChild, oldChild);
 
@@ -491,7 +534,7 @@ extends ParentNode implements Document
      * @since DOM Level 3
      */
     public void setTextContent(String textContent)
-    throws DOMException {
+            throws DOMException {
         // no-op
     }
 
@@ -508,7 +551,7 @@ extends ParentNode implements Document
         // plus, only features whose interfaces are directly castable are
         // considered.
         if ((feature.equalsIgnoreCase("+XPath"))
-            && (anyVersion || version.equals("3.0"))) {
+                && (anyVersion || version.equals("3.0"))) {
 
             // If an XPathEvaluator was created previously
             // return it otherwise create a new one.
@@ -527,7 +570,7 @@ extends ParentNode implements Document
                 Class interfaces[] = xpathClass.getInterfaces();
                 for (int i = 0; i < interfaces.length; i++) {
                     if (interfaces[i].getName().equals(
-                    "org.w3c.dom.xpath.XPathEvaluator")) {
+                            "org.w3c.dom.xpath.XPathEvaluator")) {
                         fXPathEvaluator = xpathClassConstr.newInstance(new Object[] { this });
                         return fXPathEvaluator;
                     }
@@ -557,14 +600,14 @@ extends ParentNode implements Document
      * if the attribute name is not acceptable.
      */
     public Attr createAttribute(String name)
-        throws DOMException {
+            throws DOMException {
 
         if (errorChecking && !isXMLName(name,xml11Version)) {
             String msg =
                 DOMMessageFormatter.formatMessage(
-                    DOMMessageFormatter.DOM_DOMAIN,
-                    "INVALID_CHARACTER_ERR",
-                    null);
+                            DOMMessageFormatter.DOM_DOMAIN,
+                            "INVALID_CHARACTER_ERR",
+                            null);
             throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
         }
         return new AttrImpl(this, name);
@@ -581,7 +624,7 @@ extends ParentNode implements Document
      * not yet implemented.)
      */
     public CDATASection createCDATASection(String data)
-    throws DOMException {
+            throws DOMException {
         return new CDATASectionImpl(this, data);
     }
 
@@ -615,7 +658,7 @@ extends ParentNode implements Document
      * acceptable.
      */
     public Element createElement(String tagName)
-    throws DOMException {
+            throws DOMException {
 
         if (errorChecking && !isXMLName(tagName,xml11Version)) {
             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "INVALID_CHARACTER_ERR", null);
@@ -636,7 +679,7 @@ extends ParentNode implements Document
      * implemented.)
      */
     public EntityReference createEntityReference(String name)
-    throws DOMException {
+            throws DOMException {
 
         if (errorChecking && !isXMLName(name,xml11Version)) {
             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "INVALID_CHARACTER_ERR", null);
@@ -660,8 +703,8 @@ extends ParentNode implements Document
      * not yet implemented.)
      */
     public ProcessingInstruction createProcessingInstruction(String target,
-    String data)
-    throws DOMException {
+            String data)
+            throws DOMException {
 
         if (errorChecking && !isXMLName(target,xml11Version)) {
             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "INVALID_CHARACTER_ERR", null);
@@ -695,7 +738,6 @@ extends ParentNode implements Document
         return docType;
     }
 
-
     /**
      * Convenience method, allowing direct access to the child node
      * which is considered the root of the actual document content. For
@@ -787,7 +829,6 @@ extends ParentNode implements Document
         return errorChecking;
     }
 
-
     /**
      * DOM Level 3 CR - Experimental. (Was getActualEncoding)
      *
@@ -921,8 +962,8 @@ extends ParentNode implements Document
      * @since DOM Level 3
      */
     public void setXmlStandalone(boolean value)
-                                  throws DOMException {
-            standalone = value;
+            throws DOMException {
+        standalone = value;
     }
 
     /**
@@ -993,9 +1034,9 @@ extends ParentNode implements Document
                             if(colon1 != -1){
                                 String msg =
                                     DOMMessageFormatter.formatMessage(
-                                            DOMMessageFormatter.DOM_DOMAIN,
-                                            "NAMESPACE_ERR",
-                                            null);
+                                                DOMMessageFormatter.DOM_DOMAIN,
+                                                "NAMESPACE_ERR",
+                                                null);
                                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
                             }
                             if (!isXMLName(name,xml11Version)) {
@@ -1021,7 +1062,7 @@ extends ParentNode implements Document
                         copyEventListeners(el, nel);
 
                         // remove user data from old node
-                        Hashtable data = removeUserDataTable(el);
+                        Map<String, UserDataRecord> data = removeUserDataTable(el);
 
                         // remove old node from parent if any
                         Node parent = el.getParentNode();
@@ -1094,7 +1135,7 @@ extends ParentNode implements Document
                         copyEventListeners(at, nat);
 
                         // remove user data from old node
-                        Hashtable data = removeUserDataTable(at);
+                        Map<String, UserDataRecord> data = removeUserDataTable(at);
 
                         // move children to new node
                         Node child = at.getFirstChild();
@@ -1329,13 +1370,13 @@ extends ParentNode implements Document
      *   parameter is from an other document.
      */
     public String saveXML(Node node)
-    throws DOMException {
-        if ( errorChecking && node != null &&
-            this != node.getOwnerDocument() ) {
+            throws DOMException {
+        if (errorChecking && node != null
+                && this != node.getOwnerDocument()) {
             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "WRONG_DOCUMENT_ERR", null);
             throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);
         }
-        DOMImplementationLS domImplLS = (DOMImplementationLS)DOMImplementationImpl.getDOMImplementation();
+        DOMImplementationLS domImplLS = (DOMImplementationLS) DOMImplementationImpl.getDOMImplementation();
         LSSerializer xmlWriter = domImplLS.createLSSerializer();
         if (node == null) {
             node = this;
@@ -1344,8 +1385,8 @@ extends ParentNode implements Document
     }
 
     /**
-     * Sets whether the DOM implementation generates mutation events
-     * upon operations.
+     * Sets whether the DOM implementation generates mutation events upon
+     * operations.
      */
     void setMutationEvents(boolean set) {
         // does nothing by default - overidden in subclass
@@ -1359,47 +1400,40 @@ extends ParentNode implements Document
         return false;
     }
 
-
-
     // non-DOM factory methods
-
     /**
-     * NON-DOM
-     * Factory method; creates a DocumentType having this Document
-     * as its OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building
-     * DTD information unspecified.)
+     * NON-DOM Factory method; creates a DocumentType having this Document as
+     * its OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building DTD
+     * information unspecified.)
      *
      * @param name The name of the Entity we wish to provide a value for.
      *
-     * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where
-     * DTDs are not permitted. (HTML not yet implemented.)
+     * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where DTDs
+     * are not permitted. (HTML not yet implemented.)
      */
     public DocumentType createDocumentType(String qualifiedName,
-    String publicID,
-    String systemID)
-    throws DOMException {
+            String publicID,
+            String systemID)
+            throws DOMException {
 
         return new DocumentTypeImpl(this, qualifiedName, publicID, systemID);
 
     } // createDocumentType(String):DocumentType
 
     /**
-     * NON-DOM
-     * Factory method; creates an Entity having this Document
-     * as its OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building
-     * DTD information unspecified.)
+     * NON-DOM Factory method; creates an Entity having this Document as its
+     * OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building DTD
+     * information unspecified.)
      *
      * @param name The name of the Entity we wish to provide a value for.
      *
      * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where
-     * nonstandard entities are not permitted. (HTML not yet
-     * implemented.)
+     * nonstandard entities are not permitted. (HTML not yet implemented.)
      */
     public Entity createEntity(String name)
-    throws DOMException {
-
+            throws DOMException {
 
-        if (errorChecking && !isXMLName(name,xml11Version)) {
+        if (errorChecking && !isXMLName(name, xml11Version)) {
             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "INVALID_CHARACTER_ERR", null);
             throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
         }
@@ -1408,21 +1442,19 @@ extends ParentNode implements Document
     } // createEntity(String):Entity
 
     /**
-     * NON-DOM
-     * Factory method; creates a Notation having this Document
-     * as its OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building
-     * DTD information unspecified.)
+     * NON-DOM Factory method; creates a Notation having this Document as its
+     * OwnerDoc. (REC-DOM-Level-1-19981001 left the process of building DTD
+     * information unspecified.)
      *
      * @param name The name of the Notation we wish to describe
      *
      * @throws DOMException(NOT_SUPPORTED_ERR) for HTML documents, where
-     * notations are not permitted. (HTML not yet
-     * implemented.)
+     * notations are not permitted. (HTML not yet implemented.)
      */
     public Notation createNotation(String name)
-    throws DOMException {
+            throws DOMException {
 
-        if (errorChecking && !isXMLName(name,xml11Version)) {
+        if (errorChecking && !isXMLName(name, xml11Version)) {
             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "INVALID_CHARACTER_ERR", null);
             throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
         }
@@ -1435,9 +1467,9 @@ extends ParentNode implements Document
      * definitions hold default attribute values.
      */
     public ElementDefinitionImpl createElementDefinition(String name)
-    throws DOMException {
+            throws DOMException {
 
-        if (errorChecking && !isXMLName(name,xml11Version)) {
+        if (errorChecking && !isXMLName(name, xml11Version)) {
             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "INVALID_CHARACTER_ERR", null);
             throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
         }
@@ -1446,23 +1478,23 @@ extends ParentNode implements Document
     } // createElementDefinition(String):ElementDefinitionImpl
 
     // other non-DOM methods
-
-    /** NON-DOM:  Get the number associated with this document.   Used to
-     * order documents in the implementation.
+    /**
+     * NON-DOM: Get the number associated with this document. Used to order
+     * documents in the implementation.
      */
     protected int getNodeNumber() {
-        if (documentNumber==0) {
+        if (documentNumber == 0) {
 
-            CoreDOMImplementationImpl cd = (CoreDOMImplementationImpl)CoreDOMImplementationImpl.getDOMImplementation();
+            CoreDOMImplementationImpl cd = (CoreDOMImplementationImpl) CoreDOMImplementationImpl.getDOMImplementation();
             documentNumber = cd.assignDocumentNumber();
         }
         return documentNumber;
     }
 
-
-    /** NON-DOM:  Get a number associated with a node created with respect
-     * to this document.   Needed for compareDocumentPosition when nodes
-     * are disconnected.  This is only used on demand.
+    /**
+     * NON-DOM: Get a number associated with a node created with respect to this
+     * document. Needed for compareDocumentPosition when nodes are disconnected.
+     * This is only used on demand.
      */
     protected int getNodeNumber(Node node) {
 
@@ -1472,18 +1504,17 @@ extends ParentNode implements Document
         // Node numbers are negative, from -1 to -n
         int num;
         if (nodeTable == null) {
-            nodeTable = new Hashtable();
+            nodeTable = new HashMap<>();
             num = --nodeCounter;
             nodeTable.put(node, new Integer(num));
-        }
-        else {
-            Integer n = (Integer)nodeTable.get(node);
-            if (n== null) {
+        } else {
+            Integer n = nodeTable.get(node);
+            if (n == null) {
                 num = --nodeCounter;
-                nodeTable.put(node, new Integer(num));
-            }
-            else
+                nodeTable.put(node, num);
+            } else {
                 num = n.intValue();
+            }
         }
         return num;
     }
@@ -1498,7 +1529,7 @@ extends ParentNode implements Document
      * and a NOT_SUPPORTED_ERR exception is thrown if attempted.
      */
     public Node importNode(Node source, boolean deep)
-    throws DOMException {
+            throws DOMException {
         return importNode(source, deep, false, null);
     } // importNode(Node,boolean):Node
 
@@ -1507,18 +1538,18 @@ extends ParentNode implements Document
      * provides the core functionality for the public importNode and cloneNode
      * methods.
      *
-     * The reversedIdentifiers parameter is provided for cloneNode to
-     * preserve the document's identifiers. The Hashtable has Elements as the
-     * keys and their identifiers as the values. When an element is being
-     * imported, a check is done for an associated identifier. If one exists,
-     * the identifier is registered with the new, imported element. If
-     * reversedIdentifiers is null, the parameter is not applied.
+     * The reversedIdentifiers parameter is provided for cloneNode to preserve
+     * the document's identifiers. The Map has Elements as the keys and
+     * their identifiers as the values. When an element is being imported, a
+     * check is done for an associated identifier. If one exists, the identifier
+     * is registered with the new, imported element. If reversedIdentifiers is
+     * null, the parameter is not applied.
      */
     private Node importNode(Node source, boolean deep, boolean cloningDoc,
-    Hashtable reversedIdentifiers)
-    throws DOMException {
-        Node newnode=null;
-                Hashtable userData = null;
+            Map<Node, String> reversedIdentifiers)
+            throws DOMException {
+        Node newnode = null;
+        Map<String, UserDataRecord> userData = null;
 
         // Sigh. This doesn't work; too many nodes have private data that
         // would have to be manually tweaked. May be able to add local
@@ -1531,8 +1562,9 @@ extends ParentNode implements Document
         //  newnode.ownerDocument=this;
         // }
         // else
-                if(source instanceof NodeImpl)
-                        userData = ((NodeImpl)source).getUserDataRecord();
+        if (source instanceof NodeImpl) {
+            userData = ((NodeImpl) source).getUserDataRecord();
+        }
         int type = source.getNodeType();
         switch (type) {
             case ELEMENT_NODE: {
@@ -1543,7 +1575,7 @@ extends ParentNode implements Document
                     newElement = createElement(source.getNodeName());
                 else
                     newElement = createElementNS(source.getNamespaceURI(),
-                    source.getNodeName());
+                            source.getNodeName());
 
                 // Copy element's attributes, if any.
                 NamedNodeMap sourceAttrs = source.getAttributes();
@@ -1558,7 +1590,7 @@ extends ParentNode implements Document
                         // But for importNode defaults should be ignored.
                         if (attr.getSpecified() || cloningDoc) {
                             Attr newAttr = (Attr)importNode(attr, true, cloningDoc,
-                            reversedIdentifiers);
+                                    reversedIdentifiers);
 
                             // Attach attribute according to namespace
                             // support/qualification.
@@ -1567,17 +1599,18 @@ extends ParentNode implements Document
                                 newElement.setAttributeNode(newAttr);
                             else
                                 newElement.setAttributeNodeNS(newAttr);
+                            }
                         }
                     }
-                }
 
                 // Register element identifier.
                 if (reversedIdentifiers != null) {
                     // Does element have an associated identifier?
-                    Object elementId = reversedIdentifiers.get(source);
+                    String elementId = reversedIdentifiers.get(source);
                     if (elementId != null) {
-                        if (identifiers == null)
-                            identifiers = new Hashtable();
+                        if (identifiers == null) {
+                            identifiers = new HashMap<>();
+                        }
 
                         identifiers.put(elementId, newElement);
                     }
@@ -1594,7 +1627,7 @@ extends ParentNode implements Document
                         newnode = createAttribute(source.getNodeName());
                     } else {
                         newnode = createAttributeNS(source.getNamespaceURI(),
-                        source.getNodeName());
+                                source.getNodeName());
                     }
                 }
                 else {
@@ -1663,7 +1696,7 @@ extends ParentNode implements Document
 
             case PROCESSING_INSTRUCTION_NODE: {
                 newnode = createProcessingInstruction(source.getNodeName(),
-                source.getNodeValue());
+                        source.getNodeValue());
                 break;
             }
 
@@ -1682,15 +1715,15 @@ extends ParentNode implements Document
                 DocumentType srcdoctype = (DocumentType)source;
                 DocumentTypeImpl newdoctype = (DocumentTypeImpl)
                 createDocumentType(srcdoctype.getNodeName(),
-                srcdoctype.getPublicId(),
-                srcdoctype.getSystemId());
+                        srcdoctype.getPublicId(),
+                        srcdoctype.getSystemId());
                 // Values are on NamedNodeMaps
                 NamedNodeMap smap = srcdoctype.getEntities();
                 NamedNodeMap tmap = newdoctype.getEntities();
                 if(smap != null) {
                     for(int i = 0; i < smap.getLength(); i++) {
                         tmap.setNamedItem(importNode(smap.item(i), true, true,
-                        reversedIdentifiers));
+                                reversedIdentifiers));
                     }
                 }
                 smap = srcdoctype.getNotations();
@@ -1698,7 +1731,7 @@ extends ParentNode implements Document
                 if (smap != null) {
                     for(int i = 0; i < smap.getLength(); i++) {
                         tmap.setNamedItem(importNode(smap.item(i), true, true,
-                        reversedIdentifiers));
+                                reversedIdentifiers));
                     }
                 }
 
@@ -1741,10 +1774,10 @@ extends ParentNode implements Document
         // If deep, replicate and attach the kids.
         if (deep) {
             for (Node srckid = source.getFirstChild();
-            srckid != null;
-            srckid = srckid.getNextSibling()) {
+                    srckid != null;
+                    srckid = srckid.getNextSibling()) {
                 newnode.appendChild(importNode(srckid, true, cloningDoc,
-                reversedIdentifiers));
+                        reversedIdentifiers));
             }
         }
         if (newnode.getNodeType() == Node.ENTITY_NODE) {
@@ -1752,7 +1785,7 @@ extends ParentNode implements Document
         }
         return newnode;
 
-    } // importNode(Node,boolean,boolean,Hashtable):Node
+    } // importNode(Node,boolean,boolean,Map):Node
 
     /**
      * DOM Level 3 WD - Experimental
@@ -1763,7 +1796,7 @@ extends ParentNode implements Document
      **/
     public Node adoptNode(Node source) {
         NodeImpl node;
-                Hashtable userData = null;
+        Map<String, UserDataRecord> userData;
         try {
             node = (NodeImpl) source;
         } catch (ClassCastException e) {
@@ -1774,8 +1807,8 @@ extends ParentNode implements Document
         // Return null if the source is null
 
         if (source == null ) {
-                return null;
-        } else if (source != null && source.getOwnerDocument() != null) {
+            return null;
+        } else if (source.getOwnerDocument() != null) {
 
             DOMImplementation thisImpl = this.getImplementation();
             DOMImplementation otherImpl = source.getOwnerDocument().getImplementation();
@@ -1795,7 +1828,7 @@ extends ParentNode implements Document
                     // Adopting between two dissimilar DOM's is not allowed
                     return null;
                 }
-                }
+            }
         }
 
         switch (node.getNodeType()) {
@@ -1808,12 +1841,13 @@ extends ParentNode implements Document
                 }
                 //2. specified flag is set to true
                 attr.isSpecified(true);
-                                userData = node.getUserDataRecord();
+                userData = node.getUserDataRecord();
 
                 //3. change ownership
                 attr.setOwnerDocument(this);
-                                if(userData != null )
-                                        setUserDataTable(node,userData);
+                if (userData != null) {
+                    setUserDataTable(node, userData);
+                }
                 break;
             }
             //entity, notation nodes are read only nodes.. so they can't be adopted.
@@ -1832,7 +1866,7 @@ extends ParentNode implements Document
                 throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
             }
             case ENTITY_REFERENCE_NODE: {
-                                userData = node.getUserDataRecord();
+                userData = node.getUserDataRecord();
                 // remove node from wherever it is
                 Node parent = node.getParentNode();
                 if (parent != null) {
@@ -1845,8 +1879,9 @@ extends ParentNode implements Document
                 }
                 // change ownership
                 node.setOwnerDocument(this);
-                                if(userData != null)
-                                        setUserDataTable(node,userData);
+                if (userData != null) {
+                    setUserDataTable(node, userData);
+                }
                 // set its new replacement value if any
                 if (docType == null) {
                     break;
@@ -1857,14 +1892,14 @@ extends ParentNode implements Document
                     break;
                 }
                 for (child = entityNode.getFirstChild();
-                child != null; child = child.getNextSibling()) {
+                        child != null; child = child.getNextSibling()) {
                     Node childClone = child.cloneNode(true);
                     node.appendChild(childClone);
                 }
                 break;
             }
             case ELEMENT_NODE: {
-                                userData = node.getUserDataRecord();
+                userData = node.getUserDataRecord();
                 // remove node from wherever it is
                 Node parent = node.getParentNode();
                 if (parent != null) {
@@ -1872,14 +1907,15 @@ extends ParentNode implements Document
                 }
                 // change ownership
                 node.setOwnerDocument(this);
-                                if(userData != null)
-                                        setUserDataTable(node,userData);
+                if (userData != null) {
+                    setUserDataTable(node, userData);
+                }
                 // reconcile default attributes
                 ((ElementImpl)node).reconcileDefaultAttributes();
                 break;
             }
             default: {
-                                userData = node.getUserDataRecord();
+                userData = node.getUserDataRecord();
                 // remove node from wherever it is
                 Node parent = node.getParentNode();
                 if (parent != null) {
@@ -1887,15 +1923,17 @@ extends ParentNode implements Document
                 }
                 // change ownership
                 node.setOwnerDocument(this);
-                                if(userData != null)
-                                        setUserDataTable(node,userData);
+                if (userData != null) {
+                    setUserDataTable(node, userData);
+                }
             }
         }
 
                 //DOM L3 Core CR
-                //http://www.w3.org/TR/2003/CR-DOM-Level-3-Core-20031107/core.html#UserDataHandler-ADOPTED
-                if(userData != null)
-                        callUserDataHandlers(source, null, UserDataHandler.NODE_ADOPTED,userData);
+        //http://www.w3.org/TR/2003/CR-DOM-Level-3-Core-20031107/core.html#UserDataHandler-ADOPTED
+        if (userData != null) {
+            callUserDataHandlers(source, null, UserDataHandler.NODE_ADOPTED, userData);
+        }
 
         return node;
     }
@@ -1994,7 +2032,7 @@ extends ParentNode implements Document
         }
 
         if (identifiers == null) {
-            identifiers = new Hashtable();
+            identifiers = new HashMap<>();
         }
 
         identifiers.put(idName, element);
@@ -2052,25 +2090,9 @@ extends ParentNode implements Document
 
     } // removeIdentifier(String)
 
-    /** Returns an enumeration registered of identifier names. */
-    public Enumeration getIdentifiers() {
-
-        if (needsSyncData()) {
-            synchronizeData();
-        }
-
-        if (identifiers == null) {
-            identifiers = new Hashtable();
-        }
-
-        return identifiers.keys();
-
-    } // getIdentifiers():Enumeration
-
     //
     // DOM2: Namespace methods
     //
-
     /**
      * Introduced in DOM Level 2. <p>
      * Creates an element of the given qualified name and namespace URI.
@@ -2095,7 +2117,7 @@ extends ParentNode implements Document
      * @since WD-DOM-Level-2-19990923
      */
     public Element createElementNS(String namespaceURI, String qualifiedName)
-    throws DOMException {
+            throws DOMException {
         return new ElementNSImpl(this, namespaceURI, qualifiedName);
     }
 
@@ -2114,8 +2136,8 @@ extends ParentNode implements Document
      *                   name contains an invalid character.
      */
     public Element createElementNS(String namespaceURI, String qualifiedName,
-    String localpart)
-    throws DOMException {
+            String localpart)
+            throws DOMException {
         return new ElementNSImpl(this, namespaceURI, qualifiedName, localpart);
     }
 
@@ -2138,7 +2160,7 @@ extends ParentNode implements Document
      * @since WD-DOM-Level-2-19990923
      */
     public Attr createAttributeNS(String namespaceURI, String qualifiedName)
-    throws DOMException {
+            throws DOMException {
         return new AttrNSImpl(this, namespaceURI, qualifiedName);
     }
 
@@ -2158,8 +2180,8 @@ extends ParentNode implements Document
      * name contains an invalid character.
      */
     public Attr createAttributeNS(String namespaceURI, String qualifiedName,
-    String localpart)
-    throws DOMException {
+            String localpart)
+            throws DOMException {
         return new AttrNSImpl(this, namespaceURI, qualifiedName, localpart);
     }
 
@@ -2180,7 +2202,7 @@ extends ParentNode implements Document
      * @since WD-DOM-Level-2-19990923
      */
     public NodeList getElementsByTagNameNS(String namespaceURI,
-    String localName) {
+            String localName) {
         return new DeepNodeListImpl(this, namespaceURI, localName);
     }
 
@@ -2233,11 +2255,11 @@ extends ParentNode implements Document
 
         if (!xml11Version) {
             validNCName = (prefix == null || XMLChar.isValidNCName(prefix))
-                && XMLChar.isValidNCName(local);
+                    && XMLChar.isValidNCName(local);
         }
         else {
             validNCName = (prefix == null || XML11Char.isXML11ValidNCName(prefix))
-                && XML11Char.isXML11ValidNCName(local);
+                    && XML11Char.isXML11ValidNCName(local);
         }
 
         return validNCName;
@@ -2323,37 +2345,33 @@ extends ParentNode implements Document
      * REVISIT: we could use a free list of UserDataRecord here
      */
     public Object setUserData(Node n, String key,
-    Object data, UserDataHandler handler) {
+            Object data, UserDataHandler handler) {
         if (data == null) {
-            if (userData != null) {
-                Hashtable t = (Hashtable) userData.get(n);
+            if (nodeUserData != null) {
+                Map<String, UserDataRecord> t = nodeUserData.get(n);
                 if (t != null) {
-                    Object o = t.remove(key);
-                    if (o != null) {
-                        UserDataRecord r = (UserDataRecord) o;
+                    UserDataRecord r = t.remove(key);
+                    if (r != null) {
                         return r.fData;
                     }
                 }
             }
             return null;
-        }
-        else {
-            Hashtable t;
-            if (userData == null) {
-                userData = new Hashtable();
-                t = new Hashtable();
-                userData.put(n, t);
-            }
-            else {
-                t = (Hashtable) userData.get(n);
+        } else {
+            Map<String, UserDataRecord> t;
+            if (nodeUserData == null) {
+                nodeUserData = new HashMap<>();
+                t = new HashMap<>();
+                nodeUserData.put(n, t);
+            } else {
+                t = nodeUserData.get(n);
                 if (t == null) {
-                    t = new Hashtable();
-                    userData.put(n, t);
+                    t = new HashMap<>();
+                    nodeUserData.put(n, t);
                 }
             }
-            Object o = t.put(key, new UserDataRecord(data, handler));
-            if (o != null) {
-                UserDataRecord r = (UserDataRecord) o;
+            UserDataRecord r = t.put(key, new UserDataRecord(data, handler));
+            if (r != null) {
                 return r.fData;
             }
             return null;
@@ -2372,42 +2390,41 @@ extends ParentNode implements Document
      * @since DOM Level 3
      */
     public Object getUserData(Node n, String key) {
-        if (userData == null) {
+        if (nodeUserData == null) {
             return null;
         }
-        Hashtable t = (Hashtable) userData.get(n);
+        Map<String, UserDataRecord> t = nodeUserData.get(n);
         if (t == null) {
             return null;
         }
-        Object o = t.get(key);
-        if (o != null) {
-            UserDataRecord r = (UserDataRecord) o;
+        UserDataRecord r = t.get(key);
+        if (r != null) {
             return r.fData;
         }
         return null;
     }
 
-        protected Hashtable getUserDataRecord(Node n){
-        if (userData == null) {
+    protected Map<String, UserDataRecord> getUserDataRecord(Node n) {
+        if (nodeUserData == null) {
             return null;
         }
-        Hashtable t = (Hashtable) userData.get(n);
+        Map<String, UserDataRecord> t = nodeUserData.get(n);
         if (t == null) {
             return null;
         }
-                return t;
-        }
+        return t;
+    }
 
-        /**
+    /**
      * Remove user data table for the given node.
      * @param n The node this operation applies to.
      * @return The removed table.
      */
-    Hashtable removeUserDataTable(Node n) {
-        if (userData == null) {
+    Map<String, UserDataRecord> removeUserDataTable(Node n) {
+        if (nodeUserData == null) {
             return null;
         }
-        return (Hashtable) userData.get(n);
+        return nodeUserData.get(n);
     }
 
     /**
@@ -2415,11 +2432,13 @@ extends ParentNode implements Document
      * @param n The node this operation applies to.
      * @param data The user data table.
      */
-    void setUserDataTable(Node n, Hashtable data) {
-                if (userData == null)
-                        userData = new Hashtable();
+    void setUserDataTable(Node n, Map<String, UserDataRecord> data) {
+        if (nodeUserData == null) {
+            nodeUserData = new HashMap<>();
+        }
+
         if (data != null) {
-            userData.put(n, data);
+            nodeUserData.put(n, data);
         }
     }
 
@@ -2430,41 +2449,39 @@ extends ParentNode implements Document
      * @param operation The operation - import, clone, or delete.
      */
     void callUserDataHandlers(Node n, Node c, short operation) {
-        if (userData == null) {
+        if (nodeUserData == null) {
             return;
         }
-        //Hashtable t = (Hashtable) userData.get(n);
-                if(n instanceof NodeImpl){
-                        Hashtable t = ((NodeImpl)n).getUserDataRecord();
-                        if (t == null || t.isEmpty()) {
-                                return;
-                        }
-                        callUserDataHandlers(n, c, operation,t);
-                }
+
+        if (n instanceof NodeImpl) {
+            Map<String, UserDataRecord> t = ((NodeImpl) n).getUserDataRecord();
+            if (t == null || t.isEmpty()) {
+                return;
+            }
+            callUserDataHandlers(n, c, operation, t);
+        }
     }
 
-        /**
+    /**
      * Call user data handlers when a node is deleted (finalized)
      * @param n The node this operation applies to.
      * @param c The copy node or null.
      * @param operation The operation - import, clone, or delete.
-         * @param handlers Data associated with n.
-        */
-        void callUserDataHandlers(Node n, Node c, short operation,Hashtable userData) {
+     * @param handlers Data associated with n.
+     */
+    void callUserDataHandlers(Node n, Node c, short operation, Map<String, UserDataRecord> userData) {
         if (userData == null || userData.isEmpty()) {
             return;
         }
-        Enumeration keys = userData.keys();
-        while (keys.hasMoreElements()) {
-            String key = (String) keys.nextElement();
-            UserDataRecord r = (UserDataRecord) userData.get(key);
+        for (String key : userData.keySet()) {
+            UserDataRecord r = userData.get(key);
             if (r.fHandler != null) {
                 r.fHandler.handle(operation, key, r.fData, n, c);
             }
         }
     }
 
-        /**
+    /**
      * Call user data handlers to let them know the nodes they are related to
      * are being deleted. The alternative would be to do that on Node but
      * because the nodes are used as the keys we have a reference to them that
@@ -2479,29 +2496,29 @@ extends ParentNode implements Document
     // 2. It affects the performance greatly in multi-thread environment.
     // -SG
     /*public void finalize() {
-        if (userData == null) {
-            return;
-        }
-        Enumeration nodes = userData.keys();
-        while (nodes.hasMoreElements()) {
-            Object node = nodes.nextElement();
-            Hashtable t = (Hashtable) userData.get(node);
-            if (t != null && !t.isEmpty()) {
-                Enumeration keys = t.keys();
-                while (keys.hasMoreElements()) {
-                    String key = (String) keys.nextElement();
-                    UserDataRecord r = (UserDataRecord) t.get(key);
-                    if (r.fHandler != null) {
-                        r.fHandler.handle(UserDataHandler.NODE_DELETED,
-                                          key, r.fData, null, null);
-                    }
-                }
-            }
-        }
-    }*/
+     if (userData == null) {
+     return;
+     }
+     Enumeration nodes = userData.keys();
+     while (nodes.hasMoreElements()) {
+     Object node = nodes.nextElement();
+     Hashtable t = (Hashtable) userData.get(node);
+     if (t != null && !t.isEmpty()) {
+     Enumeration keys = t.keys();
+     while (keys.hasMoreElements()) {
+     String key = (String) keys.nextElement();
+     UserDataRecord r = (UserDataRecord) t.get(key);
+     if (r.fHandler != null) {
+     r.fHandler.handle(UserDataHandler.NODE_DELETED,
+     key, r.fData, null, null);
+     }
+     }
+     }
+     }
+     }*/
 
     protected final void checkNamespaceWF( String qname, int colon1,
-    int colon2) {
+            int colon2) {
 
         if (!errorChecking) {
             return;
@@ -2512,42 +2529,42 @@ extends ParentNode implements Document
         if (colon1 == 0 || colon1 == qname.length() - 1 || colon2 != colon1) {
             String msg =
             DOMMessageFormatter.formatMessage(
-            DOMMessageFormatter.DOM_DOMAIN,
-            "NAMESPACE_ERR",
-            null);
+                            DOMMessageFormatter.DOM_DOMAIN,
+                            "NAMESPACE_ERR",
+                            null);
             throw new DOMException(DOMException.NAMESPACE_ERR, msg);
         }
     }
     protected final void checkDOMNSErr(String prefix,
-    String namespace) {
+            String namespace) {
         if (errorChecking) {
             if (namespace == null) {
                 String msg =
                 DOMMessageFormatter.formatMessage(
-                DOMMessageFormatter.DOM_DOMAIN,
-                "NAMESPACE_ERR",
-                null);
+                                DOMMessageFormatter.DOM_DOMAIN,
+                                "NAMESPACE_ERR",
+                                null);
                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
             }
             else if (prefix.equals("xml")
-            && !namespace.equals(NamespaceContext.XML_URI)) {
+                    && !namespace.equals(NamespaceContext.XML_URI)) {
                 String msg =
                 DOMMessageFormatter.formatMessage(
-                DOMMessageFormatter.DOM_DOMAIN,
-                "NAMESPACE_ERR",
-                null);
+                                DOMMessageFormatter.DOM_DOMAIN,
+                                "NAMESPACE_ERR",
+                                null);
                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
             }
             else if (
             prefix.equals("xmlns")
-            && !namespace.equals(NamespaceContext.XMLNS_URI)
-            || (!prefix.equals("xmlns")
-            && namespace.equals(NamespaceContext.XMLNS_URI))) {
+                    && !namespace.equals(NamespaceContext.XMLNS_URI)
+                    || (!prefix.equals("xmlns")
+                    && namespace.equals(NamespaceContext.XMLNS_URI))) {
                 String msg =
                 DOMMessageFormatter.formatMessage(
-                DOMMessageFormatter.DOM_DOMAIN,
-                "NAMESPACE_ERR",
-                null);
+                                DOMMessageFormatter.DOM_DOMAIN,
+                                "NAMESPACE_ERR",
+                                null);
                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
             }
         }
@@ -2565,24 +2582,24 @@ extends ParentNode implements Document
             return;
         }
 
-                // check that both prefix and local part match NCName
+        // check that both prefix and local part match NCName
         boolean validNCName = false;
         if (!xml11Version) {
             validNCName = (prefix == null || XMLChar.isValidNCName(prefix))
-                && XMLChar.isValidNCName(local);
+                    && XMLChar.isValidNCName(local);
         }
         else {
             validNCName = (prefix == null || XML11Char.isXML11ValidNCName(prefix))
-                && XML11Char.isXML11ValidNCName(local);
+                    && XML11Char.isXML11ValidNCName(local);
         }
 
         if (!validNCName) {
             // REVISIT: add qname parameter to the message
             String msg =
             DOMMessageFormatter.formatMessage(
-            DOMMessageFormatter.DOM_DOMAIN,
-            "INVALID_CHARACTER_ERR",
-            null);
+                            DOMMessageFormatter.DOM_DOMAIN,
+                            "INVALID_CHARACTER_ERR",
+                            null);
             throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
         }
     }
@@ -2629,14 +2646,14 @@ extends ParentNode implements Document
     // Event related methods overidden in subclass
 
     protected void addEventListener(NodeImpl node, String type,
-    EventListener listener,
-    boolean useCapture) {
+            EventListener listener,
+            boolean useCapture) {
         // does nothing by default - overidden in subclass
     }
 
     protected void removeEventListener(NodeImpl node, String type,
-    EventListener listener,
-    boolean useCapture) {
+            EventListener listener,
+            boolean useCapture) {
         // does nothing by default - overidden in subclass
     }
 
@@ -2763,4 +2780,91 @@ extends ParentNode implements Document
     void renamedElement(Element oldEl, Element newEl) {
     }
 
+    /**
+     * @serialData Serialized fields. Convert Maps to Hashtables for backward
+     * compatibility.
+     */
+    private void writeObject(ObjectOutputStream out) throws IOException {
+        // Convert Maps to Hashtables
+        Hashtable<Node, Hashtable<String, UserDataRecord>> nud = null;
+        if (nodeUserData != null) {
+            nud = new Hashtable<>();
+            for (Map.Entry<Node, Map<String, UserDataRecord>> e : nodeUserData.entrySet()) {
+                //e.getValue() will not be null since an entry is always put with a non-null value
+                nud.put(e.getKey(), new Hashtable<>(e.getValue()));
+            }
+        }
+
+        Hashtable<String, Node> ids = (identifiers == null)? null : new Hashtable<>(identifiers);
+        Hashtable<Node, Integer> nt = (nodeTable == null)? null : new Hashtable<>(nodeTable);
+
+        // Write serialized fields
+        ObjectOutputStream.PutField pf = out.putFields();
+        pf.put("docType", docType);
+        pf.put("docElement", docElement);
+        pf.put("fFreeNLCache", fFreeNLCache);
+        pf.put("encoding", encoding);
+        pf.put("actualEncoding", actualEncoding);
+        pf.put("version", version);
+        pf.put("standalone", standalone);
+        pf.put("fDocumentURI", fDocumentURI);
+
+        //userData is the original name. It has been changed to nodeUserData, refer to the corrsponding @serialField
+        pf.put("userData", nud);
+        pf.put("identifiers", ids);
+        pf.put("changes", changes);
+        pf.put("allowGrammarAccess", allowGrammarAccess);
+        pf.put("errorChecking", errorChecking);
+        pf.put("ancestorChecking", ancestorChecking);
+        pf.put("xmlVersionChanged", xmlVersionChanged);
+        pf.put("documentNumber", documentNumber);
+        pf.put("nodeCounter", nodeCounter);
+        pf.put("nodeTable", nt);
+        pf.put("xml11Version", xml11Version);
+        out.writeFields();
+    }
+
+    @SuppressWarnings("unchecked")
+    private void readObject(ObjectInputStream in)
+                        throws IOException, ClassNotFoundException {
+        // We have to read serialized fields first.
+        ObjectInputStream.GetField gf = in.readFields();
+        docType = (DocumentTypeImpl)gf.get("docType", null);
+        docElement = (ElementImpl)gf.get("docElement", null);
+        fFreeNLCache = (NodeListCache)gf.get("fFreeNLCache", null);
+        encoding = (String)gf.get("encoding", null);
+        actualEncoding = (String)gf.get("actualEncoding", null);
+        version = (String)gf.get("version", null);
+        standalone = gf.get("standalone", false);
+        fDocumentURI = (String)gf.get("fDocumentURI", null);
+
+        //userData is the original name. It has been changed to nodeUserData, refer to the corrsponding @serialField
+        Hashtable<Node, Hashtable<String, UserDataRecord>> nud =
+                (Hashtable<Node, Hashtable<String, UserDataRecord>>)gf.get("userData", null);
+
+        Hashtable<String, Node> ids = (Hashtable<String, Node>)gf.get("identifiers", null);
+
+        changes = gf.get("changes", 0);
+        allowGrammarAccess = gf.get("allowGrammarAccess", false);
+        errorChecking = gf.get("errorChecking", true);
+        ancestorChecking = gf.get("ancestorChecking", true);
+        xmlVersionChanged = gf.get("xmlVersionChanged", false);
+        documentNumber = gf.get("documentNumber", 0);
+        nodeCounter = gf.get("nodeCounter", 0);
+
+        Hashtable<Node, Integer> nt = (Hashtable<Node, Integer>)gf.get("nodeTable", null);
+
+        xml11Version = gf.get("xml11Version", false);
+
+        //convert Hashtables back to HashMaps
+        if (nud != null) {
+            nodeUserData = new HashMap<>();
+            for (Map.Entry<Node, Hashtable<String, UserDataRecord>> e : nud.entrySet()) {
+                nodeUserData.put(e.getKey(), new HashMap<>(e.getValue()));
+            }
+        }
+
+        if (ids != null) identifiers = new HashMap<>(ids);
+        if (nt != null) nodeTable = new HashMap<>(nt);
+    }
 } // class CoreDocumentImpl
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DeferredDocumentImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DeferredDocumentImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DeferredDocumentImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -21,7 +21,7 @@
 package com.sun.org.apache.xerces.internal.dom;
 
 import java.util.ArrayList;
-
+import java.util.HashMap;
 import org.w3c.dom.DOMImplementation;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
@@ -2057,9 +2057,9 @@ public class DeferredDocumentImpl
                                element+')');
         }
 
-        // create hashtable
+        // create Map
         if (identifiers == null) {
-            identifiers = new java.util.Hashtable();
+            identifiers = new HashMap<>();
         }
 
         // save ID and its associated element
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001,2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,13 +20,19 @@
 
 package com.sun.org.apache.xerces.internal.dom;
 
+import com.sun.org.apache.xerces.internal.dom.events.EventImpl;
+import com.sun.org.apache.xerces.internal.dom.events.MutationEventImpl;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.Hashtable;
+import java.util.List;
+import java.util.Map;
 import java.util.Vector;
-
-import com.sun.org.apache.xerces.internal.dom.events.EventImpl;
-import com.sun.org.apache.xerces.internal.dom.events.MutationEventImpl;
-import org.w3c.dom.UserDataHandler;
 import org.w3c.dom.Attr;
 import org.w3c.dom.DOMException;
 import org.w3c.dom.DOMImplementation;
@@ -34,6 +40,7 @@ import org.w3c.dom.DocumentType;
 import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
+import org.w3c.dom.UserDataHandler;
 import org.w3c.dom.events.DocumentEvent;
 import org.w3c.dom.events.Event;
 import org.w3c.dom.events.EventException;
@@ -96,18 +103,33 @@ public class DocumentImpl
 
     /** Iterators */
     // REVISIT: Should this be transient? -Ac
-    protected Vector iterators;
+    protected List<NodeIterator> iterators;
 
      /** Ranges */
     // REVISIT: Should this be transient? -Ac
-    protected Vector ranges;
+    protected List<Range> ranges;
 
     /** Table for event listeners registered to this document nodes. */
-    protected Hashtable eventListeners;
+    protected Map<NodeImpl, List<LEntry>> eventListeners;
 
     /** Bypass mutation events firing. */
     protected boolean mutationEvents = false;
 
+
+    /**
+     * @serialField iterators Vector Node iterators
+     * @serialField ranges Vector ranges
+     * @serialField eventListeners Hashtable Event listeners
+     * @serialField mutationEvents boolean Bypass mutation events firing
+     */
+    private static final ObjectStreamField[] serialPersistentFields =
+        new ObjectStreamField[] {
+            new ObjectStreamField("iterators", Vector.class),
+            new ObjectStreamField("ranges", Vector.class),
+            new ObjectStreamField("eventListeners", Hashtable.class),
+            new ObjectStreamField("mutationEvents", boolean.class),
+        };
+
     //
     // Constructors
     //
@@ -227,10 +249,10 @@ public class DocumentImpl
                                                      filter,
                                                      entityReferenceExpansion);
         if (iterators == null) {
-            iterators = new Vector();
+            iterators = new ArrayList<>();
         }
 
-        iterators.addElement(iterator);
+        iterators.add(iterator);
 
         return iterator;
     }
@@ -287,7 +309,7 @@ public class DocumentImpl
         if (nodeIterator == null) return;
         if (iterators == null) return;
 
-        iterators.removeElement(nodeIterator);
+        iterators.remove(nodeIterator);
     }
 
     //
@@ -298,12 +320,11 @@ public class DocumentImpl
     public Range createRange() {
 
         if (ranges == null) {
-            ranges = new Vector();
+            ranges = new ArrayList<>();
         }
 
         Range range = new RangeImpl(this);
-
-        ranges.addElement(range);
+        ranges.add(range);
 
         return range;
 
@@ -318,7 +339,7 @@ public class DocumentImpl
         if (range == null) return;
         if (ranges == null) return;
 
-        ranges.removeElement(range);
+        ranges.remove(range);
     }
 
     /**
@@ -330,7 +351,7 @@ public class DocumentImpl
         if (ranges != null) {
             int size = ranges.size();
             for (int i = 0; i != size; i++) {
-                ((RangeImpl)ranges.elementAt(i)).receiveReplacedText(node);
+                ((RangeImpl)ranges.get(i)).receiveReplacedText(node);
             }
         }
     }
@@ -344,7 +365,7 @@ public class DocumentImpl
         if (ranges != null) {
             int size = ranges.size();
             for (int i = 0; i != size; i++) {
-                ((RangeImpl)ranges.elementAt(i)).receiveDeletedText(node,
+                ((RangeImpl)ranges.get(i)).receiveDeletedText(node,
                                                                 offset, count);
             }
         }
@@ -359,7 +380,7 @@ public class DocumentImpl
         if (ranges != null) {
             int size = ranges.size();
             for (int i = 0; i != size; i++) {
-                ((RangeImpl)ranges.elementAt(i)).receiveInsertedText(node,
+                ((RangeImpl)ranges.get(i)).receiveInsertedText(node,
                                                                 offset, count);
             }
         }
@@ -374,7 +395,7 @@ public class DocumentImpl
         if (ranges != null) {
             int size = ranges.size();
             for (int i = 0; i != size; i++) {
-                ((RangeImpl)ranges.elementAt(i)).receiveSplitData(node,
+                ((RangeImpl)ranges.get(i)).receiveSplitData(node,
                                                               newNode, offset);
             }
         }
@@ -437,9 +458,9 @@ public class DocumentImpl
      * node here won't be GC'ed as long as some listener is registered on it,
      * since the eventsListeners table will have a reference to the node.
      */
-    protected void setEventListeners(NodeImpl n, Vector listeners) {
+    private void setEventListeners(NodeImpl n, List<LEntry> listeners) {
         if (eventListeners == null) {
-            eventListeners = new Hashtable();
+            eventListeners = new HashMap<>();
         }
         if (listeners == null) {
             eventListeners.remove(n);
@@ -457,11 +478,11 @@ public class DocumentImpl
     /**
      * Retreive event listener registered on a given node
      */
-    protected Vector getEventListeners(NodeImpl n) {
+    private List<LEntry> getEventListeners(NodeImpl n) {
         if (eventListeners == null) {
             return null;
         }
-        return (Vector) eventListeners.get(n);
+        return eventListeners.get(n);
     }
 
     //
@@ -515,6 +536,7 @@ public class DocumentImpl
      * @param useCapture True iff listener is registered on
      *  capturing phase rather than at-target or bubbling
      */
+    @Override
     protected void addEventListener(NodeImpl node, String type,
                                     EventListener listener, boolean useCapture)
     {
@@ -527,12 +549,12 @@ public class DocumentImpl
         // Simplest way to code that is to zap the previous entry, if any.
         removeEventListener(node, type, listener, useCapture);
 
-        Vector nodeListeners = getEventListeners(node);
+        List<LEntry> nodeListeners = getEventListeners(node);
         if(nodeListeners == null) {
-            nodeListeners = new Vector();
+            nodeListeners = new ArrayList<>();
             setEventListeners(node, nodeListeners);
         }
-        nodeListeners.addElement(new LEntry(type, listener, useCapture));
+        nodeListeners.add(new LEntry(type, listener, useCapture));
 
         // Record active listener
         LCount lc = LCount.lookup(type);
@@ -558,6 +580,7 @@ public class DocumentImpl
      * @param useCapture True iff listener is registered on
      *  capturing phase rather than at-target or bubbling
      */
+    @Override
     protected void removeEventListener(NodeImpl node, String type,
                                        EventListener listener,
                                        boolean useCapture)
@@ -565,7 +588,7 @@ public class DocumentImpl
         // If this couldn't be a valid listener registration, ignore request
         if (type == null || type.equals("") || listener == null)
             return;
-        Vector nodeListeners = getEventListeners(node);
+        List<LEntry> nodeListeners = getEventListeners(node);
         if (nodeListeners == null)
             return;
 
@@ -573,12 +596,12 @@ public class DocumentImpl
         // each listener may be registered only once per type per phase.
         // count-down is OK for deletions!
         for (int i = nodeListeners.size() - 1; i >= 0; --i) {
-            LEntry le = (LEntry) nodeListeners.elementAt(i);
+            LEntry le = nodeListeners.get(i);
             if (le.useCapture == useCapture && le.listener == listener &&
                 le.type.equals(type)) {
-                nodeListeners.removeElementAt(i);
+                nodeListeners.remove(i);
                 // Storage management: Discard empty listener lists
-                if (nodeListeners.size() == 0)
+                if (nodeListeners.isEmpty())
                     setEventListeners(node, null);
 
                 // Remove active listener
@@ -597,12 +620,13 @@ public class DocumentImpl
         }
     } // removeEventListener(NodeImpl,String,EventListener,boolean) :void
 
+    @Override
     protected void copyEventListeners(NodeImpl src, NodeImpl tgt) {
-        Vector nodeListeners = getEventListeners(src);
+        List<LEntry> nodeListeners = getEventListeners(src);
         if (nodeListeners == null) {
             return;
         }
-        setEventListeners(tgt, (Vector) nodeListeners.clone());
+        setEventListeners(tgt, new ArrayList<>(nodeListeners));
     }
 
     /**
@@ -655,6 +679,7 @@ public class DocumentImpl
      * @return true if the event's <code>preventDefault()</code>
      *              method was invoked by an EventListener; otherwise false.
     */
+    @Override
     protected boolean dispatchEvent(NodeImpl node, Event event) {
         if (event == null) return false;
 
@@ -691,11 +716,11 @@ public class DocumentImpl
         // is issued to the Element rather than the Attr
         // and causes a _second_ DOMSubtreeModified in the Element's
         // tree.
-        Vector pv = new Vector(10,10);
+        List<Node> pv = new ArrayList<>(10);
         Node p = node;
         Node n = p.getParentNode();
         while (n != null) {
-            pv.addElement(n);
+            pv.add(n);
             p = n;
             n = n.getParentNode();
         }
@@ -710,15 +735,15 @@ public class DocumentImpl
                     break;  // Someone set the flag. Phase ends.
 
                 // Handle all capturing listeners on this node
-                NodeImpl nn = (NodeImpl) pv.elementAt(j);
+                NodeImpl nn = (NodeImpl) pv.get(j);
                 evt.currentTarget = nn;
-                Vector nodeListeners = getEventListeners(nn);
+                List<LEntry> nodeListeners = getEventListeners(nn);
                 if (nodeListeners != null) {
-                    Vector nl = (Vector) nodeListeners.clone();
+                    List<LEntry> nl = (List)((ArrayList)nodeListeners).clone();
                     // call listeners in the order in which they got registered
                     int nlsize = nl.size();
                     for (int i = 0; i < nlsize; i++) {
-                        LEntry le = (LEntry) nl.elementAt(i);
+                        LEntry le = nl.get(i);
                         if (le.useCapture && le.type.equals(evt.type) &&
                             nodeListeners.contains(le)) {
                             try {
@@ -741,13 +766,13 @@ public class DocumentImpl
             // node are _not_ invoked, even during the capture phase.
             evt.eventPhase = Event.AT_TARGET;
             evt.currentTarget = node;
-            Vector nodeListeners = getEventListeners(node);
+            List<LEntry> nodeListeners = getEventListeners(node);
             if (!evt.stopPropagation && nodeListeners != null) {
-                Vector nl = (Vector) nodeListeners.clone();
+                List<LEntry> nl = (List)((ArrayList)nodeListeners).clone();
                 // call listeners in the order in which they got registered
                 int nlsize = nl.size();
                 for (int i = 0; i < nlsize; i++) {
-                    LEntry le = (LEntry) nl.elementAt(i);
+                    LEntry le = (LEntry) nl.get(i);
                     if (!le.useCapture && le.type.equals(evt.type) &&
                         nodeListeners.contains(le)) {
                         try {
@@ -772,16 +797,16 @@ public class DocumentImpl
                         break;  // Someone set the flag. Phase ends.
 
                     // Handle all bubbling listeners on this node
-                    NodeImpl nn = (NodeImpl) pv.elementAt(j);
+                    NodeImpl nn = (NodeImpl) pv.get(j);
                     evt.currentTarget = nn;
                     nodeListeners = getEventListeners(nn);
                     if (nodeListeners != null) {
-                        Vector nl = (Vector) nodeListeners.clone();
+                        List<LEntry> nl = (List)((ArrayList)nodeListeners).clone();
                         // call listeners in the order in which they got
                         // registered
                         int nlsize = nl.size();
                         for (int i = 0; i < nlsize; i++) {
-                            LEntry le = (LEntry) nl.elementAt(i);
+                            LEntry le = nl.get(i);
                             if (!le.useCapture && le.type.equals(evt.type) &&
                                 nodeListeners.contains(le)) {
                                 try {
@@ -1118,7 +1143,7 @@ public class DocumentImpl
         if (ranges != null) {
             int size = ranges.size();
             for (int i = 0; i != size; i++) {
-                ((RangeImpl)ranges.elementAt(i)).insertedNodeFromDOM(newInternal);
+                ((RangeImpl)ranges.get(i)).insertedNodeFromDOM(newInternal);
             }
         }
     }
@@ -1132,7 +1157,7 @@ public class DocumentImpl
         if (iterators != null) {
             int size = iterators.size();
             for (int i = 0; i != size; i++) {
-               ((NodeIteratorImpl)iterators.elementAt(i)).removeNode(oldChild);
+               ((NodeIteratorImpl)iterators.get(i)).removeNode(oldChild);
             }
         }
 
@@ -1140,7 +1165,7 @@ public class DocumentImpl
         if (ranges != null) {
             int size = ranges.size();
             for (int i = 0; i != size; i++) {
-                ((RangeImpl)ranges.elementAt(i)).removeNode(oldChild);
+                ((RangeImpl)ranges.get(i)).removeNode(oldChild);
             }
         }
 
@@ -1302,4 +1327,53 @@ public class DocumentImpl
         // REVISIT: To be implemented!!!
     }
 
+
+    /**
+     * @serialData Serialized fields. Convert Maps to Hashtables and Lists
+     * to Vectors for backward compatibility.
+     */
+    private void writeObject(ObjectOutputStream out) throws IOException {
+        // Convert Maps to Hashtables, Lists to Vectors
+        Vector<NodeIterator> it = (iterators == null)? null : new Vector<>(iterators);
+        Vector<Range> r = (ranges == null)? null : new Vector<>(ranges);
+
+        Hashtable<NodeImpl, Vector<LEntry>> el = null;
+        if (eventListeners != null) {
+            el = new Hashtable<>();
+            for (Map.Entry<NodeImpl, List<LEntry>> e : eventListeners.entrySet()) {
+                 el.put(e.getKey(), new Vector<>(e.getValue()));
+            }
+        }
+
+        // Write serialized fields
+        ObjectOutputStream.PutField pf = out.putFields();
+        pf.put("iterators", it);
+        pf.put("ranges", r);
+        pf.put("eventListeners", el);
+        pf.put("mutationEvents", mutationEvents);
+        out.writeFields();
+    }
+
+    @SuppressWarnings("unchecked")
+    private void readObject(ObjectInputStream in)
+                        throws IOException, ClassNotFoundException {
+        // We have to read serialized fields first.
+        ObjectInputStream.GetField gf = in.readFields();
+        Vector<NodeIterator> it = (Vector<NodeIterator>)gf.get("iterators", null);
+        Vector<Range> r = (Vector<Range>)gf.get("ranges", null);
+        Hashtable<NodeImpl, Vector<LEntry>> el =
+                (Hashtable<NodeImpl, Vector<LEntry>>)gf.get("eventListeners", null);
+
+        mutationEvents = gf.get("mutationEvents", false);
+
+        //convert Hashtables back to HashMaps and Vectors to Lists
+        if (it != null) iterators = new ArrayList<>(it);
+        if (r != null) ranges = new ArrayList<>(r);
+        if (el != null) {
+            eventListeners = new HashMap<>();
+            for (Map.Entry<NodeImpl, Vector<LEntry>> e : el.entrySet()) {
+                 eventListeners.put(e.getKey(), new ArrayList<>(e.getValue()));
+            }
+        }
+    }
 } // class DocumentImpl
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentTypeImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentTypeImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/DocumentTypeImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,11 +20,17 @@
 
 package com.sun.org.apache.xerces.internal.dom;
 
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Map;
 import org.w3c.dom.DOMException;
 import org.w3c.dom.DocumentType;
-import org.w3c.dom.Node;
 import org.w3c.dom.NamedNodeMap;
-import java.util.Hashtable;
+import org.w3c.dom.Node;
 import org.w3c.dom.UserDataHandler;
 
 /**
@@ -95,10 +101,37 @@ public class DocumentTypeImpl
     // a number, on demand, for ordering purposes for compareDocumentPosition
     private int doctypeNumber=0;
 
+    private Map<String, UserDataRecord> userData =  null;
+
+
+    /**
+     * @serialField name String document type name
+     * @serialField entities NamedNodeMapImpl entities
+     * @serialField notations NamedNodeMapImpl notations
+     * @serialField elements NamedNodeMapImpl elements
+     * @serialField publicID String support public ID
+     * @serialField systemID String support system ID
+     * @serialField internalSubset String support internal subset
+     * @serialField doctypeNumber int Doctype number
+     * @serialField userData Hashtable user data
+     */
+    private static final ObjectStreamField[] serialPersistentFields =
+        new ObjectStreamField[] {
+            new ObjectStreamField("name", String.class),
+            new ObjectStreamField("entities", NamedNodeMapImpl.class),
+            new ObjectStreamField("notations", NamedNodeMapImpl.class),
+            new ObjectStreamField("elements", NamedNodeMapImpl.class),
+            new ObjectStreamField("publicID", String.class),
+            new ObjectStreamField("systemID", String.class),
+            new ObjectStreamField("internalSubset", String.class),
+            new ObjectStreamField("doctypeNumber", int.class),
+            new ObjectStreamField("userData", Hashtable.class),
+        };
+
     //
     // Constructors
     //
-    private Hashtable userData =  null;
+
     /** Factory method for creating a document type node. */
     public DocumentTypeImpl(CoreDocumentImpl ownerDocument, String name) {
         super(ownerDocument);
@@ -445,22 +478,20 @@ public class DocumentTypeImpl
     public Object setUserData(String key,
     Object data, UserDataHandler handler) {
         if(userData == null)
-            userData = new Hashtable();
+            userData = new HashMap<>();
         if (data == null) {
             if (userData != null) {
-                Object o = userData.remove(key);
-                if (o != null) {
-                    UserDataRecord r = (UserDataRecord) o;
-                    return r.fData;
+                UserDataRecord udr = userData.remove(key);
+                if (udr != null) {
+                    return udr.fData;
                 }
             }
             return null;
         }
         else {
-            Object o = userData.put(key, new UserDataRecord(data, handler));
-            if (o != null) {
-                UserDataRecord r = (UserDataRecord) o;
-                return r.fData;
+            UserDataRecord udr = userData.put(key, new UserDataRecord(data, handler));
+            if (udr != null) {
+                return udr.fData;
             }
         }
         return null;
@@ -470,16 +501,58 @@ public class DocumentTypeImpl
         if (userData == null) {
             return null;
         }
-        Object o = userData.get(key);
-        if (o != null) {
-            UserDataRecord r = (UserDataRecord) o;
-            return r.fData;
+        UserDataRecord udr = userData.get(key);
+        if (udr != null) {
+            return udr.fData;
         }
         return null;
     }
 
-    protected Hashtable getUserDataRecord(){
+    @Override
+    protected Map<String, UserDataRecord> getUserDataRecord(){
         return userData;
     }
 
+    /**
+     * @serialData Serialized fields. Convert Map to Hashtable for backward
+     * compatibility.
+     */
+    private void writeObject(ObjectOutputStream out) throws IOException {
+        // Convert the HashMap to Hashtable
+        Hashtable<String, UserDataRecord> ud = (userData == null)? null : new Hashtable<>(userData);
+
+        // Write serialized fields
+        ObjectOutputStream.PutField pf = out.putFields();
+        pf.put("name", name);
+        pf.put("entities", entities);
+        pf.put("notations", notations);
+        pf.put("elements", elements);
+        pf.put("publicID", publicID);
+        pf.put("systemID", systemID);
+        pf.put("internalSubset", internalSubset);
+        pf.put("doctypeNumber", doctypeNumber);
+        pf.put("userData", ud);
+        out.writeFields();
+    }
+
+    @SuppressWarnings("unchecked")
+    private void readObject(ObjectInputStream in)
+                        throws IOException, ClassNotFoundException {
+        // We have to read serialized fields first.
+        ObjectInputStream.GetField gf = in.readFields();
+        name = (String)gf.get("name", null);
+        entities = (NamedNodeMapImpl)gf.get("entities", null);
+        notations = (NamedNodeMapImpl)gf.get("notations", null);
+        elements = (NamedNodeMapImpl)gf.get("elements", null);
+        publicID = (String)gf.get("publicID", null);
+        systemID = (String)gf.get("systemID", null);
+        internalSubset = (String)gf.get("internalSubset", null);
+        doctypeNumber = gf.get("doctypeNumber", 0);
+
+        Hashtable<String, UserDataRecord> ud =
+                (Hashtable<String, UserDataRecord>)gf.get("userData", null);
+
+        //convert the Hashtable back to HashMap
+        if (ud != null) userData = new HashMap<>(ud);
+    }
 } // class DocumentTypeImpl
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/LCount.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/LCount.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/LCount.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,20 +22,13 @@ package com.sun.org.apache.xerces.intern
 
 /** Internal class LCount is used to track the number of
     listeners registered for a given event name, as an entry
-    in a global hashtable. This should allow us to avoid generating,
-    or discard, events for which no listeners are registered.
+    in a global Map. This should allow us to avoid generating,
+    or discarding, events for which no listeners are registered.
 
     ***** There should undoubtedly be methods here to manipulate
     this table. At the moment that code's residing in NodeImpl.
     Move it when we have a chance to do so. Sorry; we were
     rushed.
-
-    ???? CONCERN: Hashtables are known to be "overserialized" in
-    current versions of Java. That may impact performance.
-
-    ???? CONCERN: The hashtable should probably be a per-document object.
-    Finer granularity would be even better, but would cost more cycles to
-    resolve and might not save enough event traffic to be worth the investment.
 */
 /**
  * @xerces.internal
@@ -44,7 +37,7 @@ package com.sun.org.apache.xerces.intern
 
 class LCount
 {
-    static java.util.Hashtable lCounts=new java.util.Hashtable();
+    static final java.util.Map<String, LCount> lCounts=new java.util.concurrent.ConcurrentHashMap<>();
     public int captures=0,bubbles=0,defaults, total=0;
 
     static LCount lookup(String evtName)
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/NodeImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/NodeImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/NodeImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
  /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,15 +23,14 @@ package com.sun.org.apache.xerces.intern
 import java.io.IOException;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
-import java.util.Hashtable;
-
-import org.w3c.dom.UserDataHandler;
+import java.util.Map;
 import org.w3c.dom.DOMException;
 import org.w3c.dom.Document;
 import org.w3c.dom.DocumentType;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
+import org.w3c.dom.UserDataHandler;
 import org.w3c.dom.events.Event;
 import org.w3c.dom.events.EventListener;
 import org.w3c.dom.events.EventTarget;
@@ -1793,7 +1792,7 @@ public abstract class NodeImpl
         return ownerDocument().getUserData(this, key);
     }
 
-        protected Hashtable getUserDataRecord(){
+    protected Map<String, ParentNode.UserDataRecord> getUserDataRecord(){
         return ownerDocument().getUserDataRecord(this);
         }
 
@@ -1845,7 +1844,7 @@ public abstract class NodeImpl
      * NON-DOM: As an alternative to subclassing the DOM, this implementation
      * has been extended with the ability to attach an object to each node.
      * (If you need multiple objects, you can attach a collection such as a
-     * vector or hashtable, then attach your application information to that.)
+     * List or Map, then attach your application information to that.)
      * <p><b>Important Note:</b> You are responsible for removing references
      * to your data on nodes that are no longer used. Failure to do so will
      * prevent the nodes, your data is attached to, to be garbage collected
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/ParentNode.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/ParentNode.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/dom/ParentNode.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,10 +20,10 @@
 
 package com.sun.org.apache.xerces.internal.dom;
 
-import java.io.Serializable;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
+import java.io.Serializable;
 
 import org.w3c.dom.DOMException;
 import org.w3c.dom.Document;
@@ -1023,7 +1023,7 @@ public abstract class ParentNode
     /*
      * a class to store some user data along with its handler
      */
-    class UserDataRecord implements Serializable {
+    protected class UserDataRecord implements Serializable {
         /** Serialization version. */
         private static final long serialVersionUID = 3258126977134310455L;
 
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java
@@ -1,15 +1,15 @@
 /*
- * Copyright (c) 2003, 2006, 2013 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
  */
-
 /*
- * Copyright 2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -44,12 +44,11 @@ import java.net.HttpURLConnection;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
-import java.util.Hashtable;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Stack;
-import javax.xml.XMLConstants;
 import javax.xml.stream.XMLInputFactory;
 
 
@@ -365,7 +364,7 @@ public class XMLEntityManager implements
     // entities
 
     /** Entities. */
-    protected Hashtable fEntities = new Hashtable();
+    protected Map<String, Entity> fEntities = new HashMap<>();
 
     /** Entity stack. */
     protected Stack fEntityStack = new Stack();
@@ -852,7 +851,7 @@ public class XMLEntityManager implements
      */
     public boolean isExternalEntity(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         if (entity == null) {
             return false;
         }
@@ -869,7 +868,7 @@ public class XMLEntityManager implements
      */
     public boolean isEntityDeclInExternalSubset(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         if (entity == null) {
             return false;
         }
@@ -899,13 +898,13 @@ public class XMLEntityManager implements
 
     public boolean isDeclaredEntity(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         return entity != null;
     }
 
     public boolean isUnparsedEntity(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         if (entity == null) {
             return false;
         }
@@ -1111,7 +1110,7 @@ public class XMLEntityManager implements
     throws IOException, XNIException {
 
         // was entity declared?
-        Entity entity = (Entity)fEntityStorage.getEntity(entityName);
+        Entity entity = fEntityStorage.getEntity(entityName);
         if (entity == null) {
             if (fEntityHandler != null) {
                 String encoding = null;
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLErrorReporter.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLErrorReporter.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLErrorReporter.java
@@ -1,68 +1,24 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * The Apache Software License, Version 1.1
- *
- *
- * Copyright (c) 1999-2004 The Apache Software Foundation.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Xerces" and "Apache Software Foundation" must
- *    not be used to endorse or promote products derived from this
- *    software without prior written permission. For written
- *    permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    nor may "Apache" appear in their name, without prior written
- *    permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 package com.sun.org.apache.xerces.internal.impl;
-import java.util.Hashtable;
-import java.util.Locale;
-
 import com.sun.org.apache.xerces.internal.util.DefaultErrorHandler;
 import com.sun.org.apache.xerces.internal.util.ErrorHandlerProxy;
 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
@@ -73,6 +29,9 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLErrorHandler;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLParseException;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
 import org.xml.sax.ErrorHandler;
 
 /**
@@ -189,7 +148,7 @@ public class XMLErrorReporter
     protected Locale fLocale;
 
     /** Mapping of Message formatters for domains. */
-    protected Hashtable fMessageFormatters;
+    protected Map<String, MessageFormatter> fMessageFormatters;
 
     /** Error handler. */
     protected XMLErrorHandler fErrorHandler;
@@ -233,7 +192,7 @@ public class XMLErrorReporter
         //       caller to specify the location of the error being
         //       reported. -Ac
 
-        fMessageFormatters = new Hashtable();
+        fMessageFormatters = new HashMap<>();
 
     } // <init>()
 
@@ -291,7 +250,7 @@ public class XMLErrorReporter
      * @param domain The domain of the message formatter.
      */
     public MessageFormatter getMessageFormatter(String domain) {
-        return (MessageFormatter)fMessageFormatters.get(domain);
+        return fMessageFormatters.get(domain);
     } // getMessageFormatter(String):MessageFormatter
 
     /**
@@ -301,7 +260,7 @@ public class XMLErrorReporter
      * @param domain The domain of the message formatter.
      */
     public MessageFormatter removeMessageFormatter(String domain) {
-        return (MessageFormatter) fMessageFormatters.remove(domain);
+        return fMessageFormatters.remove(domain);
     } // removeMessageFormatter(String):MessageFormatter
 
     /**
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLStreamReaderImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLStreamReaderImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLStreamReaderImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,22 +25,21 @@
 
 package com.sun.org.apache.xerces.internal.impl;
 
+import com.sun.org.apache.xerces.internal.util.NamespaceContextWrapper;
+import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
+import com.sun.org.apache.xerces.internal.util.SymbolTable;
+import com.sun.org.apache.xerces.internal.util.XMLAttributesImpl;
+import com.sun.org.apache.xerces.internal.util.XMLChar;
+import com.sun.org.apache.xerces.internal.util.XMLStringBuffer;
+import com.sun.org.apache.xerces.internal.xni.XNIException;
+import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
 import com.sun.xml.internal.stream.Entity;
 import com.sun.xml.internal.stream.StaxErrorReporter;
 import com.sun.xml.internal.stream.XMLEntityStorage;
+import com.sun.xml.internal.stream.dtd.nonvalidating.DTDGrammar;
+import com.sun.xml.internal.stream.dtd.nonvalidating.XMLNotationDecl;
 import com.sun.xml.internal.stream.events.EntityDeclarationImpl;
 import com.sun.xml.internal.stream.events.NotationDeclarationImpl;
-import javax.xml.namespace.NamespaceContext;
-import com.sun.org.apache.xerces.internal.xni.XNIException;
-import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
-import javax.xml.XMLConstants;
-import javax.xml.namespace.QName;
-import javax.xml.stream.Location;
-import javax.xml.stream.events.XMLEvent;
-import com.sun.org.apache.xerces.internal.util.NamespaceContextWrapper;
-import com.sun.org.apache.xerces.internal.util.SymbolTable;
-import com.sun.xml.internal.stream.dtd.nonvalidating.XMLNotationDecl;
-import com.sun.xml.internal.stream.dtd.nonvalidating.DTDGrammar;
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -48,20 +47,16 @@ import java.io.InputStream;
 import java.io.Reader;
 import java.util.ArrayList;
 import java.util.Enumeration;
-import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
+import javax.xml.XMLConstants;
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.Location;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamConstants;
 import javax.xml.stream.XMLStreamException;
-import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
-import com.sun.org.apache.xerces.internal.util.XMLChar;
-import com.sun.org.apache.xerces.internal.util.XMLStringBuffer;
-import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
-import com.sun.org.apache.xerces.internal.util.XMLAttributesImpl;
-import com.sun.org.apache.xerces.internal.impl.Constants;
-import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
-import com.sun.xml.internal.stream.dtd.DTDGrammarUtil;
+import javax.xml.stream.events.XMLEvent;
 
 /** This class implements javax.xml.stream.XMLStreamReader. It makes use of XML*Scanner classes to
  * derive most of its functionality. If desired, Application can reuse this instance by calling
@@ -1173,7 +1168,7 @@ public class XMLStreamReaderImpl impleme
     public boolean hasText() {
         if(DEBUG) pr("XMLReaderImpl#EVENT TYPE = " + fEventType ) ;
         if( fEventType == XMLEvent.CHARACTERS || fEventType == XMLEvent.COMMENT || fEventType == XMLEvent.CDATA) {
-            return fScanner.getCharacterData().length > 0 ? true : false;
+            return fScanner.getCharacterData().length > 0;
         } else if(fEventType == XMLEvent.ENTITY_REFERENCE) {
             String name = fScanner.getEntityName();
             if(name != null){
@@ -1185,9 +1180,9 @@ public class XMLStreamReaderImpl impleme
                 if(en == null)
                     return false;
                 if(en.isExternal()){
-                    return ((Entity.ExternalEntity)en).entityLocation.getExpandedSystemId() != null ? true : false;
+                    return ((Entity.ExternalEntity)en).entityLocation.getExpandedSystemId() != null;
                 } else{
-                    return ((Entity.InternalEntity)en).text != null ? true : false ;
+                    return ((Entity.InternalEntity)en).text != null ;
                 }
             }else
                 return false;
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammar.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammar.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammar.java
@@ -1,69 +1,25 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * The Apache Software License, Version 1.1
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
- * Copyright (c) 1999-2002 The Apache Software Foundation.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Xerces" and "Apache Software Foundation" must
- *    not be used to endorse or promote products derived from this
- *    software without prior written permission. For written
- *    permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    nor may "Apache" appear in their name, without prior written
- *    permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 package com.sun.org.apache.xerces.internal.impl.dtd;
 
-import java.util.ArrayList;
-import java.util.Hashtable;
-
 import com.sun.org.apache.xerces.internal.impl.dtd.models.CMAny;
 import com.sun.org.apache.xerces.internal.impl.dtd.models.CMBinOp;
 import com.sun.org.apache.xerces.internal.impl.dtd.models.CMLeaf;
@@ -88,10 +44,13 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLDTDContentModelSource;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLDTDSource;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * A DTD grammar. This class implements the XNI handler interfaces
- * for DTD information so that it can build the approprate validation
+ * for DTD information so that it can build the appropriate validation
  * structures automatically from the callbacks.
  *
  * @xerces.internal
@@ -251,13 +210,13 @@ public class DTDGrammar
     // other information
 
     /** Element index mapping table. */
-    private QNameHashtable fElementIndexMap = new QNameHashtable();
+    private final Map<String, Integer> fElementIndexMap = new HashMap<>();
 
     /** Entity index mapping table. */
-    private QNameHashtable fEntityIndexMap = new QNameHashtable();
+    private final Map<String, Integer> fEntityIndexMap = new HashMap<>();
 
     /** Notation index mapping table. */
-    private QNameHashtable fNotationIndexMap = new QNameHashtable();
+    private final Map<String, Integer> fNotationIndexMap = new HashMap<>();
 
     // temp variables
 
@@ -291,7 +250,7 @@ public class DTDGrammar
     private XMLContentSpec fContentSpec = new XMLContentSpec();
 
     /** table of XMLElementDecl   */
-    Hashtable   fElementDeclTab     = new Hashtable();
+    Map<String, XMLElementDecl> fElementDeclTab = new HashMap<>();
 
     /** Children content model operation stack. */
     private short[] fOpStack = null;
@@ -516,7 +475,7 @@ public class DTDGrammar
     public void elementDecl(String name, String contentModel, Augmentations augs)
         throws XNIException {
 
-        XMLElementDecl tmpElementDecl = (XMLElementDecl) fElementDeclTab.get(name) ;
+        XMLElementDecl tmpElementDecl = fElementDeclTab.get(name) ;
 
         // check if it is already defined
         if ( tmpElementDecl != null ) {
@@ -606,7 +565,7 @@ public class DTDGrammar
                               String defaultType, XMLString defaultValue,
                               XMLString nonNormalizedDefaultValue, Augmentations augs) throws XNIException {
 
-        if ( this.fElementDeclTab.containsKey( (String) elementName) ) {
+        if ( this.fElementDeclTab.containsKey(elementName) ) {
             //if ElementDecl has already being created in the Grammar then remove from table,
             //this.fElementDeclTab.remove( (String) elementName );
         }
@@ -989,7 +948,7 @@ public class DTDGrammar
     public void startContentModel(String elementName, Augmentations augs)
         throws XNIException {
 
-        XMLElementDecl elementDecl = (XMLElementDecl) this.fElementDeclTab.get( elementName);
+        XMLElementDecl elementDecl = this.fElementDeclTab.get(elementName);
         if ( elementDecl != null ) {
             fElementDecl = elementDecl;
         }
@@ -1216,7 +1175,10 @@ public class DTDGrammar
      * @return index of the elementDeclName in scope
      */
     public int getElementDeclIndex(String elementDeclName) {
-        int mapping = fElementIndexMap.get(elementDeclName);
+        Integer mapping = fElementIndexMap.get(elementDeclName);
+        if (mapping == null) {
+            mapping = -1;
+        }
         //System.out.println("getElementDeclIndex("+elementDeclName+") -> "+mapping);
         return mapping;
     } // getElementDeclIndex(String):int
@@ -1393,7 +1355,7 @@ public class DTDGrammar
      * @return the index of the EntityDecl
      */
     public int getEntityDeclIndex(String entityDeclName) {
-        if (entityDeclName == null) {
+        if (entityDeclName == null || fEntityIndexMap.get(entityDeclName) == null) {
             return -1;
         }
 
@@ -1436,7 +1398,7 @@ public class DTDGrammar
      * @return the index if found a notation with the name, otherwise -1.
      */
     public int getNotationDeclIndex(String notationDeclName) {
-        if (notationDeclName == null) {
+        if (notationDeclName == null || fNotationIndexMap.get(notationDeclName) == null) {
             return -1;
         }
 
@@ -2670,108 +2632,6 @@ public class DTDGrammar
     } // class ChildrenList
 
     //
-    // Classes
-    //
-
-    /**
-     * A simple Hashtable implementation that takes a tuple (String, String)
-     * as the key and a int as value.
-     *
-     * @xerces.internal
-     *
-     * @author Eric Ye, IBM
-     * @author Andy Clark, IBM
-     */
-    protected static final class QNameHashtable {
-
-        //
-        // Constants
-        //
-
-        /** Initial bucket size (4). */
-        private static final int INITIAL_BUCKET_SIZE = 4;
-
-        // NOTE: Changed previous hashtable size from 512 to 101 so
-        //       that we get a better distribution for hashing. -Ac
-        /** Hashtable size (101). */
-        private static final int HASHTABLE_SIZE = 101;
-
-        //
-        // Data
-        //
-        private Object[][] fHashTable = new Object[HASHTABLE_SIZE][];
-
-        //
-        // Public methods
-        //
-        /** Associates the given value with the specified key tuple. */
-        public void put(String key, int value) {
-
-            int hash = (key.hashCode() & 0x7FFFFFFF) % HASHTABLE_SIZE;
-            Object[] bucket = fHashTable[hash];
-
-            if (bucket == null) {
-                bucket = new Object[1 + 2*INITIAL_BUCKET_SIZE];
-                bucket[0] = new int[]{1};
-                bucket[1] = key;
-                bucket[2] = new int[]{value};
-                fHashTable[hash] = bucket;
-            } else {
-                int count = ((int[])bucket[0])[0];
-                int offset = 1 + 2*count;
-                if (offset == bucket.length) {
-                    int newSize = count + INITIAL_BUCKET_SIZE;
-                    Object[] newBucket = new Object[1 + 2*newSize];
-                    System.arraycopy(bucket, 0, newBucket, 0, offset);
-                    bucket = newBucket;
-                    fHashTable[hash] = bucket;
-                }
-                boolean found = false;
-                int j=1;
-                for (int i=0; i<count; i++){
-                    if ((String)bucket[j] == key) {
-                        ((int[])bucket[j+1])[0] = value;
-                        found = true;
-                        break;
-                    }
-                    j += 2;
-                }
-                if (! found) {
-                    bucket[offset++] = key;
-                    bucket[offset]= new int[]{value};
-                    ((int[])bucket[0])[0] = ++count;
-                }
-
-            }
-            //System.out.println("put("+key+" -> "+value+')');
-            //System.out.println("get("+key+") -> "+get(key));
-
-        } // put(int,String,String,int)
-
-        /** Returns the value associated with the specified key tuple. */
-        public int get(String key) {
-            int hash = (key.hashCode() & 0x7FFFFFFF) % HASHTABLE_SIZE;
-            Object[] bucket = fHashTable[hash];
-
-            if (bucket == null) {
-                return -1;
-            }
-            int count = ((int[])bucket[0])[0];
-
-            int j=1;
-            for (int i=0; i<count; i++){
-                if ((String)bucket[j] == key) {
-                    return ((int[])bucket[j+1])[0];
-                }
-                j += 2;
-            }
-            return -1;
-
-        } // get(int,String,String)
-
-    }  // class QNameHashtable
-
-    //
     // EntityState methods
     //
     public boolean isEntityDeclared (String name){
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammarBucket.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammarBucket.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dtd/DTDGrammarBucket.java
@@ -1,68 +1,28 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * The Apache Software License, Version 1.1
- *
- *
- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Xerces" and "Apache Software Foundation" must
- *    not be used to endorse or promote products derived from this
- *    software without prior written permission. For written
- *    permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    nor may "Apache" appear in their name, without prior written
- *    permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 package com.sun.org.apache.xerces.internal.impl.dtd;
 
 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * This very simple class is the skeleton of what the DTDValidator could use
@@ -87,7 +47,7 @@ public class DTDGrammarBucket {
     //
 
     /** Grammars associated with element root name. */
-    protected Hashtable fGrammars;
+    protected Map<XMLDTDDescription, DTDGrammar> fGrammars;
 
     // the unique grammar from fGrammars (or that we're
     // building) that is used in validation.
@@ -102,7 +62,7 @@ public class DTDGrammarBucket {
 
     /** Default constructor. */
     public DTDGrammarBucket() {
-        fGrammars = new Hashtable();
+        fGrammars = new HashMap<>();
     } // <init>()
 
     //
@@ -122,7 +82,7 @@ public class DTDGrammarBucket {
 
     // retrieve a DTDGrammar given an XMLDTDDescription
     public DTDGrammar getGrammar(XMLGrammarDescription desc) {
-        return (DTDGrammar)(fGrammars.get((XMLDTDDescription)desc));
+        return fGrammars.get((XMLDTDDescription)desc);
     } // putGrammar(DTDGrammar)
 
     public void clear() {
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/DTDDVFactory.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/DTDDVFactory.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/DTDDVFactory.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001, 2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,7 +20,7 @@
 
 package com.sun.org.apache.xerces.internal.impl.dv;
 
-import java.util.Hashtable;
+import java.util.Map;
 import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
 
 /**
@@ -80,10 +80,10 @@ public abstract class DTDDVFactory {
     public abstract DatatypeValidator getBuiltInDV(String name);
 
     /**
-     * get all built-in DVs, which are stored in a hashtable keyed by the name
+     * get all built-in DVs, which are stored in a map keyed by the name
      *
-     * @return      a hashtable which contains all datatypes
+     * @return      a map which contains all datatypes
      */
-    public abstract Hashtable getBuiltInTypes();
+    public abstract Map<String, DatatypeValidator> getBuiltInTypes();
 
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/DTDDVFactoryImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/DTDDVFactoryImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/DTDDVFactoryImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001, 2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,7 +22,9 @@ package com.sun.org.apache.xerces.intern
 
 import com.sun.org.apache.xerces.internal.impl.dv.DTDDVFactory;
 import com.sun.org.apache.xerces.internal.impl.dv.DatatypeValidator;
-import java.util.Hashtable;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * the factory to create/return built-in schema DVs and create user-defined DVs
@@ -34,9 +36,25 @@ import java.util.Hashtable;
  */
 public class DTDDVFactoryImpl extends DTDDVFactory {
 
-    static Hashtable fBuiltInTypes = new Hashtable();
+    static final Map<String, DatatypeValidator> fBuiltInTypes;
     static {
-        createBuiltInTypes();
+        Map<String, DatatypeValidator> builtInTypes = new HashMap<>();
+        DatatypeValidator dvTemp;
+
+        builtInTypes.put("string", new StringDatatypeValidator());
+        builtInTypes.put("ID", new IDDatatypeValidator());
+        dvTemp = new IDREFDatatypeValidator();
+        builtInTypes.put("IDREF", dvTemp);
+        builtInTypes.put("IDREFS", new ListDatatypeValidator(dvTemp));
+        dvTemp = new ENTITYDatatypeValidator();
+        builtInTypes.put("ENTITY", new ENTITYDatatypeValidator());
+        builtInTypes.put("ENTITIES", new ListDatatypeValidator(dvTemp));
+        builtInTypes.put("NOTATION", new NOTATIONDatatypeValidator());
+        dvTemp = new NMTOKENDatatypeValidator();
+        builtInTypes.put("NMTOKEN", dvTemp);
+        builtInTypes.put("NMTOKENS", new ListDatatypeValidator(dvTemp));
+
+        fBuiltInTypes = Collections.unmodifiableMap(builtInTypes);
     }
 
     /**
@@ -45,37 +63,19 @@ public class DTDDVFactoryImpl extends DT
      * @param name  the name of the datatype
      * @return      the datatype validator of the given name
      */
+    @Override
     public DatatypeValidator getBuiltInDV(String name) {
-        return (DatatypeValidator)fBuiltInTypes.get(name);
+        return fBuiltInTypes.get(name);
     }
 
     /**
-     * get all built-in DVs, which are stored in a hashtable keyed by the name
+     * get all built-in DVs, which are stored in a Map keyed by the name
      *
-     * @return      a hashtable which contains all datatypes
+     * @return      a Map which contains all datatypes
      */
-    public Hashtable getBuiltInTypes() {
-        return (Hashtable)fBuiltInTypes.clone();
+    @Override
+    public Map<String, DatatypeValidator> getBuiltInTypes() {
+        return new HashMap<>(fBuiltInTypes);
     }
 
-    // create all built-in types
-    static void createBuiltInTypes() {
-
-        DatatypeValidator dvTemp;
-
-        fBuiltInTypes.put("string", new StringDatatypeValidator());
-        fBuiltInTypes.put("ID", new IDDatatypeValidator());
-        dvTemp = new IDREFDatatypeValidator();
-        fBuiltInTypes.put("IDREF", dvTemp);
-        fBuiltInTypes.put("IDREFS", new ListDatatypeValidator(dvTemp));
-        dvTemp = new ENTITYDatatypeValidator();
-        fBuiltInTypes.put("ENTITY", new ENTITYDatatypeValidator());
-        fBuiltInTypes.put("ENTITIES", new ListDatatypeValidator(dvTemp));
-        fBuiltInTypes.put("NOTATION", new NOTATIONDatatypeValidator());
-        dvTemp = new NMTOKENDatatypeValidator();
-        fBuiltInTypes.put("NMTOKEN", dvTemp);
-        fBuiltInTypes.put("NMTOKENS", new ListDatatypeValidator(dvTemp));
-
-    }//createBuiltInTypes()
-
 }// DTDDVFactoryImpl
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/XML11DTDDVFactoryImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/XML11DTDDVFactoryImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/dv/dtd/XML11DTDDVFactoryImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001, 2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,10 +20,10 @@
 
 package com.sun.org.apache.xerces.internal.impl.dv.dtd;
 
-import java.util.Enumeration;
-import java.util.Hashtable;
-
 import com.sun.org.apache.xerces.internal.impl.dv.DatatypeValidator;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * the factory to create/return built-in XML 1.1 DVs and create user-defined DVs
@@ -35,7 +35,18 @@ import com.sun.org.apache.xerces.interna
  */
 public class XML11DTDDVFactoryImpl extends DTDDVFactoryImpl {
 
-    static Hashtable fXML11BuiltInTypes = new Hashtable();
+    static Map<String, DatatypeValidator> XML11BUILTINTYPES;
+    static {
+        Map<String, DatatypeValidator> xml11BuiltInTypes = new HashMap<>();
+        xml11BuiltInTypes.put("XML11ID", new XML11IDDatatypeValidator());
+        DatatypeValidator dvTemp = new XML11IDREFDatatypeValidator();
+        xml11BuiltInTypes.put("XML11IDREF", dvTemp);
+        xml11BuiltInTypes.put("XML11IDREFS", new ListDatatypeValidator(dvTemp));
+        dvTemp = new XML11NMTOKENDatatypeValidator();
+        xml11BuiltInTypes.put("XML11NMTOKEN", dvTemp);
+        xml11BuiltInTypes.put("XML11NMTOKENS", new ListDatatypeValidator(dvTemp));
+        XML11BUILTINTYPES = Collections.unmodifiableMap(xml11BuiltInTypes);
+    } // <clinit>
 
     /**
      * return a dtd type of the given name
@@ -45,38 +56,24 @@ public class XML11DTDDVFactoryImpl exten
      * @param name  the name of the datatype
      * @return      the datatype validator of the given name
      */
+    @Override
     public DatatypeValidator getBuiltInDV(String name) {
-        if(fXML11BuiltInTypes.get(name) != null) {
-            return (DatatypeValidator)fXML11BuiltInTypes.get(name);
+        if(XML11BUILTINTYPES.get(name) != null) {
+            return XML11BUILTINTYPES.get(name);
         }
-        return (DatatypeValidator)fBuiltInTypes.get(name);
+        return fBuiltInTypes.get(name);
     }
 
     /**
-     * get all built-in DVs, which are stored in a hashtable keyed by the name
+     * get all built-in DVs, which are stored in a Map keyed by the name
      * New XML 1.1 datatypes are inserted.
      *
-     * @return      a hashtable which contains all datatypes
+     * @return      a Map which contains all datatypes
      */
-    public Hashtable getBuiltInTypes() {
-        Hashtable toReturn = (Hashtable)fBuiltInTypes.clone();
-        Enumeration xml11Keys = fXML11BuiltInTypes.keys();
-        while (xml11Keys.hasMoreElements()) {
-            Object key = xml11Keys.nextElement();
-            toReturn.put(key, fXML11BuiltInTypes.get(key));
-        }
+    @Override
+    public Map<String, DatatypeValidator> getBuiltInTypes() {
+        final HashMap<String, DatatypeValidator> toReturn = new HashMap<>(fBuiltInTypes);
+        toReturn.putAll(XML11BUILTINTYPES);
         return toReturn;
     }
-
-    static {
-        fXML11BuiltInTypes.put("XML11ID", new XML11IDDatatypeValidator());
-        DatatypeValidator dvTemp = new XML11IDREFDatatypeValidator();
-        fXML11BuiltInTypes.put("XML11IDREF", dvTemp);
-        fXML11BuiltInTypes.put("XML11IDREFS", new ListDatatypeValidator(dvTemp));
-        dvTemp = new XML11NMTOKENDatatypeValidator();
-        fXML11BuiltInTypes.put("XML11NMTOKEN", dvTemp);
-        fXML11BuiltInTypes.put("XML11NMTOKENS", new ListDatatypeValidator(dvTemp));
-    } // <clinit>
-
-
 }//XML11DTDDVFactoryImpl
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2000-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,13 +20,14 @@
 
 package com.sun.org.apache.xerces.internal.impl.xpath;
 
-import java.util.Vector;
-
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
-import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.util.XMLChar;
+import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
 import com.sun.org.apache.xerces.internal.xni.QName;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Vector;
 
 /**
  * Bare minimum XPath parser.
@@ -858,10 +859,10 @@ public class XPath {
         private SymbolTable fSymbolTable;
 
         // REVISIT: Code something better here. -Ac
-        private java.util.Hashtable fSymbolMapping = new java.util.Hashtable();
+        private Map<String, Integer> fSymbolMapping = new HashMap<>();
 
         // REVISIT: Code something better here. -Ac
-        private java.util.Hashtable fTokenNames = new java.util.Hashtable();
+        private Map<Integer, String> fTokenNames = new HashMap<>();
 
         /**
          * Current position in the token list.
@@ -882,57 +883,57 @@ public class XPath {
                 "self",
             };
             for (int i = 0; i < symbols.length; i++) {
-                fSymbolMapping.put(fSymbolTable.addSymbol(symbols[i]), new Integer(i));
+                fSymbolMapping.put(fSymbolTable.addSymbol(symbols[i]), i);
             }
-            fTokenNames.put(new Integer(EXPRTOKEN_OPEN_PAREN), "EXPRTOKEN_OPEN_PAREN");
-            fTokenNames.put(new Integer(EXPRTOKEN_CLOSE_PAREN), "EXPRTOKEN_CLOSE_PAREN");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPEN_BRACKET), "EXPRTOKEN_OPEN_BRACKET");
-            fTokenNames.put(new Integer(EXPRTOKEN_CLOSE_BRACKET), "EXPRTOKEN_CLOSE_BRACKET");
-            fTokenNames.put(new Integer(EXPRTOKEN_PERIOD), "EXPRTOKEN_PERIOD");
-            fTokenNames.put(new Integer(EXPRTOKEN_DOUBLE_PERIOD), "EXPRTOKEN_DOUBLE_PERIOD");
-            fTokenNames.put(new Integer(EXPRTOKEN_ATSIGN), "EXPRTOKEN_ATSIGN");
-            fTokenNames.put(new Integer(EXPRTOKEN_COMMA), "EXPRTOKEN_COMMA");
-            fTokenNames.put(new Integer(EXPRTOKEN_DOUBLE_COLON), "EXPRTOKEN_DOUBLE_COLON");
-            fTokenNames.put(new Integer(EXPRTOKEN_NAMETEST_ANY), "EXPRTOKEN_NAMETEST_ANY");
-            fTokenNames.put(new Integer(EXPRTOKEN_NAMETEST_NAMESPACE), "EXPRTOKEN_NAMETEST_NAMESPACE");
-            fTokenNames.put(new Integer(EXPRTOKEN_NAMETEST_QNAME), "EXPRTOKEN_NAMETEST_QNAME");
-            fTokenNames.put(new Integer(EXPRTOKEN_NODETYPE_COMMENT), "EXPRTOKEN_NODETYPE_COMMENT");
-            fTokenNames.put(new Integer(EXPRTOKEN_NODETYPE_TEXT), "EXPRTOKEN_NODETYPE_TEXT");
-            fTokenNames.put(new Integer(EXPRTOKEN_NODETYPE_PI), "EXPRTOKEN_NODETYPE_PI");
-            fTokenNames.put(new Integer(EXPRTOKEN_NODETYPE_NODE), "EXPRTOKEN_NODETYPE_NODE");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_AND), "EXPRTOKEN_OPERATOR_AND");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_OR), "EXPRTOKEN_OPERATOR_OR");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_MOD), "EXPRTOKEN_OPERATOR_MOD");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_DIV), "EXPRTOKEN_OPERATOR_DIV");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_MULT), "EXPRTOKEN_OPERATOR_MULT");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_SLASH), "EXPRTOKEN_OPERATOR_SLASH");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_DOUBLE_SLASH), "EXPRTOKEN_OPERATOR_DOUBLE_SLASH");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_UNION), "EXPRTOKEN_OPERATOR_UNION");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_PLUS), "EXPRTOKEN_OPERATOR_PLUS");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_MINUS), "EXPRTOKEN_OPERATOR_MINUS");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_EQUAL), "EXPRTOKEN_OPERATOR_EQUAL");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_NOT_EQUAL), "EXPRTOKEN_OPERATOR_NOT_EQUAL");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_LESS), "EXPRTOKEN_OPERATOR_LESS");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_LESS_EQUAL), "EXPRTOKEN_OPERATOR_LESS_EQUAL");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_GREATER), "EXPRTOKEN_OPERATOR_GREATER");
-            fTokenNames.put(new Integer(EXPRTOKEN_OPERATOR_GREATER_EQUAL), "EXPRTOKEN_OPERATOR_GREATER_EQUAL");
-            fTokenNames.put(new Integer(EXPRTOKEN_FUNCTION_NAME), "EXPRTOKEN_FUNCTION_NAME");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_ANCESTOR), "EXPRTOKEN_AXISNAME_ANCESTOR");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF), "EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_ATTRIBUTE), "EXPRTOKEN_AXISNAME_ATTRIBUTE");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_CHILD), "EXPRTOKEN_AXISNAME_CHILD");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_DESCENDANT), "EXPRTOKEN_AXISNAME_DESCENDANT");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF), "EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_FOLLOWING), "EXPRTOKEN_AXISNAME_FOLLOWING");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING), "EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_NAMESPACE), "EXPRTOKEN_AXISNAME_NAMESPACE");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_PARENT), "EXPRTOKEN_AXISNAME_PARENT");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_PRECEDING), "EXPRTOKEN_AXISNAME_PRECEDING");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_PRECEDING_SIBLING), "EXPRTOKEN_AXISNAME_PRECEDING_SIBLING");
-            fTokenNames.put(new Integer(EXPRTOKEN_AXISNAME_SELF), "EXPRTOKEN_AXISNAME_SELF");
-            fTokenNames.put(new Integer(EXPRTOKEN_LITERAL), "EXPRTOKEN_LITERAL");
-            fTokenNames.put(new Integer(EXPRTOKEN_NUMBER), "EXPRTOKEN_NUMBER");
-            fTokenNames.put(new Integer(EXPRTOKEN_VARIABLE_REFERENCE), "EXPRTOKEN_VARIABLE_REFERENCE");
+            fTokenNames.put(EXPRTOKEN_OPEN_PAREN, "EXPRTOKEN_OPEN_PAREN");
+            fTokenNames.put(EXPRTOKEN_CLOSE_PAREN, "EXPRTOKEN_CLOSE_PAREN");
+            fTokenNames.put(EXPRTOKEN_OPEN_BRACKET, "EXPRTOKEN_OPEN_BRACKET");
+            fTokenNames.put(EXPRTOKEN_CLOSE_BRACKET, "EXPRTOKEN_CLOSE_BRACKET");
+            fTokenNames.put(EXPRTOKEN_PERIOD, "EXPRTOKEN_PERIOD");
+            fTokenNames.put(EXPRTOKEN_DOUBLE_PERIOD, "EXPRTOKEN_DOUBLE_PERIOD");
+            fTokenNames.put(EXPRTOKEN_ATSIGN, "EXPRTOKEN_ATSIGN");
+            fTokenNames.put(EXPRTOKEN_COMMA, "EXPRTOKEN_COMMA");
+            fTokenNames.put(EXPRTOKEN_DOUBLE_COLON, "EXPRTOKEN_DOUBLE_COLON");
+            fTokenNames.put(EXPRTOKEN_NAMETEST_ANY, "EXPRTOKEN_NAMETEST_ANY");
+            fTokenNames.put(EXPRTOKEN_NAMETEST_NAMESPACE, "EXPRTOKEN_NAMETEST_NAMESPACE");
+            fTokenNames.put(EXPRTOKEN_NAMETEST_QNAME, "EXPRTOKEN_NAMETEST_QNAME");
+            fTokenNames.put(EXPRTOKEN_NODETYPE_COMMENT, "EXPRTOKEN_NODETYPE_COMMENT");
+            fTokenNames.put(EXPRTOKEN_NODETYPE_TEXT, "EXPRTOKEN_NODETYPE_TEXT");
+            fTokenNames.put(EXPRTOKEN_NODETYPE_PI, "EXPRTOKEN_NODETYPE_PI");
+            fTokenNames.put(EXPRTOKEN_NODETYPE_NODE, "EXPRTOKEN_NODETYPE_NODE");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_AND, "EXPRTOKEN_OPERATOR_AND");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_OR, "EXPRTOKEN_OPERATOR_OR");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_MOD, "EXPRTOKEN_OPERATOR_MOD");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_DIV, "EXPRTOKEN_OPERATOR_DIV");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_MULT, "EXPRTOKEN_OPERATOR_MULT");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_SLASH, "EXPRTOKEN_OPERATOR_SLASH");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_DOUBLE_SLASH, "EXPRTOKEN_OPERATOR_DOUBLE_SLASH");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_UNION, "EXPRTOKEN_OPERATOR_UNION");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_PLUS, "EXPRTOKEN_OPERATOR_PLUS");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_MINUS, "EXPRTOKEN_OPERATOR_MINUS");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_EQUAL, "EXPRTOKEN_OPERATOR_EQUAL");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_NOT_EQUAL, "EXPRTOKEN_OPERATOR_NOT_EQUAL");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_LESS, "EXPRTOKEN_OPERATOR_LESS");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_LESS_EQUAL, "EXPRTOKEN_OPERATOR_LESS_EQUAL");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_GREATER, "EXPRTOKEN_OPERATOR_GREATER");
+            fTokenNames.put(EXPRTOKEN_OPERATOR_GREATER_EQUAL, "EXPRTOKEN_OPERATOR_GREATER_EQUAL");
+            fTokenNames.put(EXPRTOKEN_FUNCTION_NAME, "EXPRTOKEN_FUNCTION_NAME");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_ANCESTOR, "EXPRTOKEN_AXISNAME_ANCESTOR");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF, "EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_ATTRIBUTE, "EXPRTOKEN_AXISNAME_ATTRIBUTE");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_CHILD, "EXPRTOKEN_AXISNAME_CHILD");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_DESCENDANT, "EXPRTOKEN_AXISNAME_DESCENDANT");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF, "EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_FOLLOWING, "EXPRTOKEN_AXISNAME_FOLLOWING");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING, "EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_NAMESPACE, "EXPRTOKEN_AXISNAME_NAMESPACE");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_PARENT, "EXPRTOKEN_AXISNAME_PARENT");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_PRECEDING, "EXPRTOKEN_AXISNAME_PRECEDING");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_PRECEDING_SIBLING, "EXPRTOKEN_AXISNAME_PRECEDING_SIBLING");
+            fTokenNames.put(EXPRTOKEN_AXISNAME_SELF, "EXPRTOKEN_AXISNAME_SELF");
+            fTokenNames.put(EXPRTOKEN_LITERAL, "EXPRTOKEN_LITERAL");
+            fTokenNames.put(EXPRTOKEN_NUMBER, "EXPRTOKEN_NUMBER");
+            fTokenNames.put(EXPRTOKEN_VARIABLE_REFERENCE, "EXPRTOKEN_VARIABLE_REFERENCE");
         }
 
         //
@@ -946,16 +947,21 @@ public class XPath {
 //        }
 //
         public String getTokenString(int token) {
-            return (String)fTokenNames.get(new Integer(token));
+            return fTokenNames.get(token);
         }
 
         public void addToken(String tokenStr) {
-            Integer tokenInt = (Integer)fTokenNames.get(tokenStr);
+            Integer tokenInt = null;
+            for (Map.Entry<Integer, String> entry : fTokenNames.entrySet()) {
+                if (entry.getValue().equals(tokenStr)) {
+                    tokenInt = entry.getKey();
+                }
+            }
             if (tokenInt == null) {
-                tokenInt = new Integer(fTokenNames.size());
+                tokenInt = fTokenNames.size();
                 fTokenNames.put(tokenInt, tokenStr);
             }
-            addToken(tokenInt.intValue());
+            addToken(tokenInt);
         }
 
         public void addToken(int token) {
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/ParserForXMLSchema.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/ParserForXMLSchema.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/ParserForXMLSchema.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,8 +20,9 @@
 
 package com.sun.org.apache.xerces.internal.impl.xpath.regex;
 
-import java.util.Hashtable;
+import java.util.HashMap;
 import java.util.Locale;
+import java.util.Map;
 
 /**
  * A regular expression parser for the XML Schema.
@@ -369,12 +370,12 @@ class ParserForXMLSchema extends RegexPa
         return c;
     }
 
-    static private Hashtable ranges = null;
-    static private Hashtable ranges2 = null;
+    static private Map<String, Token> ranges = null;
+    static private Map<String, Token> ranges2 = null;
     static synchronized protected RangeToken getRange(String name, boolean positive) {
         if (ranges == null) {
-            ranges = new Hashtable();
-            ranges2 = new Hashtable();
+            ranges = new HashMap<>();
+            ranges2 = new HashMap<>();
 
             Token tok = Token.createRange();
             setupRange(tok, SPACES);
@@ -390,7 +391,7 @@ class ParserForXMLSchema extends RegexPa
             tok = Token.createRange();
             setupRange(tok, LETTERS);
             setupRange(tok, LETTERS_INT);
-            tok.mergeRanges((Token)ranges.get("xml:isDigit"));
+            tok.mergeRanges(ranges.get("xml:isDigit"));
             ranges.put("xml:isWord", tok);
             ranges2.put("xml:isWord", Token.complementRanges(tok));
 
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/Token.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/Token.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/regex/Token.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,8 +20,18 @@
 
 package com.sun.org.apache.xerces.internal.impl.xpath.regex;
 
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.Vector;
-import java.util.Hashtable;
 
 /**
  * This class represents a node in parse tree.
@@ -583,8 +593,8 @@ class Token implements java.io.Serializa
     }
 
     // ------------------------------------------------------
-    private final static Hashtable categories = new Hashtable();
-    private final static Hashtable categories2 = new Hashtable();
+    private final static Map<String, Token> categories = new HashMap<>();
+    private final static Map<String, Token> categories2 = new HashMap<>();
     private static final String[] categoryNames = {
         "Cn", "Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Me", "Mc", "Nd",
         "Nl", "No", "Zs", "Zl", "Zp", "Cc", "Cf", null, "Co", "Cs",
@@ -820,7 +830,7 @@ class Token implements java.io.Serializa
                 //REVISIT: do we really need to support block names as in Unicode 3.1
                 //         or we can just create all the names in IsBLOCKNAME format (XML Schema REC)?
                 //
-                StringBuffer buffer = new StringBuffer(50);
+                StringBuilder buffer = new StringBuilder(50);
                 for (int i = 0;  i < Token.blockNames.length;  i ++) {
                     Token r1 = Token.createRange();
                     int location;
@@ -972,22 +982,17 @@ class Token implements java.io.Serializa
         return range;
     }
 
-    static Hashtable nonxs = null;
+    static final Set<String> nonxs = Collections.synchronizedSet(new HashSet<String>());
     /**
      * This method is called by only getRange().
      * So this method need not MT-safe.
      */
     static protected void registerNonXS(String name) {
-        if (Token.nonxs == null)
-            Token.nonxs = new Hashtable();
-        Token.nonxs.put(name, name);
+        Token.nonxs.add(name);
     }
+
     static protected boolean isRegisterNonXS(String name) {
-        if (Token.nonxs == null)
-            return false;
-        //DEBUG
-        //System.err.println("isRegisterNonXS: "+name);
-        return Token.nonxs.containsKey(name);
+        return Token.nonxs.contains(name);
     }
 
     private static void setAlias(String newName, String name, boolean positive) {
@@ -1423,17 +1428,26 @@ class Token implements java.io.Serializa
 
         private static final long serialVersionUID = -2568843945989489861L;
 
-        Vector children;
+        List<Token> children;
+
+        /**
+         * @serialField children Vector children
+         */
+        private static final ObjectStreamField[] serialPersistentFields =
+            new ObjectStreamField[] {
+                new ObjectStreamField("children", Vector.class),
+            };
 
         UnionToken(int type) {
             super(type);
         }
 
+        @Override
         void addChild(Token tok) {
             if (tok == null)  return;
-            if (this.children == null)  this.children = new Vector();
+            if (this.children == null)  this.children = new ArrayList<>();
             if (this.type == UNION) {
-                this.children.addElement(tok);
+                this.children.add(tok);
                 return;
             }
                                                 // This is CONCAT, and new child is CONCAT.
@@ -1444,31 +1458,31 @@ class Token implements java.io.Serializa
             }
             int size = this.children.size();
             if (size == 0) {
-                this.children.addElement(tok);
+                this.children.add(tok);
                 return;
             }
-            Token previous = (Token)this.children.elementAt(size-1);
+            Token previous = this.children.get(size - 1);
             if (!((previous.type == CHAR || previous.type == STRING)
                   && (tok.type == CHAR || tok.type == STRING))) {
-                this.children.addElement(tok);
+                this.children.add(tok);
                 return;
             }
 
             //System.err.println("Merge '"+previous+"' and '"+tok+"'.");
 
-            StringBuffer buffer;
+            StringBuilder buffer;
             int nextMaxLength = (tok.type == CHAR ? 2 : tok.getString().length());
             if (previous.type == CHAR) {        // Replace previous token by STRING
-                buffer = new StringBuffer(2 + nextMaxLength);
+                buffer = new StringBuilder(2 + nextMaxLength);
                 int ch = previous.getChar();
                 if (ch >= 0x10000)
                     buffer.append(REUtil.decomposeToSurrogates(ch));
                 else
                     buffer.append((char)ch);
                 previous = Token.createString(null);
-                this.children.setElementAt(previous, size-1);
+                this.children.set(size - 1, previous);
             } else {                            // STRING
-                buffer = new StringBuffer(previous.getString().length() + nextMaxLength);
+                buffer = new StringBuilder(previous.getString().length() + nextMaxLength);
                 buffer.append(previous.getString());
             }
 
@@ -1485,13 +1499,16 @@ class Token implements java.io.Serializa
             ((StringToken)previous).string = new String(buffer);
         }
 
+        @Override
         int size() {
             return this.children == null ? 0 : this.children.size();
         }
+        @Override
         Token getChild(int index) {
-            return (Token)this.children.elementAt(index);
+            return this.children.get(index);
         }
 
+        @Override
         public String toString(int options) {
             String ret;
             if (this.type == CONCAT) {
@@ -1505,9 +1522,9 @@ class Token implements java.io.Serializa
                     } else
                         ret = ch.toString(options)+ch2.toString(options);
                 } else {
-                    StringBuffer sb = new StringBuffer();
+                    StringBuilder sb = new StringBuilder();
                     for (int i = 0;  i < this.children.size();  i ++) {
-                        sb.append(((Token)this.children.elementAt(i)).toString(options));
+                        sb.append(((Token)this.children.get(i)).toString(options));
                     }
                     ret = new String(sb);
                 }
@@ -1519,15 +1536,39 @@ class Token implements java.io.Serializa
                        && this.getChild(0).type == EMPTY) {
                 ret = this.getChild(1).toString(options)+"??";
             } else {
-                StringBuffer sb = new StringBuffer();
-                sb.append(((Token)this.children.elementAt(0)).toString(options));
+                StringBuilder sb = new StringBuilder();
+                sb.append((this.children.get(0)).toString(options));
                 for (int i = 1;  i < this.children.size();  i ++) {
                     sb.append((char)'|');
-                    sb.append(((Token)this.children.elementAt(i)).toString(options));
+                    sb.append((this.children.get(i)).toString(options));
                 }
                 ret = new String(sb);
             }
             return ret;
         }
+
+        /**
+         * @serialData Serialized fields. Convert the List to Vector for backward compatibility.
+         */
+        private void writeObject(ObjectOutputStream out) throws IOException {
+            // Convert List to Vector
+            Vector<Token> vChildren = (children == null)? null : new Vector<>(children);
+
+            // Write serialized fields
+            ObjectOutputStream.PutField pf = out.putFields();
+            pf.put("children", vChildren);
+            out.writeFields();
+        }
+
+        @SuppressWarnings("unchecked")
+        private void readObject(ObjectInputStream in)
+                            throws IOException, ClassNotFoundException {
+            // We have to read serialized fields first.
+            ObjectInputStream.GetField gf = in.readFields();
+            Vector<Token> vChildren = (Vector<Token>)gf.get("children", null);
+
+            //convert Vector back to List
+            if (vChildren != null) children = new ArrayList<>(vChildren);
+        }
     }
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/SubstitutionGroupHandler.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/SubstitutionGroupHandler.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/SubstitutionGroupHandler.java
@@ -1,6 +1,5 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Copyright 2001-2005 The Apache Software Foundation.
@@ -20,12 +19,13 @@
 
 package com.sun.org.apache.xerces.internal.impl.xs;
 
+import com.sun.org.apache.xerces.internal.xni.QName;
 import com.sun.org.apache.xerces.internal.xs.XSConstants;
 import com.sun.org.apache.xerces.internal.xs.XSObjectList;
 import com.sun.org.apache.xerces.internal.xs.XSSimpleTypeDefinition;
 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
-import com.sun.org.apache.xerces.internal.xni.QName;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Vector;
 
 /**
@@ -172,14 +172,14 @@ public class SubstitutionGroupHandler {
     }
 
     // to store substitution group information
-    // the key to the hashtable is an element decl, and the value is
+    // the key to the map is an element decl, and the value is
     // - a Vector, which contains all elements that has this element as their
     //   substitution group affilication
     // - an array of OneSubGroup, which contains its substitution group before block.
-    Hashtable fSubGroupsB = new Hashtable();
+    Map<XSElementDecl, Object> fSubGroupsB = new HashMap<>();
     private static final OneSubGroup[] EMPTY_VECTOR = new OneSubGroup[0];
     // The real substitution groups (after "block")
-    Hashtable fSubGroups = new Hashtable();
+    Map<XSElementDecl, XSElementDecl[]> fSubGroups = new HashMap<>();
 
     /**
      * clear the internal registry of substitutionGroup information
@@ -221,9 +221,9 @@ public class SubstitutionGroupHandler {
      */
     public XSElementDecl[] getSubstitutionGroup(XSElementDecl element) {
         // If we already have sub group for this element, just return it.
-        Object subGroup = fSubGroups.get(element);
+        XSElementDecl[] subGroup = fSubGroups.get(element);
         if (subGroup != null)
-            return (XSElementDecl[])subGroup;
+            return subGroup;
 
         if ((element.fBlock & XSConstants.DERIVATION_SUBSTITUTION) != 0) {
             fSubGroups.put(element, EMPTY_GROUP);
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaLoader.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaLoader.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaLoader.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2000-2005 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,26 +20,12 @@
 
 package com.sun.org.apache.xerces.internal.impl.xs;
 
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.io.StringReader;
-import java.util.Hashtable;
-import java.util.Locale;
-import java.util.StringTokenizer;
-import java.util.Vector;
-
 import com.sun.org.apache.xerces.internal.dom.DOMErrorImpl;
 import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
 import com.sun.org.apache.xerces.internal.dom.DOMStringListImpl;
 import com.sun.org.apache.xerces.internal.impl.Constants;
 import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
 import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
-import com.sun.org.apache.xerces.internal.impl.dv.DVFactoryException;
 import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
 import com.sun.org.apache.xerces.internal.impl.dv.SchemaDVFactory;
 import com.sun.org.apache.xerces.internal.impl.dv.xs.SchemaDVFactoryImpl;
@@ -72,14 +58,25 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xs.StringList;
 import com.sun.org.apache.xerces.internal.xs.XSLoader;
 import com.sun.org.apache.xerces.internal.xs.XSModel;
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.StringReader;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
+import java.util.StringTokenizer;
+import java.util.Vector;
 import javax.xml.XMLConstants;
 import org.w3c.dom.DOMConfiguration;
 import org.w3c.dom.DOMError;
 import org.w3c.dom.DOMErrorHandler;
-import org.w3c.dom.DOMStringList;
 import org.w3c.dom.DOMException;
+import org.w3c.dom.DOMStringList;
 import org.w3c.dom.ls.LSInput;
 import org.w3c.dom.ls.LSResourceResolver;
 import org.xml.sax.InputSource;
@@ -596,9 +593,8 @@ XSLoader, DOMConfiguration {
      * @throws IOException
      * @throws XNIException
      */
-    SchemaGrammar loadSchema(XSDDescription desc,
-            XMLInputSource source,
-            Map locationPairs) throws IOException, XNIException {
+    SchemaGrammar loadSchema(XSDDescription desc, XMLInputSource source,
+            Map<String, LocationArray> locationPairs) throws IOException, XNIException {
 
         // this should only be done once per invocation of this object;
         // unless application alters JAXPSource in the mean time.
@@ -620,9 +616,9 @@ XSLoader, DOMConfiguration {
     } // loadSchema(XSDDescription, XMLInputSource):  SchemaGrammar
 
     /** This method tries to resolve location of the given schema.
-     * The loader stores the namespace/location pairs in a hashtable (use "" as the
+     * The loader stores the namespace/location pairs in a map (use "" as the
      * namespace of absent namespace). When resolving an entity, loader first tries
-     * to find in the hashtable whether there is a value for that namespace,
+     * to find in the map whether there is a value for that namespace,
      * if so, pass that location value to the user-defined entity resolver.
      *
      * @param desc
@@ -631,7 +627,8 @@ XSLoader, DOMConfiguration {
      * @return
      * @throws IOException
      */
-    public static XMLInputSource resolveDocument(XSDDescription desc, Map locationPairs,
+    public static XMLInputSource resolveDocument(XSDDescription desc,
+            Map<String, LocationArray> locationPairs,
             XMLEntityResolver entityResolver) throws IOException {
         String loc = null;
         // we consider the schema location properties for import
@@ -641,7 +638,7 @@ XSLoader, DOMConfiguration {
             String namespace = desc.getTargetNamespace();
             String ns = namespace == null ? XMLSymbols.EMPTY_STRING : namespace;
             // get the location hint for that namespace
-            LocationArray tempLA = (LocationArray)locationPairs.get(ns);
+            LocationArray tempLA = locationPairs.get(ns);
             if(tempLA != null)
                 loc = tempLA.getFirstLocation();
         }
@@ -662,7 +659,7 @@ XSLoader, DOMConfiguration {
 
     // add external schema locations to the location pairs
     public static void processExternalHints(String sl, String nsl,
-            Map locations,
+            Map<String, XMLSchemaLoader.LocationArray> locations,
             XMLErrorReporter er) {
         if (sl != null) {
             try {
@@ -715,7 +712,8 @@ XSLoader, DOMConfiguration {
     // @param schemaStr     The schemaLocation string to tokenize
     // @param locations     HashMap mapping namespaces to LocationArray objects holding lists of locaitons
     // @return true if no problems; false if string could not be tokenized
-    public static boolean tokenizeSchemaLocationStr(String schemaStr, Map locations) {
+    public static boolean tokenizeSchemaLocationStr(String schemaStr,
+            Map<String, XMLSchemaLoader.LocationArray> locations) {
         if (schemaStr!= null) {
             StringTokenizer t = new StringTokenizer(schemaStr, " \n\t\r");
             String namespace, location;
@@ -725,7 +723,7 @@ XSLoader, DOMConfiguration {
                     return false; // error!
                 }
                 location = t.nextToken();
-                LocationArray la = ((LocationArray)locations.get(namespace));
+                LocationArray la = locations.get(namespace);
                 if(la == null) {
                     la = new LocationArray();
                     locations.put(namespace, la);
@@ -746,7 +744,8 @@ XSLoader, DOMConfiguration {
      * Note: all JAXP schema files will be checked for full-schema validity if the feature was set up
      *
      */
-    private void processJAXPSchemaSource(Map locationPairs) throws IOException {
+    private void processJAXPSchemaSource(
+            Map<String, LocationArray> locationPairs) throws IOException {
         fJAXPProcessed = true;
         if (fJAXPSource == null) {
             return;
@@ -925,7 +924,7 @@ XSLoader, DOMConfiguration {
         return new XMLInputSource(publicId, systemId, null);
     }
 
-    static class LocationArray{
+    public static class LocationArray{
 
         int length ;
         String [] locations = new String[2];
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2005 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,16 +20,6 @@
 
 package com.sun.org.apache.xerces.internal.impl.xs;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Stack;
-import java.util.Vector;
-import java.util.ArrayList;
-import javax.xml.XMLConstants;
 import com.sun.org.apache.xerces.internal.impl.Constants;
 import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
 import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
@@ -51,13 +41,14 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.impl.xs.models.CMBuilder;
 import com.sun.org.apache.xerces.internal.impl.xs.models.CMNodeFactory;
 import com.sun.org.apache.xerces.internal.impl.xs.models.XSCMValidator;
+import com.sun.org.apache.xerces.internal.parsers.XMLParser;
 import com.sun.org.apache.xerces.internal.util.AugmentationsImpl;
 import com.sun.org.apache.xerces.internal.util.IntStack;
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
+import com.sun.org.apache.xerces.internal.util.URI.MalformedURIException;
 import com.sun.org.apache.xerces.internal.util.XMLAttributesImpl;
 import com.sun.org.apache.xerces.internal.util.XMLChar;
 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
-import com.sun.org.apache.xerces.internal.util.URI.MalformedURIException;
 import com.sun.org.apache.xerces.internal.xni.Augmentations;
 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
 import com.sun.org.apache.xerces.internal.xni.QName;
@@ -83,7 +74,13 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xs.XSConstants;
 import com.sun.org.apache.xerces.internal.xs.XSObjectList;
 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
-import com.sun.org.apache.xerces.internal.parsers.XMLParser;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Stack;
+import java.util.Vector;
 
 /**
  * The XML Schema validator. The validator implements a document
@@ -308,9 +305,6 @@ public class XMLSchemaValidator
     protected static final int ID_CONSTRAINT_NUM = 1;
 
     //
-    private static final Hashtable EMPTY_TABLE = new Hashtable();
-
-    //
     // Data
     //
 
@@ -495,7 +489,7 @@ public class XMLSchemaValidator
 
     /** Schema Grammar Description passed,  to give a chance to application to supply the Grammar */
     protected final XSDDescription fXSDDescription = new XSDDescription();
-    protected final Hashtable fLocationPairs = new Hashtable();
+    protected final Map<String, XMLSchemaLoader.LocationArray> fLocationPairs = new HashMap<>();
 
 
     // handlers
@@ -2358,8 +2352,7 @@ public class XMLSchemaValidator
             }
         }
         if (nsLocation != null) {
-            XMLSchemaLoader.LocationArray la =
-                ((XMLSchemaLoader.LocationArray) fLocationPairs.get(XMLSymbols.EMPTY_STRING));
+            XMLSchemaLoader.LocationArray la = fLocationPairs.get(XMLSymbols.EMPTY_STRING);
             if (la == null) {
                 la = new XMLSchemaLoader.LocationArray();
                 fLocationPairs.put(XMLSymbols.EMPTY_STRING, la);
@@ -2414,11 +2407,11 @@ public class XMLSchemaValidator
                 fXSDDescription.setBaseSystemId(fLocator.getExpandedSystemId());
             }
 
-            Hashtable locationPairs = fLocationPairs;
-            Object locationArray =
+            Map<String, XMLSchemaLoader.LocationArray> locationPairs = fLocationPairs;
+            XMLSchemaLoader.LocationArray locationArray =
                 locationPairs.get(namespace == null ? XMLSymbols.EMPTY_STRING : namespace);
             if (locationArray != null) {
-                String[] temp = ((XMLSchemaLoader.LocationArray) locationArray).getLocationArray();
+                String[] temp = locationArray.getLocationArray();
                 if (temp.length != 0) {
                     setLocationHints(fXSDDescription, temp, grammar);
                 }
@@ -2428,7 +2421,7 @@ public class XMLSchemaValidator
                 boolean toParseSchema = true;
                 if (grammar != null) {
                      // use location hints instead
-                    locationPairs = EMPTY_TABLE;
+                    locationPairs = Collections.<String, XMLSchemaLoader.LocationArray>emptyMap();
                 }
 
                 // try to parse the grammar using location hints from that namespace..
@@ -3688,7 +3681,7 @@ public class XMLSchemaValidator
 
         protected void checkDuplicateValues() {
             // no-op
-        } // duplicateValue(Hashtable)
+        } // duplicateValue(Map)
 
         /** Returns a string of the specified values. */
         protected String toString(Object[] values) {
@@ -3861,7 +3854,7 @@ public class XMLSchemaValidator
                 String cName = fIdentityConstraint.getIdentityConstraintName();
                 reportSchemaError(code, new Object[] { value, eName, cName });
             }
-        } // duplicateValue(Hashtable)
+        } // duplicateValue(Map)
 
     } // class UniqueValueStore
 
@@ -3898,7 +3891,7 @@ public class XMLSchemaValidator
                 String cName = fIdentityConstraint.getIdentityConstraintName();
                 reportSchemaError(code, new Object[] { value, eName, cName });
             }
-        } // duplicateValue(Hashtable)
+        } // duplicateValue(Map)
 
     } // class KeyValueStore
 
@@ -3990,14 +3983,15 @@ public class XMLSchemaValidator
 
         /**
          * Values stores associated to specific identity constraints.
-         * This hashtable maps IdentityConstraints and
+         * This map maps IdentityConstraints and
          * the 0-based element on which their selectors first matched to
          * a corresponding ValueStore.  This should take care
          * of all cases, including where ID constraints with
          * descendant-or-self axes occur on recursively-defined
          * elements.
          */
-        protected final Hashtable fIdentityConstraint2ValueStoreMap = new Hashtable();
+        protected final Map<LocalIDKey, ValueStoreBase>
+                fIdentityConstraint2ValueStoreMap = new HashMap<>();
 
         // sketch of algorithm:
         // - when a constraint is first encountered, its
@@ -4010,7 +4004,7 @@ public class XMLSchemaValidator
         // The fGlobalIDMapStack has the following structure:
         // - validation always occurs against the fGlobalIDConstraintMap
         // (which comprises all the "eligible" id constraints);
-        // When an endElement is found, this Hashtable is merged with the one
+        // When an endElement is found, this Map is merged with the one
         // below in the stack.
         // When a start tag is encountered, we create a new
         // fGlobalIDConstraintMap.
@@ -4018,8 +4012,10 @@ public class XMLSchemaValidator
         // the preceding siblings' eligible id constraints;
         // the fGlobalIDConstraintMap contains descendants+self.
         // keyrefs can only match descendants+self.
-        protected final Stack fGlobalMapStack = new Stack();
-        protected final Hashtable fGlobalIDConstraintMap = new Hashtable();
+        protected final Stack<Map<IdentityConstraint, ValueStoreBase>>
+                fGlobalMapStack = new Stack<>();
+        protected final Map<IdentityConstraint, ValueStoreBase>
+                fGlobalIDConstraintMap = new HashMap<>();
 
         //
         // Constructors
@@ -4046,7 +4042,8 @@ public class XMLSchemaValidator
         public void startElement() {
             // only clone the hashtable when there are elements
             if (fGlobalIDConstraintMap.size() > 0)
-                fGlobalMapStack.push(fGlobalIDConstraintMap.clone());
+                fGlobalMapStack.push((Map<IdentityConstraint, ValueStoreBase>)
+                        ((HashMap)fGlobalIDConstraintMap).clone());
             else
                 fGlobalMapStack.push(null);
             fGlobalIDConstraintMap.clear();
@@ -4059,19 +4056,17 @@ public class XMLSchemaValidator
             if (fGlobalMapStack.isEmpty()) {
                 return; // must be an invalid doc!
             }
-            Hashtable oldMap = (Hashtable) fGlobalMapStack.pop();
+            Map<IdentityConstraint, ValueStoreBase> oldMap = fGlobalMapStack.pop();
             // return if there is no element
             if (oldMap == null) {
                 return;
             }
 
-            Iterator entries = oldMap.entrySet().iterator();
-            while (entries.hasNext()) {
-                Map.Entry entry = (Map.Entry) entries.next();
-                IdentityConstraint id = (IdentityConstraint) entry.getKey();
-                ValueStoreBase oldVal = (ValueStoreBase) entry.getValue();
+            for (Map.Entry<IdentityConstraint, ValueStoreBase> entry : oldMap.entrySet()) {
+                IdentityConstraint id = entry.getKey();
+                ValueStoreBase oldVal = entry.getValue();
                 if (oldVal != null) {
-                    ValueStoreBase currVal = (ValueStoreBase) fGlobalIDConstraintMap.get(id);
+                    ValueStoreBase currVal = fGlobalIDConstraintMap.get(id);
                     if (currVal == null) {
                         fGlobalIDConstraintMap.put(id, oldVal);
                     }
@@ -4145,26 +4140,25 @@ public class XMLSchemaValidator
         public ValueStoreBase getValueStoreFor(IdentityConstraint id, int initialDepth) {
             fLocalId.fDepth = initialDepth;
             fLocalId.fId = id;
-            return (ValueStoreBase) fIdentityConstraint2ValueStoreMap.get(fLocalId);
+            return fIdentityConstraint2ValueStoreMap.get(fLocalId);
         } // getValueStoreFor(IdentityConstraint, int):ValueStoreBase
 
         /** Returns the global value store associated to the specified IdentityConstraint. */
         public ValueStoreBase getGlobalValueStoreFor(IdentityConstraint id) {
-            return (ValueStoreBase) fGlobalIDConstraintMap.get(id);
+            return fGlobalIDConstraintMap.get(id);
         } // getValueStoreFor(IdentityConstraint):ValueStoreBase
 
         // This method takes the contents of the (local) ValueStore
         // associated with id and moves them into the global
-        // hashtable, if id is a <unique> or a <key>.
+        // map, if id is a <unique> or a <key>.
         // If it's a <keyRef>, then we leave it for later.
         public void transplant(IdentityConstraint id, int initialDepth) {
             fLocalId.fDepth = initialDepth;
             fLocalId.fId = id;
-            ValueStoreBase newVals =
-                (ValueStoreBase) fIdentityConstraint2ValueStoreMap.get(fLocalId);
+            ValueStoreBase newVals = fIdentityConstraint2ValueStoreMap.get(fLocalId);
             if (id.getCategory() == IdentityConstraint.IC_KEYREF)
                 return;
-            ValueStoreBase currVals = (ValueStoreBase) fGlobalIDConstraintMap.get(id);
+            ValueStoreBase currVals = fGlobalIDConstraintMap.get(id);
             if (currVals != null) {
                 currVals.append(newVals);
                 fGlobalIDConstraintMap.put(id, currVals);
@@ -4205,7 +4199,7 @@ public class XMLSchemaValidator
     } // class ValueStoreCache
 
     // the purpose of this class is to enable IdentityConstraint,int
-    // pairs to be used easily as keys in Hashtables.
+    // pairs to be used easily as keys in Maps.
     protected class LocalIDKey {
 
         public IdentityConstraint fId;
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XSGrammarBucket.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XSGrammarBucket.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/XSGrammarBucket.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001, 2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,7 +20,6 @@
 
 package com.sun.org.apache.xerces.internal.impl.xs;
 
-import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Vector;
@@ -38,7 +37,7 @@ public class XSGrammarBucket {
     // Data
 
     /**
-     * Hashtable that maps between Namespace and a Grammar
+     * Map that maps between Namespace and a Grammar
      */
     Map<String, SchemaGrammar> fGrammarRegistry = new HashMap();
     SchemaGrammar fNoNSGrammar = null;
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSAttributeChecker.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSAttributeChecker.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSAttributeChecker.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,12 +20,6 @@
 
 package com.sun.org.apache.xerces.internal.impl.xs.traversers;
 
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.StringTokenizer;
-import java.util.Vector;
-
 import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
 import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
 import com.sun.org.apache.xerces.internal.impl.xs.SchemaGrammar;
@@ -44,6 +38,10 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xni.QName;
 import com.sun.org.apache.xerces.internal.xs.XSConstants;
 import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.StringTokenizer;
+import java.util.Vector;
 import org.w3c.dom.Attr;
 import org.w3c.dom.Element;
 
@@ -64,7 +62,7 @@ import org.w3c.dom.Element;
  * - Whether to return non-schema attributes/values
  * - Do we need to update NamespaceScope and ErrorReporter when reset()?
  * - Should have the datatype validators return compiled value
- * - use symbol table instead of many hashtables
+ * - use symbol table instead of many maps
  *
  * @xerces.internal
  *
@@ -1026,9 +1024,7 @@ public class XSAttributeChecker {
             return null;
         }
 
-        //Hashtable attrValues = new Hashtable();
         Object[] attrValues = getAvailableArray();
-        //Hashtable otherValues = new Hashtable();
         long fromDefault = 0;
 
         // clear the "seen" flag.
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,21 +20,6 @@
 
 package com.sun.org.apache.xerces.internal.impl.xs.traversers;
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Stack;
-import java.util.Vector;
-
-import javax.xml.stream.XMLEventReader;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-
 import com.sun.org.apache.xerces.internal.impl.Constants;
 import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
 import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
@@ -74,8 +59,8 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.util.StAXLocationWrapper;
 import com.sun.org.apache.xerces.internal.util.SymbolHash;
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
-import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.util.URI.MalformedURIException;
+import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;
 import com.sun.org.apache.xerces.internal.utils.XMLSecurityPropertyManager;
@@ -107,7 +92,19 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xs.XSTerm;
 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
 import com.sun.org.apache.xerces.internal.xs.datatypes.ObjectList;
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Stack;
+import java.util.Vector;
 import javax.xml.XMLConstants;
+import javax.xml.stream.XMLEventReader;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
@@ -277,9 +274,9 @@ public class XSDHandler {
     private Map<String, Element> fUnparsedIdentityConstraintRegistry =  new HashMap();
     private Map<String, Element> fUnparsedNotationRegistry =  new HashMap();
     private Map<String, Element> fUnparsedTypeRegistry =  new HashMap();
-    // Compensation for the above hashtables to locate XSDocumentInfo,
+    // Compensation for the above maps to locate XSDocumentInfo,
     // Since we may take Schema Element directly, so can not get the
-    // corresponding XSDocumentInfo object just using above hashtables.
+    // corresponding XSDocumentInfo object just using above maps.
     private Map<String, XSDocumentInfo> fUnparsedAttributeRegistrySub =  new HashMap();
     private Map<String, XSDocumentInfo> fUnparsedAttributeGroupRegistrySub =  new HashMap();
     private Map<String, XSDocumentInfo> fUnparsedElementRegistrySub =  new HashMap();
@@ -301,26 +298,25 @@ public class XSDHandler {
         null, // TYPEDECL_TYPE
     };
 
-    // this hashtable is keyed on by XSDocumentInfo objects.  Its values
+    // this map is keyed on by XSDocumentInfo objects.  Its values
     // are Vectors containing the XSDocumentInfo objects <include>d,
     // <import>ed or <redefine>d by the key XSDocumentInfo.
     private Map<XSDocumentInfo, Vector> fDependencyMap = new HashMap();
 
-    // this hashtable is keyed on by a target namespace.  Its values
+    // this map is keyed on by a target namespace.  Its values
     // are Vectors containing namespaces imported by schema documents
     // with the key target namespace.
     // if an imprted schema has absent namespace, the value "null" is stored.
     private Map<String, Vector> fImportMap = new HashMap();
     // all namespaces that imports other namespaces
     // if the importing schema has absent namespace, empty string is stored.
-    // (because the key of a hashtable can't be null.)
+    // (because the key of a map can't be null.)
     private Vector fAllTNSs = new Vector();
     // stores instance document mappings between namespaces and schema hints
-    private Map fLocationPairs = null;
-    private static final Map EMPTY_TABLE = new HashMap();
+    private Map<String, XMLSchemaLoader.LocationArray> fLocationPairs = null;
 
     // Records which nodes are hidden when the input is a DOMInputSource.
-    Hashtable fHiddenNodes = null;
+    Map<Node, String> fHiddenNodes = null;
 
     // convenience methods
     private String null2EmptyString(String ns) {
@@ -348,14 +344,14 @@ public class XSDHandler {
     // schema document that is included in multiple other schemas.
     private Map fTraversed = new HashMap();
 
-    // this hashtable contains a mapping from Schema Element to its systemId
+    // this map contains a mapping from Schema Element to its systemId
     // this is useful to resolve a uri relative to the referring document
     private Map fDoc2SystemId = new HashMap();
 
     // the primary XSDocumentInfo we were called to parse
     private XSDocumentInfo fRoot = null;
 
-    // This hashtable's job is to act as a link between the Schema Element and its
+    // This map's job is to act as a link between the Schema Element and its
     // XSDocumentInfo object.
     private Map fDoc2XSDocumentMap = new HashMap();
 
@@ -461,17 +457,17 @@ public class XSDHandler {
     private String [][] fKeyrefNamespaceContext = new String[INIT_KEYREF_STACK][1];
 
     // global decls: map from decl name to decl object
-    SymbolHash fGlobalAttrDecls = new SymbolHash();
-    SymbolHash fGlobalAttrGrpDecls = new SymbolHash();
-    SymbolHash fGlobalElemDecls = new SymbolHash();
-    SymbolHash fGlobalGroupDecls = new SymbolHash();
-    SymbolHash fGlobalNotationDecls = new SymbolHash();
-    SymbolHash fGlobalIDConstraintDecls = new SymbolHash();
-    SymbolHash fGlobalTypeDecls = new SymbolHash();
+    SymbolHash fGlobalAttrDecls = new SymbolHash(12);
+    SymbolHash fGlobalAttrGrpDecls = new SymbolHash(5);
+    SymbolHash fGlobalElemDecls = new SymbolHash(25);
+    SymbolHash fGlobalGroupDecls = new SymbolHash(5);
+    SymbolHash fGlobalNotationDecls = new SymbolHash(1);
+    SymbolHash fGlobalIDConstraintDecls = new SymbolHash(3);
+    SymbolHash fGlobalTypeDecls = new SymbolHash(25);
 
     // Constructors
     public XSDHandler(){
-        fHiddenNodes = new Hashtable();
+        fHiddenNodes = new HashMap<>();
         fSchemaParser = new SchemaDOMParser(new SchemaParsingConfig());
     }
 
@@ -500,7 +496,7 @@ public class XSDHandler {
      * @throws IOException
      */
     public SchemaGrammar parseSchema(XMLInputSource is, XSDDescription desc,
-            Map locationPairs)
+            Map<String, XMLSchemaLoader.LocationArray> locationPairs)
     throws IOException {
         fLocationPairs = locationPairs;
         fSchemaParser.resetNodePool();
@@ -1002,7 +998,7 @@ public class XSDHandler {
 
                 // If "findGrammar" returns a grammar, then this is not the
                 // the first time we see a location for a given namespace.
-                // Don't consult the location pair hashtable in this case,
+                // Don't consult the location pair map in this case,
                 // otherwise the location will be ignored because it'll get
                 // resolved to the same location as the first hint.
                 newSchemaRoot = resolveSchema(fSchemaGrammarDescription, false, child, isg == null);
@@ -2048,7 +2044,7 @@ public class XSDHandler {
                                   Element referElement, boolean usePairs) {
         XMLInputSource schemaSource = null;
         try {
-            Map pairs = usePairs ? fLocationPairs : EMPTY_TABLE;
+            Map<String, XMLSchemaLoader.LocationArray> pairs = usePairs ? fLocationPairs : Collections.<String, XMLSchemaLoader.LocationArray>emptyMap();
             schemaSource = XMLSchemaLoader.resolveDocument(desc, pairs, fEntityResolver);
         }
         catch (IOException ex) {
@@ -2101,7 +2097,7 @@ public class XSDHandler {
 
         XMLInputSource schemaSource = null;
         try {
-            Map pairs = usePairs ? fLocationPairs : EMPTY_TABLE;
+            Map<String, XMLSchemaLoader.LocationArray> pairs = usePairs ? fLocationPairs : Collections.<String, XMLSchemaLoader.LocationArray>emptyMap();
             schemaSource = XMLSchemaLoader.resolveDocument(desc, pairs, fEntityResolver);
         }
         catch (IOException ex) {
@@ -3791,7 +3787,7 @@ public class XSDHandler {
             fUnparsedRegistriesExt[declType].put(qName, currSchema);
         }
 
-    } // checkForDuplicateNames(String, Hashtable, Element, XSDocumentInfo):void
+    } // checkForDuplicateNames(String, Map, Element, XSDocumentInfo):void
 
     void checkForDuplicateNames(String qName, int declType, Element currComp) {
         int namespaceEnd = qName.indexOf(',');
@@ -3962,7 +3958,7 @@ public class XSDHandler {
     // this method takes a name of the form a:b, determines the URI mapped
     // to by a in the current SchemaNamespaceSupport object, and returns this
     // information in the form (nsURI,b) suitable for lookups in the global
-    // decl Hashtables.
+    // decl maps.
     // REVISIT: should have it return QName, instead of String. this would
     //          save lots of string concatenation time. we can use
     //          QName#equals() to compare two QNames, and use QName directly
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2000-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,16 +20,15 @@
 
 package com.sun.org.apache.xerces.internal.jaxp;
 
-import java.util.Hashtable;
-
+import com.sun.org.apache.xerces.internal.parsers.DOMParser;
+import com.sun.org.apache.xerces.internal.util.SAXMessageFormatter;
+import java.util.HashMap;
+import java.util.Map;
 import javax.xml.XMLConstants;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.validation.Schema;
-
-import com.sun.org.apache.xerces.internal.parsers.DOMParser;
-import com.sun.org.apache.xerces.internal.util.SAXMessageFormatter;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXNotRecognizedException;
 import org.xml.sax.SAXNotSupportedException;
@@ -41,8 +40,8 @@ import org.xml.sax.SAXNotSupportedExcept
  */
 public class DocumentBuilderFactoryImpl extends DocumentBuilderFactory {
     /** These are DocumentBuilderFactory attributes not DOM attributes */
-    private Hashtable attributes;
-    private Hashtable features;
+    private Map<String, Object> attributes;
+    private Map<String, Boolean> features;
     private Schema grammar;
     private boolean isXIncludeAware;
 
@@ -101,9 +100,9 @@ public class DocumentBuilderFactoryImpl
         // This is ugly.  We have to collect the attributes and then
         // later create a DocumentBuilderImpl to verify the attributes.
 
-        // Create Hashtable if none existed before
+        // Create the Map if none existed before
         if (attributes == null) {
-            attributes = new Hashtable();
+            attributes = new HashMap<>();
         }
 
         attributes.put(name, value);
@@ -124,7 +123,7 @@ public class DocumentBuilderFactoryImpl
     public Object getAttribute(String name)
         throws IllegalArgumentException
     {
-        // See if it's in the attributes Hashtable
+        // See if it's in the attributes Map
         if (attributes != null) {
             Object val = attributes.get(name);
             if (val != null) {
@@ -135,7 +134,7 @@ public class DocumentBuilderFactoryImpl
         DOMParser domParser = null;
         try {
             // We create a dummy DocumentBuilderImpl in case the attribute
-            // name is not one that is in the attributes hashtable.
+            // name is not one that is in the attributes map.
             domParser =
                 new DocumentBuilderImpl(this, attributes, features).getDOMParser();
             return domParser.getProperty(name);
@@ -173,11 +172,11 @@ public class DocumentBuilderFactoryImpl
         if (name.equals(XMLConstants.FEATURE_SECURE_PROCESSING)) {
             return fSecureProcess;
         }
-        // See if it's in the features Hashtable
+        // See if it's in the features map
         if (features != null) {
-            Object val = features.get(name);
+            Boolean val = features.get(name);
             if (val != null) {
-                return ((Boolean) val).booleanValue();
+                return val;
             }
         }
         try {
@@ -192,7 +191,7 @@ public class DocumentBuilderFactoryImpl
     public void setFeature(String name, boolean value)
         throws ParserConfigurationException {
         if (features == null) {
-            features = new Hashtable();
+            features = new HashMap<>();
         }
         // If this is the secure processing feature, save it then return.
         if (name.equals(XMLConstants.FEATURE_SECURE_PROCESSING)) {
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2000-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,15 +20,6 @@
 
 package com.sun.org.apache.xerces.internal.jaxp;
 
-import java.io.IOException;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.Map;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.validation.Schema;
-import javax.xml.XMLConstants;
-
 import com.sun.org.apache.xerces.internal.dom.DOMImplementationImpl;
 import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
 import com.sun.org.apache.xerces.internal.impl.Constants;
@@ -46,6 +37,11 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLParserConfiguration;
+import java.io.IOException;
+import java.util.Map;
+import javax.xml.XMLConstants;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.validation.Schema;
 import org.w3c.dom.DOMImplementation;
 import org.w3c.dom.Document;
 import org.xml.sax.EntityResolver;
@@ -126,12 +122,14 @@ public class DocumentBuilderImpl extends
     private XMLSecurityManager fSecurityManager;
     private XMLSecurityPropertyManager fSecurityPropertyMgr;
 
-    DocumentBuilderImpl(DocumentBuilderFactoryImpl dbf, Hashtable dbfAttrs, Hashtable features)
+    DocumentBuilderImpl(DocumentBuilderFactoryImpl dbf, Map<String, Object> dbfAttrs,
+            Map<String, Boolean> features)
         throws SAXNotRecognizedException, SAXNotSupportedException {
         this(dbf, dbfAttrs, features, false);
     }
 
-    DocumentBuilderImpl(DocumentBuilderFactoryImpl dbf, Hashtable dbfAttrs, Hashtable features, boolean secureProcessing)
+    DocumentBuilderImpl(DocumentBuilderFactoryImpl dbf, Map<String, Object> dbfAttrs,
+            Map<String, Boolean> features, boolean secureProcessing)
         throws SAXNotRecognizedException, SAXNotSupportedException
     {
         domParser = new DOMParser();
@@ -182,10 +180,9 @@ public class DocumentBuilderImpl extends
              * System Properties or jaxp.properties are set
              */
             if (features != null) {
-                Object temp = features.get(XMLConstants.FEATURE_SECURE_PROCESSING);
+                Boolean temp = features.get(XMLConstants.FEATURE_SECURE_PROCESSING);
                 if (temp != null) {
-                    boolean value = ((Boolean) temp).booleanValue();
-                    if (value && Constants.IS_JDK8_OR_ABOVE) {
+                    if (temp && Constants.IS_JDK8_OR_ABOVE) {
                         fSecurityPropertyMgr.setValue(Property.ACCESS_EXTERNAL_DTD,
                                 State.FSP, Constants.EXTERNAL_ACCESS_DEFAULT_FSP);
                         fSecurityPropertyMgr.setValue(Property.ACCESS_EXTERNAL_SCHEMA,
@@ -240,15 +237,11 @@ public class DocumentBuilderImpl extends
         fInitEntityResolver = domParser.getEntityResolver();
     }
 
-    private void setFeatures(Hashtable features)
+    private void setFeatures( Map<String, Boolean> features)
         throws SAXNotSupportedException, SAXNotRecognizedException {
         if (features != null) {
-            Iterator entries = features.entrySet().iterator();
-            while (entries.hasNext()) {
-                Map.Entry entry = (Map.Entry) entries.next();
-                String feature = (String) entry.getKey();
-                boolean value = ((Boolean) entry.getValue()).booleanValue();
-                domParser.setFeature(feature, value);
+            for (Map.Entry<String, Boolean> entry : features.entrySet()) {
+                domParser.setFeature(entry.getKey(), entry.getValue());
         }
     }
     }
@@ -260,7 +253,7 @@ public class DocumentBuilderImpl extends
      * attribute names and JAXP specific attribute names,
      * eg. DocumentBuilderFactory.setValidating()
      */
-    private void setDocumentBuilderFactoryAttributes(Hashtable dbfAttrs)
+    private void setDocumentBuilderFactoryAttributes( Map<String, Object> dbfAttrs)
         throws SAXNotSupportedException, SAXNotRecognizedException
     {
         if (dbfAttrs == null) {
@@ -268,14 +261,12 @@ public class DocumentBuilderImpl extends
             return;
         }
 
-        Iterator entries = dbfAttrs.entrySet().iterator();
-        while (entries.hasNext()) {
-            Map.Entry entry = (Map.Entry) entries.next();
-            String name = (String) entry.getKey();
+        for (Map.Entry<String, Object> entry : dbfAttrs.entrySet()) {
+            String name = entry.getKey();
             Object val = entry.getValue();
             if (val instanceof Boolean) {
                 // Assume feature
-                domParser.setFeature(name, ((Boolean)val).booleanValue());
+                domParser.setFeature(name, (Boolean)val);
             } else {
                 // Assume property
                 if (JAXP_SCHEMA_LANGUAGE.equals(name)) {
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2000-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,21 +20,19 @@
 
 package com.sun.org.apache.xerces.internal.jaxp;
 
-import java.util.Hashtable;
-
+import com.sun.org.apache.xerces.internal.impl.Constants;
+import com.sun.org.apache.xerces.internal.util.SAXMessageFormatter;
+import java.util.HashMap;
+import java.util.Map;
 import javax.xml.XMLConstants;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 import javax.xml.validation.Schema;
-
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXNotRecognizedException;
 import org.xml.sax.SAXNotSupportedException;
 
-import com.sun.org.apache.xerces.internal.impl.Constants;
-import com.sun.org.apache.xerces.internal.util.SAXMessageFormatter;
-
 /**
  * This is the implementation specific class for the
  * <code>javax.xml.parsers.SAXParserFactory</code>. This is the platform
@@ -59,7 +57,7 @@ public class SAXParserFactoryImpl extend
     private static final String XINCLUDE_FEATURE =
         Constants.XERCES_FEATURE_PREFIX + Constants.XINCLUDE_FEATURE;
 
-    private Hashtable features;
+    private Map<String, Boolean> features;
     private Schema grammar;
     private boolean isXIncludeAware;
 
@@ -188,7 +186,7 @@ public class SAXParserFactoryImpl extend
 
     private void putInFeatures(String name, boolean value){
          if (features == null) {
-            features = new Hashtable();
+            features = new HashMap<>();
         }
         features.put(name, value ? Boolean.TRUE : Boolean.FALSE);
     }
@@ -198,8 +196,8 @@ public class SAXParserFactoryImpl extend
             return false;
          }
          else {
-             Object value = features.get(name);
-             return (value == null) ? false : Boolean.valueOf(value.toString()).booleanValue();
+             Boolean value = features.get(name);
+             return (value == null) ? false : value;
          }
     }
 
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2000-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -39,7 +39,6 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xs.PSVIProvider;
 import java.io.IOException;
 import java.util.HashMap;
-import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
@@ -116,18 +115,18 @@ public class SAXParserImpl extends javax
 
     /**
      * Create a SAX parser with the associated features
-     * @param features Hashtable of SAX features, may be null
+     * @param features Map of SAX features, may be null
      */
-    SAXParserImpl(SAXParserFactoryImpl spf, Hashtable features)
+    SAXParserImpl(SAXParserFactoryImpl spf, Map<String, Boolean> features)
         throws SAXException {
         this(spf, features, false);
     }
 
     /**
      * Create a SAX parser with the associated features
-     * @param features Hashtable of SAX features, may be null
+     * @param features Map of SAX features, may be null
      */
-    SAXParserImpl(SAXParserFactoryImpl spf, Hashtable features, boolean secureProcessing)
+    SAXParserImpl(SAXParserFactoryImpl spf, Map<String, Boolean> features, boolean secureProcessing)
         throws SAXException
     {
         fSecurityManager = new XMLSecurityManager(secureProcessing);
@@ -165,10 +164,9 @@ public class SAXParserImpl extends javax
              */
             if (features != null) {
 
-                Object temp = features.get(XMLConstants.FEATURE_SECURE_PROCESSING);
+                Boolean temp = features.get(XMLConstants.FEATURE_SECURE_PROCESSING);
                 if (temp != null) {
-                    boolean value = ((Boolean) temp).booleanValue();
-                    if (value && Constants.IS_JDK8_OR_ABOVE) {
+                    if (temp && Constants.IS_JDK8_OR_ABOVE) {
                         fSecurityPropertyMgr.setValue(XMLSecurityPropertyManager.Property.ACCESS_EXTERNAL_DTD,
                                 XMLSecurityPropertyManager.State.FSP, Constants.EXTERNAL_ACCESS_DEFAULT_FSP);
                         fSecurityPropertyMgr.setValue(XMLSecurityPropertyManager.Property.ACCESS_EXTERNAL_SCHEMA,
@@ -241,15 +239,11 @@ public class SAXParserImpl extends javax
      * XXX Does not handle possible conflicts between SAX feature names and
      * JAXP specific feature names, eg. SAXParserFactory.isValidating()
      */
-    private void setFeatures(Hashtable features)
+    private void setFeatures(Map<String, Boolean> features)
         throws SAXNotSupportedException, SAXNotRecognizedException {
         if (features != null) {
-            Iterator entries = features.entrySet().iterator();
-            while (entries.hasNext()) {
-                Map.Entry entry = (Map.Entry) entries.next();
-                String feature = (String) entry.getKey();
-                boolean value = ((Boolean) entry.getValue()).booleanValue();
-                xmlReader.setFeature0(feature, value);
+            for (Map.Entry<String, Boolean> entry : features.entrySet()) {
+                xmlReader.setFeature0(entry.getKey(), entry.getValue());
             }
         }
     }
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/parsers/XMLGrammarPreparser.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/parsers/XMLGrammarPreparser.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/parsers/XMLGrammarPreparser.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001, 2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,15 +20,11 @@
 
 package com.sun.org.apache.xerces.internal.parsers;
 
-import java.io.IOException;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Locale;
-
 import com.sun.org.apache.xerces.internal.impl.Constants;
 import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
 import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
+import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
 import com.sun.org.apache.xerces.internal.xni.XNIException;
 import com.sun.org.apache.xerces.internal.xni.grammars.Grammar;
 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
@@ -37,7 +33,11 @@ import com.sun.org.apache.xerces.interna
 import com.sun.org.apache.xerces.internal.xni.parser.XMLEntityResolver;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLErrorHandler;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
-import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
 
 /**
  * <p> This class provides an easy way for a user to preparse grammars
@@ -82,13 +82,15 @@ public class XMLGrammarPreparser {
         Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
 
     // the "built-in" grammar loaders
-    private static final Hashtable KNOWN_LOADERS = new Hashtable();
+    private static final Map<String, String> KNOWN_LOADERS;
 
     static {
-        KNOWN_LOADERS.put(XMLGrammarDescription.XML_SCHEMA,
+        Map<String, String> loaders = new HashMap<>();
+        loaders.put(XMLGrammarDescription.XML_SCHEMA,
             "com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaLoader");
-        KNOWN_LOADERS.put(XMLGrammarDescription.XML_DTD,
+        loaders.put(XMLGrammarDescription.XML_DTD,
             "com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDLoader");
+        KNOWN_LOADERS = Collections.unmodifiableMap(loaders);
     }
 
     /** Recognized properties. */
@@ -108,8 +110,8 @@ public class XMLGrammarPreparser {
 
     protected Locale fLocale;
 
-    // Hashtable holding our loaders
-    private Hashtable fLoaders;
+    // Map holding our loaders
+    private Map<String, XMLGrammarLoader> fLoaders;
 
     //
     // Constructors
@@ -128,7 +130,7 @@ public class XMLGrammarPreparser {
     public XMLGrammarPreparser (SymbolTable symbolTable) {
         fSymbolTable = symbolTable;
 
-        fLoaders = new Hashtable();
+        fLoaders = new HashMap<>();
         fErrorReporter = new XMLErrorReporter();
         setLocale(Locale.getDefault());
         fEntityResolver = new XMLEntityManager();
@@ -189,7 +191,7 @@ public class XMLGrammarPreparser {
     public Grammar preparseGrammar(String type, XMLInputSource
                 is) throws XNIException, IOException {
         if(fLoaders.containsKey(type)) {
-            XMLGrammarLoader gl = (XMLGrammarLoader)fLoaders.get(type);
+            XMLGrammarLoader gl = fLoaders.get(type);
             // make sure gl's been set up with all the "basic" properties:
             gl.setProperty(SYMBOL_TABLE, fSymbolTable);
             gl.setProperty(ENTITY_RESOLVER, fEntityResolver);
@@ -271,7 +273,7 @@ public class XMLGrammarPreparser {
     // it's possible the application may want access to a certain loader to do
     // some custom work.
     public XMLGrammarLoader getLoader(String type) {
-        return (XMLGrammarLoader)fLoaders.get(type);
+        return fLoaders.get(type);
     } // getLoader(String):  XMLGrammarLoader
 
     // set a feature.  This method tries to set it on all
@@ -280,10 +282,9 @@ public class XMLGrammarPreparser {
     // by a grammar loader of a particular type, it will have
     // to retrieve that loader and use the loader's setFeature method.
     public void setFeature(String featureId, boolean value) {
-        Enumeration loaders = fLoaders.elements();
-        while(loaders.hasMoreElements()){
-            XMLGrammarLoader gl = (XMLGrammarLoader)loaders.nextElement();
+        for (Map.Entry<String, XMLGrammarLoader> entry : fLoaders.entrySet()) {
             try {
+                XMLGrammarLoader gl = entry.getValue();
                 gl.setFeature(featureId, value);
             } catch(Exception e) {
                 // eat it up...
@@ -304,10 +305,9 @@ public class XMLGrammarPreparser {
     // <p> <strong>An application should use the explicit method
     // in this class to set "standard" properties like error handler etc.</strong>
     public void setProperty(String propId, Object value) {
-        Enumeration loaders = fLoaders.elements();
-        while(loaders.hasMoreElements()){
-            XMLGrammarLoader gl = (XMLGrammarLoader)loaders.nextElement();
+        for (Map.Entry<String, XMLGrammarLoader> entry : fLoaders.entrySet()) {
             try {
+                XMLGrammarLoader gl = entry.getValue();
                 gl.setProperty(propId, value);
             } catch(Exception e) {
                 // eat it up...
@@ -322,7 +322,7 @@ public class XMLGrammarPreparser {
     // @param featureId the feature string to query.
     // @return the value of the feature.
     public boolean getFeature(String type, String featureId) {
-        XMLGrammarLoader gl = (XMLGrammarLoader)fLoaders.get(type);
+        XMLGrammarLoader gl = fLoaders.get(type);
         return gl.getFeature(featureId);
     } // getFeature (String, String):  boolean
 
@@ -335,7 +335,7 @@ public class XMLGrammarPreparser {
     // @param propertyId the property string to query.
     // @return the value of the property.
     public Object getProperty(String type, String propertyId) {
-        XMLGrammarLoader gl = (XMLGrammarLoader)fLoaders.get(type);
+        XMLGrammarLoader gl = fLoaders.get(type);
         return gl.getProperty(propertyId);
     } // getProperty(String, String):  Object
 } // class XMLGrammarPreparser
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/AugmentationsImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/AugmentationsImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/AugmentationsImpl.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2000-2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,14 +20,15 @@
 
 package com.sun.org.apache.xerces.internal.util;
 
-import java.util.Hashtable;
-import java.util.Enumeration;
-
 import com.sun.org.apache.xerces.internal.xni.Augmentations;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * This class provides an implementation for Augmentations interface.
- * Augmentations interface defines a hashtable of additional data that could
+ * Augmentations interface defines a map of additional data that could
  * be passed along the document pipeline. The information can contain extra
  * arguments or infoset augmentations, for example PSVI. This additional
  * information is identified by a String key.
@@ -194,18 +195,18 @@ public class AugmentationsImpl implement
         }
 
         public String toString() {
-            StringBuffer buff = new StringBuffer();
-            buff.append("SmallContainer - fNumEntries == " + fNumEntries);
+            StringBuilder buff = new StringBuilder();
+            buff.append("SmallContainer - fNumEntries == ").append(fNumEntries);
 
             for (int i = 0; i < SIZE_LIMIT*2; i=i+2) {
-                buff.append("\nfAugmentations[");
-                buff.append(i);
-                buff.append("] == ");
-                buff.append(fAugmentations[i]);
-                buff.append("; fAugmentations[");
-                buff.append(i+1);
-                buff.append("] == ");
-                buff.append(fAugmentations[i+1]);
+                buff.append("\nfAugmentations[")
+                    .append(i)
+                    .append("] == ")
+                    .append(fAugmentations[i])
+                    .append("; fAugmentations[")
+                    .append(i+1)
+                    .append("] == ")
+                    .append(fAugmentations[i+1]);
             }
 
             return buff.toString();
@@ -240,7 +241,7 @@ public class AugmentationsImpl implement
     }
 
     class LargeContainer extends AugmentationsItemsContainer {
-        final Hashtable fAugmentations = new Hashtable();
+        final Map<Object, Object> fAugmentations = new HashMap<>();
 
         public Object getItem(Object key) {
             return fAugmentations.get(key);
@@ -255,7 +256,7 @@ public class AugmentationsImpl implement
         }
 
         public Enumeration keys() {
-            return fAugmentations.keys();
+            return Collections.enumeration(fAugmentations.keySet());
         }
 
         public void clear() {
@@ -271,18 +272,14 @@ public class AugmentationsImpl implement
         }
 
         public String toString() {
-            StringBuffer buff = new StringBuffer();
+            StringBuilder buff = new StringBuilder();
             buff.append("LargeContainer");
-            Enumeration keys = fAugmentations.keys();
-
-            while (keys.hasMoreElements()) {
-                Object key = keys.nextElement();
+            for(Object key : fAugmentations.keySet()) {
                 buff.append("\nkey == ");
                 buff.append(key);
                 buff.append("; value == ");
                 buff.append(fAugmentations.get(key));
             }
-
             return buff.toString();
         }
     }
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMErrorHandlerWrapper.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMErrorHandlerWrapper.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMErrorHandlerWrapper.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001, 2002, 2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,20 +20,20 @@
 
 package com.sun.org.apache.xerces.internal.util;
 
+import com.sun.org.apache.xerces.internal.dom.DOMErrorImpl;
+import com.sun.org.apache.xerces.internal.dom.DOMLocatorImpl;
+import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
 import com.sun.org.apache.xerces.internal.xni.XNIException;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLErrorHandler;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLParseException;
-
-import org.w3c.dom.Node;
+import java.io.PrintWriter;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import org.w3c.dom.DOMError;
-import org.w3c.dom.DOMLocator;
 import org.w3c.dom.DOMErrorHandler;
-import com.sun.org.apache.xerces.internal.dom.DOMErrorImpl;
-import com.sun.org.apache.xerces.internal.dom.DOMLocatorImpl;
-import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
-
-import java.io.PrintWriter;
-import java.util.Hashtable;
+import org.w3c.dom.DOMLocator;
+import org.w3c.dom.Node;
 
 /**
  * This class handles DOM errors .
@@ -287,131 +287,133 @@ public class DOMErrorHandlerWrapper
     private static class DOMErrorTypeMap {
 
         /** Map for converting internal error codes to DOM error types. **/
-        private static Hashtable fgDOMErrorTypeTable;
+        private static final Map<XMLErrorCode, String> fgDOMErrorTypeTable;
 
         static {
             // initialize error type table: internal error codes (represented by domain and key) need to be mapped to a DOM error type.
 
             // REVISIT: do well-formedness issues involving XML declaration <?xml ... ?> need to be added to hash table (no XML declaration node in DOM, but Document includes xmlEncoding, xmlStandalone, xmlVersion, etc.
 
-            fgDOMErrorTypeTable = new Hashtable();
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInCDSect"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInContent"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "TwoColonsInQName"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ColonNotLegalWithNS"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInProlog"), "wf-invalid-character");  // e.g. in Processing Instruction
+            Map<XMLErrorCode, String> aDOMErrorTypeTable = new HashMap<>();
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInCDSect"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInContent"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "TwoColonsInQName"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ColonNotLegalWithNS"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInProlog"), "wf-invalid-character");  // e.g. in Processing Instruction
 
             // InvalidCharInXMLDecl omitted because XML declaration is not a DOM Node
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "CDEndInContent"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "CDSectUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "DoctypeNotAllowed"), "doctype-not-allowed");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ETagRequired"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementUnterminated"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EqRequiredInAttribute"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "OpenQuoteExpected"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "CloseQuoteExpected"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ETagUnterminated"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MarkupNotRecognizedInContent"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "DoctypeIllegalInContent"), "doctype-not-allowed");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInAttValue"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInPI"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInInternalSubset"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "QuoteRequiredInAttValue"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "LessthanInAttValue"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttributeValueUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PITargetRequired"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredInPI"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PIUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ReservedPITarget"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PI_NOT_IN_ONE_ENTITY"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PINotInOneEntity"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingDeclInvalid"), "unsupported-encoding");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingByteOrderUnsupported"), "unsupported-encoding");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInEntityValue"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInExternalSubset"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInIgnoreSect"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInPublicID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInSystemID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredAfterSYSTEM"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "QuoteRequiredInSystemID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SystemIDUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredAfterPUBLIC"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "QuoteRequiredInPublicID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PublicIDUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PubidCharIllegal"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredBetweenPublicAndSystem"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !DOCTYPE)
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ROOT_ELEMENT_TYPE_REQUIRED"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "DoctypedeclUnterminated"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PEReferenceWithinMarkup"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementDeclUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_CLOSE_PAREN_REQUIRED_IN_MIXED"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MixedContentUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttNameRequiredInAttDef"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttTypeRequiredInAttDef"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DUPLICATE_ATTRIBUTE_DEFINITION"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NAME_REQUIRED_IN_NOTATIONTYPE"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "NotationTypeUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NMTOKEN_REQUIRED_IN_ENUMERATION"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EnumerationUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DISTINCT_TOKENS_IN_ENUMERATION"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DISTINCT_NOTATION_IN_ENUMERATION"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "IncludeSectUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "IgnoreSectUnterminated"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "NameRequiredInPEReference"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SemicolonRequiredInPEReference"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY)
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY %)
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY %)
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY)
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_NDATA_IN_UNPARSED_ENTITYDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EntityDeclUnterminated"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DUPLICATE_ENTITY_DEFINITION"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ExternalIDRequired"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_URI_FRAGMENT_IN_SYSTEMID"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node, which follows !NOTATION
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node, which follows !NOTATION
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node, which follows !NOTATION
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ExternalIDorPublicIDRequired"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "NotationDeclUnterminated"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ReferenceToExternalEntity"), "wf-invalid-character");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ReferenceToUnparsedEntity"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "CDEndInContent"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "CDSectUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "DoctypeNotAllowed"), "doctype-not-allowed");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ETagRequired"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementUnterminated"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EqRequiredInAttribute"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "OpenQuoteExpected"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "CloseQuoteExpected"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ETagUnterminated"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MarkupNotRecognizedInContent"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "DoctypeIllegalInContent"), "doctype-not-allowed");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInAttValue"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInPI"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInInternalSubset"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "QuoteRequiredInAttValue"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "LessthanInAttValue"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttributeValueUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PITargetRequired"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredInPI"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PIUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ReservedPITarget"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PI_NOT_IN_ONE_ENTITY"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PINotInOneEntity"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingDeclInvalid"), "unsupported-encoding");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingByteOrderUnsupported"), "unsupported-encoding");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInEntityValue"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInExternalSubset"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInIgnoreSect"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInPublicID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInSystemID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredAfterSYSTEM"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "QuoteRequiredInSystemID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SystemIDUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredAfterPUBLIC"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "QuoteRequiredInPublicID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PublicIDUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PubidCharIllegal"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SpaceRequiredBetweenPublicAndSystem"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !DOCTYPE)
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ROOT_ELEMENT_TYPE_REQUIRED"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "DoctypedeclUnterminated"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PEReferenceWithinMarkup"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_MARKUP_NOT_RECOGNIZED_IN_DTD"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementDeclUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_CLOSE_PAREN_REQUIRED_IN_MIXED"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MixedContentUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttNameRequiredInAttDef"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttTypeRequiredInAttDef"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DUPLICATE_ATTRIBUTE_DEFINITION"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NAME_REQUIRED_IN_NOTATIONTYPE"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "NotationTypeUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NMTOKEN_REQUIRED_IN_ENUMERATION"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EnumerationUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DISTINCT_TOKENS_IN_ENUMERATION"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DISTINCT_NOTATION_IN_ENUMERATION"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "IncludeSectUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "IgnoreSectUnterminated"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "NameRequiredInPEReference"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "SemicolonRequiredInPEReference"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY)
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY %)
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY %)
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node (which follows !ENTITY)
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_NDATA_IN_UNPARSED_ENTITYDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EntityDeclUnterminated"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_DUPLICATE_ENTITY_DEFINITION"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ExternalIDRequired"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_URI_FRAGMENT_IN_SYSTEMID"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node, which follows !NOTATION
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node, which follows !NOTATION
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL"), "wf-invalid-character-in-node-name");  // considered error in name of node, which follows !NOTATION
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ExternalIDorPublicIDRequired"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "NotationDeclUnterminated"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ReferenceToExternalEntity"), "wf-invalid-character");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ReferenceToUnparsedEntity"), "wf-invalid-character");
 
             // REVISIT: do EntityNotDeclared, RecursiveReference, RecursiveGeneralReference, RecursivePEReference belong here?
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingNotSupported"), "unsupported-encoding");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingRequired"), "unsupported-encoding");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "IllegalQName"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementXMLNSPrefix"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementPrefixUnbound"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttributePrefixUnbound"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EmptyPrefixedAttName"), "wf-invalid-character-in-node-name");
-            fgDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PrefixDeclared"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingNotSupported"), "unsupported-encoding");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EncodingRequired"), "unsupported-encoding");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "IllegalQName"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementXMLNSPrefix"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "ElementPrefixUnbound"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "AttributePrefixUnbound"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "EmptyPrefixedAttName"), "wf-invalid-character-in-node-name");
+            aDOMErrorTypeTable.put(new XMLErrorCode(XMLMessageFormatter.XML_DOMAIN, "PrefixDeclared"), "wf-invalid-character-in-node-name");
+
+            fgDOMErrorTypeTable = Collections.unmodifiableMap(aDOMErrorTypeTable);
         }
 
         public static String getDOMErrorType (XMLErrorCode error) {
-            return (String) fgDOMErrorTypeTable.get(error);
+            return fgDOMErrorTypeTable.get(error);
         }
 
         private DOMErrorTypeMap () {}
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMUtil.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMUtil.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/DOMUtil.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -20,11 +20,10 @@
 
 package com.sun.org.apache.xerces.internal.util;
 
-import java.util.Hashtable;
-
 import com.sun.org.apache.xerces.internal.dom.AttrImpl;
 import com.sun.org.apache.xerces.internal.dom.DocumentImpl;
 import com.sun.org.apache.xerces.internal.impl.xs.opti.ElementImpl;
+import java.util.Map;
 import org.w3c.dom.Attr;
 import org.w3c.dom.DOMException;
 import org.w3c.dom.Document;
@@ -184,7 +183,7 @@ public class DOMUtil {
     } // getFirstChildElement(Node):Element
 
     /** Finds and returns the first visible child element node. */
-    public static Element getFirstVisibleChildElement(Node parent, Hashtable hiddenNodes) {
+    public static Element getFirstVisibleChildElement(Node parent, Map<Node, String> hiddenNodes) {
 
         // search for node
         Node child = parent.getFirstChild();
@@ -241,7 +240,7 @@ public class DOMUtil {
     /** Finds and returns the last visible child element node.
      *  Overload previous method for non-Xerces node impl
      */
-    public static Element getLastVisibleChildElement(Node parent, Hashtable hiddenNodes) {
+    public static Element getLastVisibleChildElement(Node parent, Map<Node, String> hiddenNodes) {
 
         // search for node
         Node child = parent.getLastChild();
@@ -293,7 +292,7 @@ public class DOMUtil {
     } // getNextSiblingdElement(Node):Element
 
     // get next visible (un-hidden) node, overload previous method for non Xerces node impl
-    public static Element getNextVisibleSiblingElement(Node node, Hashtable hiddenNodes) {
+    public static Element getNextVisibleSiblingElement(Node node, Map<Node, String> hiddenNodes) {
 
         // search for node
         Node sibling = node.getNextSibling();
@@ -319,7 +318,7 @@ public class DOMUtil {
     } // setHidden(node):void
 
     // set this Node as being hidden, overloaded method
-    public static void setHidden(Node node, Hashtable hiddenNodes) {
+    public static void setHidden(Node node, Map<Node, String> hiddenNodes) {
         if (node instanceof com.sun.org.apache.xerces.internal.impl.xs.opti.NodeImpl) {
             ((com.sun.org.apache.xerces.internal.impl.xs.opti.NodeImpl)node).setReadOnly(true, false);
         }
@@ -337,7 +336,7 @@ public class DOMUtil {
     } // setVisible(node):void
 
     // set this Node as being visible, overloaded method
-    public static void setVisible(Node node, Hashtable hiddenNodes) {
+    public static void setVisible(Node node, Map<Node, String> hiddenNodes) {
         if (node instanceof com.sun.org.apache.xerces.internal.impl.xs.opti.NodeImpl) {
             ((com.sun.org.apache.xerces.internal.impl.xs.opti.NodeImpl)node).setReadOnly(false, false);
         }
@@ -356,7 +355,7 @@ public class DOMUtil {
     } // isHidden(Node):boolean
 
     // is this node hidden? overloaded method
-    public static boolean isHidden(Node node, Hashtable hiddenNodes) {
+    public static boolean isHidden(Node node, Map<Node, String> hiddenNodes) {
         if (node instanceof com.sun.org.apache.xerces.internal.impl.xs.opti.NodeImpl) {
             return ((com.sun.org.apache.xerces.internal.impl.xs.opti.NodeImpl)node).getReadOnly();
         }
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/EncodingMap.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/EncodingMap.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/EncodingMap.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,7 +20,9 @@
 
 package com.sun.org.apache.xerces.internal.util;
 
-import java.util.Hashtable;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * EncodingMap is a convenience class which handles conversions between
@@ -477,469 +479,473 @@ public class EncodingMap {
     //
 
     /** fIANA2JavaMap */
-    protected final static Hashtable fIANA2JavaMap = new Hashtable();
+    protected final static Map<String, String> fIANA2JavaMap;
 
     /** fJava2IANAMap */
-    protected final static Hashtable fJava2IANAMap = new Hashtable();
+    protected final static Map<String, String> fJava2IANAMap;
 
     //
     // Static initialization
     //
 
     static {
+        Map<String, String> aIANA2JavaMap = new HashMap<>();
+        Map<String, String> aJava2IANAMap = new HashMap<>();
 
         // add IANA to Java encoding mappings.
-        fIANA2JavaMap.put("BIG5",            "Big5");
-        fIANA2JavaMap.put("CSBIG5",            "Big5");
-        fIANA2JavaMap.put("CP037",    "CP037");
-        fIANA2JavaMap.put("IBM037",    "CP037");
-        fIANA2JavaMap.put("CSIBM037",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-US",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-CA",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-NL",    "CP037");
-        fIANA2JavaMap.put("EBCDIC-CP-WT",    "CP037");
-        fIANA2JavaMap.put("IBM273",    "CP273");
-        fIANA2JavaMap.put("CP273",    "CP273");
-        fIANA2JavaMap.put("CSIBM273",    "CP273");
-        fIANA2JavaMap.put("IBM277",    "CP277");
-        fIANA2JavaMap.put("CP277",    "CP277");
-        fIANA2JavaMap.put("CSIBM277",    "CP277");
-        fIANA2JavaMap.put("EBCDIC-CP-DK",    "CP277");
-        fIANA2JavaMap.put("EBCDIC-CP-NO",    "CP277");
-        fIANA2JavaMap.put("IBM278",    "CP278");
-        fIANA2JavaMap.put("CP278",    "CP278");
-        fIANA2JavaMap.put("CSIBM278",    "CP278");
-        fIANA2JavaMap.put("EBCDIC-CP-FI",    "CP278");
-        fIANA2JavaMap.put("EBCDIC-CP-SE",    "CP278");
-        fIANA2JavaMap.put("IBM280",    "CP280");
-        fIANA2JavaMap.put("CP280",    "CP280");
-        fIANA2JavaMap.put("CSIBM280",    "CP280");
-        fIANA2JavaMap.put("EBCDIC-CP-IT",    "CP280");
-        fIANA2JavaMap.put("IBM284",    "CP284");
-        fIANA2JavaMap.put("CP284",    "CP284");
-        fIANA2JavaMap.put("CSIBM284",    "CP284");
-        fIANA2JavaMap.put("EBCDIC-CP-ES",    "CP284");
-        fIANA2JavaMap.put("EBCDIC-CP-GB",    "CP285");
-        fIANA2JavaMap.put("IBM285",    "CP285");
-        fIANA2JavaMap.put("CP285",    "CP285");
-        fIANA2JavaMap.put("CSIBM285",    "CP285");
-        fIANA2JavaMap.put("EBCDIC-JP-KANA",    "CP290");
-        fIANA2JavaMap.put("IBM290",    "CP290");
-        fIANA2JavaMap.put("CP290",    "CP290");
-        fIANA2JavaMap.put("CSIBM290",    "CP290");
-        fIANA2JavaMap.put("EBCDIC-CP-FR",    "CP297");
-        fIANA2JavaMap.put("IBM297",    "CP297");
-        fIANA2JavaMap.put("CP297",    "CP297");
-        fIANA2JavaMap.put("CSIBM297",    "CP297");
-        fIANA2JavaMap.put("EBCDIC-CP-AR1",   "CP420");
-        fIANA2JavaMap.put("IBM420",    "CP420");
-        fIANA2JavaMap.put("CP420",    "CP420");
-        fIANA2JavaMap.put("CSIBM420",    "CP420");
-        fIANA2JavaMap.put("EBCDIC-CP-HE",    "CP424");
-        fIANA2JavaMap.put("IBM424",    "CP424");
-        fIANA2JavaMap.put("CP424",    "CP424");
-        fIANA2JavaMap.put("CSIBM424",    "CP424");
-        fIANA2JavaMap.put("IBM437",    "CP437");
-        fIANA2JavaMap.put("437",    "CP437");
-        fIANA2JavaMap.put("CP437",    "CP437");
-        fIANA2JavaMap.put("CSPC8CODEPAGE437",    "CP437");
-        fIANA2JavaMap.put("EBCDIC-CP-CH",    "CP500");
-        fIANA2JavaMap.put("IBM500",    "CP500");
-        fIANA2JavaMap.put("CP500",    "CP500");
-        fIANA2JavaMap.put("CSIBM500",    "CP500");
-        fIANA2JavaMap.put("EBCDIC-CP-CH",    "CP500");
-        fIANA2JavaMap.put("EBCDIC-CP-BE",    "CP500");
-        fIANA2JavaMap.put("IBM775",    "CP775");
-        fIANA2JavaMap.put("CP775",    "CP775");
-        fIANA2JavaMap.put("CSPC775BALTIC",    "CP775");
-        fIANA2JavaMap.put("IBM850",    "CP850");
-        fIANA2JavaMap.put("850",    "CP850");
-        fIANA2JavaMap.put("CP850",    "CP850");
-        fIANA2JavaMap.put("CSPC850MULTILINGUAL",    "CP850");
-        fIANA2JavaMap.put("IBM852",    "CP852");
-        fIANA2JavaMap.put("852",    "CP852");
-        fIANA2JavaMap.put("CP852",    "CP852");
-        fIANA2JavaMap.put("CSPCP852",    "CP852");
-        fIANA2JavaMap.put("IBM855",    "CP855");
-        fIANA2JavaMap.put("855",    "CP855");
-        fIANA2JavaMap.put("CP855",    "CP855");
-        fIANA2JavaMap.put("CSIBM855",    "CP855");
-        fIANA2JavaMap.put("IBM857",    "CP857");
-        fIANA2JavaMap.put("857",    "CP857");
-        fIANA2JavaMap.put("CP857",    "CP857");
-        fIANA2JavaMap.put("CSIBM857",    "CP857");
-        fIANA2JavaMap.put("IBM00858",    "CP858");
-        fIANA2JavaMap.put("CP00858",    "CP858");
-        fIANA2JavaMap.put("CCSID00858",    "CP858");
-        fIANA2JavaMap.put("IBM860",    "CP860");
-        fIANA2JavaMap.put("860",    "CP860");
-        fIANA2JavaMap.put("CP860",    "CP860");
-        fIANA2JavaMap.put("CSIBM860",    "CP860");
-        fIANA2JavaMap.put("IBM861",    "CP861");
-        fIANA2JavaMap.put("861",    "CP861");
-        fIANA2JavaMap.put("CP861",    "CP861");
-        fIANA2JavaMap.put("CP-IS",    "CP861");
-        fIANA2JavaMap.put("CSIBM861",    "CP861");
-        fIANA2JavaMap.put("IBM862",    "CP862");
-        fIANA2JavaMap.put("862",    "CP862");
-        fIANA2JavaMap.put("CP862",    "CP862");
-        fIANA2JavaMap.put("CSPC862LATINHEBREW",    "CP862");
-        fIANA2JavaMap.put("IBM863",    "CP863");
-        fIANA2JavaMap.put("863",    "CP863");
-        fIANA2JavaMap.put("CP863",    "CP863");
-        fIANA2JavaMap.put("CSIBM863",    "CP863");
-        fIANA2JavaMap.put("IBM864",    "CP864");
-        fIANA2JavaMap.put("CP864",    "CP864");
-        fIANA2JavaMap.put("CSIBM864",    "CP864");
-        fIANA2JavaMap.put("IBM865",    "CP865");
-        fIANA2JavaMap.put("865",    "CP865");
-        fIANA2JavaMap.put("CP865",    "CP865");
-        fIANA2JavaMap.put("CSIBM865",    "CP865");
-        fIANA2JavaMap.put("IBM866",    "CP866");
-        fIANA2JavaMap.put("866",    "CP866");
-        fIANA2JavaMap.put("CP866",    "CP866");
-        fIANA2JavaMap.put("CSIBM866",    "CP866");
-        fIANA2JavaMap.put("IBM868",    "CP868");
-        fIANA2JavaMap.put("CP868",    "CP868");
-        fIANA2JavaMap.put("CSIBM868",    "CP868");
-        fIANA2JavaMap.put("CP-AR",        "CP868");
-        fIANA2JavaMap.put("IBM869",    "CP869");
-        fIANA2JavaMap.put("CP869",    "CP869");
-        fIANA2JavaMap.put("CSIBM869",    "CP869");
-        fIANA2JavaMap.put("CP-GR",        "CP869");
-        fIANA2JavaMap.put("IBM870",    "CP870");
-        fIANA2JavaMap.put("CP870",    "CP870");
-        fIANA2JavaMap.put("CSIBM870",    "CP870");
-        fIANA2JavaMap.put("EBCDIC-CP-ROECE", "CP870");
-        fIANA2JavaMap.put("EBCDIC-CP-YU",    "CP870");
-        fIANA2JavaMap.put("IBM871",    "CP871");
-        fIANA2JavaMap.put("CP871",    "CP871");
-        fIANA2JavaMap.put("CSIBM871",    "CP871");
-        fIANA2JavaMap.put("EBCDIC-CP-IS",    "CP871");
-        fIANA2JavaMap.put("IBM918",    "CP918");
-        fIANA2JavaMap.put("CP918",    "CP918");
-        fIANA2JavaMap.put("CSIBM918",    "CP918");
-        fIANA2JavaMap.put("EBCDIC-CP-AR2",   "CP918");
-        fIANA2JavaMap.put("IBM00924",    "CP924");
-        fIANA2JavaMap.put("CP00924",    "CP924");
-        fIANA2JavaMap.put("CCSID00924",    "CP924");
+        aIANA2JavaMap.put("BIG5",            "Big5");
+        aIANA2JavaMap.put("CSBIG5",            "Big5");
+        aIANA2JavaMap.put("CP037",    "CP037");
+        aIANA2JavaMap.put("IBM037",    "CP037");
+        aIANA2JavaMap.put("CSIBM037",    "CP037");
+        aIANA2JavaMap.put("EBCDIC-CP-US",    "CP037");
+        aIANA2JavaMap.put("EBCDIC-CP-CA",    "CP037");
+        aIANA2JavaMap.put("EBCDIC-CP-NL",    "CP037");
+        aIANA2JavaMap.put("EBCDIC-CP-WT",    "CP037");
+        aIANA2JavaMap.put("IBM273",    "CP273");
+        aIANA2JavaMap.put("CP273",    "CP273");
+        aIANA2JavaMap.put("CSIBM273",    "CP273");
+        aIANA2JavaMap.put("IBM277",    "CP277");
+        aIANA2JavaMap.put("CP277",    "CP277");
+        aIANA2JavaMap.put("CSIBM277",    "CP277");
+        aIANA2JavaMap.put("EBCDIC-CP-DK",    "CP277");
+        aIANA2JavaMap.put("EBCDIC-CP-NO",    "CP277");
+        aIANA2JavaMap.put("IBM278",    "CP278");
+        aIANA2JavaMap.put("CP278",    "CP278");
+        aIANA2JavaMap.put("CSIBM278",    "CP278");
+        aIANA2JavaMap.put("EBCDIC-CP-FI",    "CP278");
+        aIANA2JavaMap.put("EBCDIC-CP-SE",    "CP278");
+        aIANA2JavaMap.put("IBM280",    "CP280");
+        aIANA2JavaMap.put("CP280",    "CP280");
+        aIANA2JavaMap.put("CSIBM280",    "CP280");
+        aIANA2JavaMap.put("EBCDIC-CP-IT",    "CP280");
+        aIANA2JavaMap.put("IBM284",    "CP284");
+        aIANA2JavaMap.put("CP284",    "CP284");
+        aIANA2JavaMap.put("CSIBM284",    "CP284");
+        aIANA2JavaMap.put("EBCDIC-CP-ES",    "CP284");
+        aIANA2JavaMap.put("EBCDIC-CP-GB",    "CP285");
+        aIANA2JavaMap.put("IBM285",    "CP285");
+        aIANA2JavaMap.put("CP285",    "CP285");
+        aIANA2JavaMap.put("CSIBM285",    "CP285");
+        aIANA2JavaMap.put("EBCDIC-JP-KANA",    "CP290");
+        aIANA2JavaMap.put("IBM290",    "CP290");
+        aIANA2JavaMap.put("CP290",    "CP290");
+        aIANA2JavaMap.put("CSIBM290",    "CP290");
+        aIANA2JavaMap.put("EBCDIC-CP-FR",    "CP297");
+        aIANA2JavaMap.put("IBM297",    "CP297");
+        aIANA2JavaMap.put("CP297",    "CP297");
+        aIANA2JavaMap.put("CSIBM297",    "CP297");
+        aIANA2JavaMap.put("EBCDIC-CP-AR1",   "CP420");
+        aIANA2JavaMap.put("IBM420",    "CP420");
+        aIANA2JavaMap.put("CP420",    "CP420");
+        aIANA2JavaMap.put("CSIBM420",    "CP420");
+        aIANA2JavaMap.put("EBCDIC-CP-HE",    "CP424");
+        aIANA2JavaMap.put("IBM424",    "CP424");
+        aIANA2JavaMap.put("CP424",    "CP424");
+        aIANA2JavaMap.put("CSIBM424",    "CP424");
+        aIANA2JavaMap.put("IBM437",    "CP437");
+        aIANA2JavaMap.put("437",    "CP437");
+        aIANA2JavaMap.put("CP437",    "CP437");
+        aIANA2JavaMap.put("CSPC8CODEPAGE437",    "CP437");
+        aIANA2JavaMap.put("EBCDIC-CP-CH",    "CP500");
+        aIANA2JavaMap.put("IBM500",    "CP500");
+        aIANA2JavaMap.put("CP500",    "CP500");
+        aIANA2JavaMap.put("CSIBM500",    "CP500");
+        aIANA2JavaMap.put("EBCDIC-CP-CH",    "CP500");
+        aIANA2JavaMap.put("EBCDIC-CP-BE",    "CP500");
+        aIANA2JavaMap.put("IBM775",    "CP775");
+        aIANA2JavaMap.put("CP775",    "CP775");
+        aIANA2JavaMap.put("CSPC775BALTIC",    "CP775");
+        aIANA2JavaMap.put("IBM850",    "CP850");
+        aIANA2JavaMap.put("850",    "CP850");
+        aIANA2JavaMap.put("CP850",    "CP850");
+        aIANA2JavaMap.put("CSPC850MULTILINGUAL",    "CP850");
+        aIANA2JavaMap.put("IBM852",    "CP852");
+        aIANA2JavaMap.put("852",    "CP852");
+        aIANA2JavaMap.put("CP852",    "CP852");
+        aIANA2JavaMap.put("CSPCP852",    "CP852");
+        aIANA2JavaMap.put("IBM855",    "CP855");
+        aIANA2JavaMap.put("855",    "CP855");
+        aIANA2JavaMap.put("CP855",    "CP855");
+        aIANA2JavaMap.put("CSIBM855",    "CP855");
+        aIANA2JavaMap.put("IBM857",    "CP857");
+        aIANA2JavaMap.put("857",    "CP857");
+        aIANA2JavaMap.put("CP857",    "CP857");
+        aIANA2JavaMap.put("CSIBM857",    "CP857");
+        aIANA2JavaMap.put("IBM00858",    "CP858");
+        aIANA2JavaMap.put("CP00858",    "CP858");
+        aIANA2JavaMap.put("CCSID00858",    "CP858");
+        aIANA2JavaMap.put("IBM860",    "CP860");
+        aIANA2JavaMap.put("860",    "CP860");
+        aIANA2JavaMap.put("CP860",    "CP860");
+        aIANA2JavaMap.put("CSIBM860",    "CP860");
+        aIANA2JavaMap.put("IBM861",    "CP861");
+        aIANA2JavaMap.put("861",    "CP861");
+        aIANA2JavaMap.put("CP861",    "CP861");
+        aIANA2JavaMap.put("CP-IS",    "CP861");
+        aIANA2JavaMap.put("CSIBM861",    "CP861");
+        aIANA2JavaMap.put("IBM862",    "CP862");
+        aIANA2JavaMap.put("862",    "CP862");
+        aIANA2JavaMap.put("CP862",    "CP862");
+        aIANA2JavaMap.put("CSPC862LATINHEBREW",    "CP862");
+        aIANA2JavaMap.put("IBM863",    "CP863");
+        aIANA2JavaMap.put("863",    "CP863");
+        aIANA2JavaMap.put("CP863",    "CP863");
+        aIANA2JavaMap.put("CSIBM863",    "CP863");
+        aIANA2JavaMap.put("IBM864",    "CP864");
+        aIANA2JavaMap.put("CP864",    "CP864");
+        aIANA2JavaMap.put("CSIBM864",    "CP864");
+        aIANA2JavaMap.put("IBM865",    "CP865");
+        aIANA2JavaMap.put("865",    "CP865");
+        aIANA2JavaMap.put("CP865",    "CP865");
+        aIANA2JavaMap.put("CSIBM865",    "CP865");
+        aIANA2JavaMap.put("IBM866",    "CP866");
+        aIANA2JavaMap.put("866",    "CP866");
+        aIANA2JavaMap.put("CP866",    "CP866");
+        aIANA2JavaMap.put("CSIBM866",    "CP866");
+        aIANA2JavaMap.put("IBM868",    "CP868");
+        aIANA2JavaMap.put("CP868",    "CP868");
+        aIANA2JavaMap.put("CSIBM868",    "CP868");
+        aIANA2JavaMap.put("CP-AR",        "CP868");
+        aIANA2JavaMap.put("IBM869",    "CP869");
+        aIANA2JavaMap.put("CP869",    "CP869");
+        aIANA2JavaMap.put("CSIBM869",    "CP869");
+        aIANA2JavaMap.put("CP-GR",        "CP869");
+        aIANA2JavaMap.put("IBM870",    "CP870");
+        aIANA2JavaMap.put("CP870",    "CP870");
+        aIANA2JavaMap.put("CSIBM870",    "CP870");
+        aIANA2JavaMap.put("EBCDIC-CP-ROECE", "CP870");
+        aIANA2JavaMap.put("EBCDIC-CP-YU",    "CP870");
+        aIANA2JavaMap.put("IBM871",    "CP871");
+        aIANA2JavaMap.put("CP871",    "CP871");
+        aIANA2JavaMap.put("CSIBM871",    "CP871");
+        aIANA2JavaMap.put("EBCDIC-CP-IS",    "CP871");
+        aIANA2JavaMap.put("IBM918",    "CP918");
+        aIANA2JavaMap.put("CP918",    "CP918");
+        aIANA2JavaMap.put("CSIBM918",    "CP918");
+        aIANA2JavaMap.put("EBCDIC-CP-AR2",   "CP918");
+        aIANA2JavaMap.put("IBM00924",    "CP924");
+        aIANA2JavaMap.put("CP00924",    "CP924");
+        aIANA2JavaMap.put("CCSID00924",    "CP924");
         // is this an error???
-        fIANA2JavaMap.put("EBCDIC-LATIN9--EURO",    "CP924");
-        fIANA2JavaMap.put("IBM1026",    "CP1026");
-        fIANA2JavaMap.put("CP1026",    "CP1026");
-        fIANA2JavaMap.put("CSIBM1026",    "CP1026");
-        fIANA2JavaMap.put("IBM01140",    "Cp1140");
-        fIANA2JavaMap.put("CP01140",    "Cp1140");
-        fIANA2JavaMap.put("CCSID01140",    "Cp1140");
-        fIANA2JavaMap.put("IBM01141",    "Cp1141");
-        fIANA2JavaMap.put("CP01141",    "Cp1141");
-        fIANA2JavaMap.put("CCSID01141",    "Cp1141");
-        fIANA2JavaMap.put("IBM01142",    "Cp1142");
-        fIANA2JavaMap.put("CP01142",    "Cp1142");
-        fIANA2JavaMap.put("CCSID01142",    "Cp1142");
-        fIANA2JavaMap.put("IBM01143",    "Cp1143");
-        fIANA2JavaMap.put("CP01143",    "Cp1143");
-        fIANA2JavaMap.put("CCSID01143",    "Cp1143");
-        fIANA2JavaMap.put("IBM01144",    "Cp1144");
-        fIANA2JavaMap.put("CP01144",    "Cp1144");
-        fIANA2JavaMap.put("CCSID01144",    "Cp1144");
-        fIANA2JavaMap.put("IBM01145",    "Cp1145");
-        fIANA2JavaMap.put("CP01145",    "Cp1145");
-        fIANA2JavaMap.put("CCSID01145",    "Cp1145");
-        fIANA2JavaMap.put("IBM01146",    "Cp1146");
-        fIANA2JavaMap.put("CP01146",    "Cp1146");
-        fIANA2JavaMap.put("CCSID01146",    "Cp1146");
-        fIANA2JavaMap.put("IBM01147",    "Cp1147");
-        fIANA2JavaMap.put("CP01147",    "Cp1147");
-        fIANA2JavaMap.put("CCSID01147",    "Cp1147");
-        fIANA2JavaMap.put("IBM01148",    "Cp1148");
-        fIANA2JavaMap.put("CP01148",    "Cp1148");
-        fIANA2JavaMap.put("CCSID01148",    "Cp1148");
-        fIANA2JavaMap.put("IBM01149",    "Cp1149");
-        fIANA2JavaMap.put("CP01149",    "Cp1149");
-        fIANA2JavaMap.put("CCSID01149",    "Cp1149");
-        fIANA2JavaMap.put("EUC-JP",          "EUCJIS");
-        fIANA2JavaMap.put("CSEUCPKDFMTJAPANESE",          "EUCJIS");
-        fIANA2JavaMap.put("EXTENDED_UNIX_CODE_PACKED_FORMAT_FOR_JAPANESE",          "EUCJIS");
-        fIANA2JavaMap.put("EUC-KR",          "KSC5601");
-        fIANA2JavaMap.put("CSEUCKR",          "KSC5601");
-        fIANA2JavaMap.put("KS_C_5601-1987",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("ISO-IR-149",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("KS_C_5601-1989",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("KSC_5601",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("KOREAN",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("CSKSC56011987",          "KS_C_5601-1987");
-        fIANA2JavaMap.put("GB2312",          "GB2312");
-        fIANA2JavaMap.put("CSGB2312",          "GB2312");
-        fIANA2JavaMap.put("ISO-2022-JP",     "JIS");
-        fIANA2JavaMap.put("CSISO2022JP",     "JIS");
-        fIANA2JavaMap.put("ISO-2022-KR",     "ISO2022KR");
-        fIANA2JavaMap.put("CSISO2022KR",     "ISO2022KR");
-        fIANA2JavaMap.put("ISO-2022-CN",     "ISO2022CN");
-
-        fIANA2JavaMap.put("X0201",  "JIS0201");
-        fIANA2JavaMap.put("CSISO13JISC6220JP", "JIS0201");
-        fIANA2JavaMap.put("X0208",  "JIS0208");
-        fIANA2JavaMap.put("ISO-IR-87",  "JIS0208");
-        fIANA2JavaMap.put("X0208dbiJIS_X0208-1983",  "JIS0208");
-        fIANA2JavaMap.put("CSISO87JISX0208",  "JIS0208");
-        fIANA2JavaMap.put("X0212",  "JIS0212");
-        fIANA2JavaMap.put("ISO-IR-159",  "JIS0212");
-        fIANA2JavaMap.put("CSISO159JISX02121990",  "JIS0212");
-        fIANA2JavaMap.put("GB18030",       "GB18030");
-        fIANA2JavaMap.put("GBK",       "GBK");
-        fIANA2JavaMap.put("CP936",       "GBK");
-        fIANA2JavaMap.put("MS936",       "GBK");
-        fIANA2JavaMap.put("WINDOWS-936",       "GBK");
-        fIANA2JavaMap.put("SHIFT_JIS",       "SJIS");
-        fIANA2JavaMap.put("CSSHIFTJIS",       "SJIS");
-        fIANA2JavaMap.put("MS_KANJI",       "SJIS");
-        fIANA2JavaMap.put("WINDOWS-31J",       "MS932");
-        fIANA2JavaMap.put("CSWINDOWS31J",       "MS932");
+        aIANA2JavaMap.put("EBCDIC-LATIN9--EURO",    "CP924");
+        aIANA2JavaMap.put("IBM1026",    "CP1026");
+        aIANA2JavaMap.put("CP1026",    "CP1026");
+        aIANA2JavaMap.put("CSIBM1026",    "CP1026");
+        aIANA2JavaMap.put("IBM01140",    "Cp1140");
+        aIANA2JavaMap.put("CP01140",    "Cp1140");
+        aIANA2JavaMap.put("CCSID01140",    "Cp1140");
+        aIANA2JavaMap.put("IBM01141",    "Cp1141");
+        aIANA2JavaMap.put("CP01141",    "Cp1141");
+        aIANA2JavaMap.put("CCSID01141",    "Cp1141");
+        aIANA2JavaMap.put("IBM01142",    "Cp1142");
+        aIANA2JavaMap.put("CP01142",    "Cp1142");
+        aIANA2JavaMap.put("CCSID01142",    "Cp1142");
+        aIANA2JavaMap.put("IBM01143",    "Cp1143");
+        aIANA2JavaMap.put("CP01143",    "Cp1143");
+        aIANA2JavaMap.put("CCSID01143",    "Cp1143");
+        aIANA2JavaMap.put("IBM01144",    "Cp1144");
+        aIANA2JavaMap.put("CP01144",    "Cp1144");
+        aIANA2JavaMap.put("CCSID01144",    "Cp1144");
+        aIANA2JavaMap.put("IBM01145",    "Cp1145");
+        aIANA2JavaMap.put("CP01145",    "Cp1145");
+        aIANA2JavaMap.put("CCSID01145",    "Cp1145");
+        aIANA2JavaMap.put("IBM01146",    "Cp1146");
+        aIANA2JavaMap.put("CP01146",    "Cp1146");
+        aIANA2JavaMap.put("CCSID01146",    "Cp1146");
+        aIANA2JavaMap.put("IBM01147",    "Cp1147");
+        aIANA2JavaMap.put("CP01147",    "Cp1147");
+        aIANA2JavaMap.put("CCSID01147",    "Cp1147");
+        aIANA2JavaMap.put("IBM01148",    "Cp1148");
+        aIANA2JavaMap.put("CP01148",    "Cp1148");
+        aIANA2JavaMap.put("CCSID01148",    "Cp1148");
+        aIANA2JavaMap.put("IBM01149",    "Cp1149");
+        aIANA2JavaMap.put("CP01149",    "Cp1149");
+        aIANA2JavaMap.put("CCSID01149",    "Cp1149");
+        aIANA2JavaMap.put("EUC-JP",          "EUCJIS");
+        aIANA2JavaMap.put("CSEUCPKDFMTJAPANESE",          "EUCJIS");
+        aIANA2JavaMap.put("EXTENDED_UNIX_CODE_PACKED_FORMAT_FOR_JAPANESE",          "EUCJIS");
+        aIANA2JavaMap.put("EUC-KR",          "KSC5601");
+        aIANA2JavaMap.put("CSEUCKR",          "KSC5601");
+        aIANA2JavaMap.put("KS_C_5601-1987",          "KS_C_5601-1987");
+        aIANA2JavaMap.put("ISO-IR-149",          "KS_C_5601-1987");
+        aIANA2JavaMap.put("KS_C_5601-1989",          "KS_C_5601-1987");
+        aIANA2JavaMap.put("KSC_5601",          "KS_C_5601-1987");
+        aIANA2JavaMap.put("KOREAN",          "KS_C_5601-1987");
+        aIANA2JavaMap.put("CSKSC56011987",          "KS_C_5601-1987");
+        aIANA2JavaMap.put("GB2312",          "GB2312");
+        aIANA2JavaMap.put("CSGB2312",          "GB2312");
+        aIANA2JavaMap.put("ISO-2022-JP",     "JIS");
+        aIANA2JavaMap.put("CSISO2022JP",     "JIS");
+        aIANA2JavaMap.put("ISO-2022-KR",     "ISO2022KR");
+        aIANA2JavaMap.put("CSISO2022KR",     "ISO2022KR");
+        aIANA2JavaMap.put("ISO-2022-CN",     "ISO2022CN");
+
+        aIANA2JavaMap.put("X0201",  "JIS0201");
+        aIANA2JavaMap.put("CSISO13JISC6220JP", "JIS0201");
+        aIANA2JavaMap.put("X0208",  "JIS0208");
+        aIANA2JavaMap.put("ISO-IR-87",  "JIS0208");
+        aIANA2JavaMap.put("X0208dbiJIS_X0208-1983",  "JIS0208");
+        aIANA2JavaMap.put("CSISO87JISX0208",  "JIS0208");
+        aIANA2JavaMap.put("X0212",  "JIS0212");
+        aIANA2JavaMap.put("ISO-IR-159",  "JIS0212");
+        aIANA2JavaMap.put("CSISO159JISX02121990",  "JIS0212");
+        aIANA2JavaMap.put("GB18030",       "GB18030");
+        aIANA2JavaMap.put("GBK",       "GBK");
+        aIANA2JavaMap.put("CP936",       "GBK");
+        aIANA2JavaMap.put("MS936",       "GBK");
+        aIANA2JavaMap.put("WINDOWS-936",       "GBK");
+        aIANA2JavaMap.put("SHIFT_JIS",       "SJIS");
+        aIANA2JavaMap.put("CSSHIFTJIS",       "SJIS");
+        aIANA2JavaMap.put("MS_KANJI",       "SJIS");
+        aIANA2JavaMap.put("WINDOWS-31J",       "MS932");
+        aIANA2JavaMap.put("CSWINDOWS31J",       "MS932");
 
             // Add support for Cp1252 and its friends
-        fIANA2JavaMap.put("WINDOWS-1250",   "Cp1250");
-        fIANA2JavaMap.put("WINDOWS-1251",   "Cp1251");
-        fIANA2JavaMap.put("WINDOWS-1252",   "Cp1252");
-        fIANA2JavaMap.put("WINDOWS-1253",   "Cp1253");
-        fIANA2JavaMap.put("WINDOWS-1254",   "Cp1254");
-        fIANA2JavaMap.put("WINDOWS-1255",   "Cp1255");
-        fIANA2JavaMap.put("WINDOWS-1256",   "Cp1256");
-        fIANA2JavaMap.put("WINDOWS-1257",   "Cp1257");
-        fIANA2JavaMap.put("WINDOWS-1258",   "Cp1258");
-        fIANA2JavaMap.put("TIS-620",   "TIS620");
-
-        fIANA2JavaMap.put("ISO-8859-1",      "ISO8859_1");
-        fIANA2JavaMap.put("ISO-IR-100",      "ISO8859_1");
-        fIANA2JavaMap.put("ISO_8859-1",      "ISO8859_1");
-        fIANA2JavaMap.put("LATIN1",      "ISO8859_1");
-        fIANA2JavaMap.put("CSISOLATIN1",      "ISO8859_1");
-        fIANA2JavaMap.put("L1",      "ISO8859_1");
-        fIANA2JavaMap.put("IBM819",      "ISO8859_1");
-        fIANA2JavaMap.put("CP819",      "ISO8859_1");
-
-        fIANA2JavaMap.put("ISO-8859-2",      "ISO8859_2");
-        fIANA2JavaMap.put("ISO-IR-101",      "ISO8859_2");
-        fIANA2JavaMap.put("ISO_8859-2",      "ISO8859_2");
-        fIANA2JavaMap.put("LATIN2",      "ISO8859_2");
-        fIANA2JavaMap.put("CSISOLATIN2",      "ISO8859_2");
-        fIANA2JavaMap.put("L2",      "ISO8859_2");
-
-        fIANA2JavaMap.put("ISO-8859-3",      "ISO8859_3");
-        fIANA2JavaMap.put("ISO-IR-109",      "ISO8859_3");
-        fIANA2JavaMap.put("ISO_8859-3",      "ISO8859_3");
-        fIANA2JavaMap.put("LATIN3",      "ISO8859_3");
-        fIANA2JavaMap.put("CSISOLATIN3",      "ISO8859_3");
-        fIANA2JavaMap.put("L3",      "ISO8859_3");
-
-        fIANA2JavaMap.put("ISO-8859-4",      "ISO8859_4");
-        fIANA2JavaMap.put("ISO-IR-110",      "ISO8859_4");
-        fIANA2JavaMap.put("ISO_8859-4",      "ISO8859_4");
-        fIANA2JavaMap.put("LATIN4",      "ISO8859_4");
-        fIANA2JavaMap.put("CSISOLATIN4",      "ISO8859_4");
-        fIANA2JavaMap.put("L4",      "ISO8859_4");
-
-        fIANA2JavaMap.put("ISO-8859-5",      "ISO8859_5");
-        fIANA2JavaMap.put("ISO-IR-144",      "ISO8859_5");
-        fIANA2JavaMap.put("ISO_8859-5",      "ISO8859_5");
-        fIANA2JavaMap.put("CYRILLIC",      "ISO8859_5");
-        fIANA2JavaMap.put("CSISOLATINCYRILLIC",      "ISO8859_5");
-
-        fIANA2JavaMap.put("ISO-8859-6",      "ISO8859_6");
-        fIANA2JavaMap.put("ISO-IR-127",      "ISO8859_6");
-        fIANA2JavaMap.put("ISO_8859-6",      "ISO8859_6");
-        fIANA2JavaMap.put("ECMA-114",      "ISO8859_6");
-        fIANA2JavaMap.put("ASMO-708",      "ISO8859_6");
-        fIANA2JavaMap.put("ARABIC",      "ISO8859_6");
-        fIANA2JavaMap.put("CSISOLATINARABIC",      "ISO8859_6");
-
-        fIANA2JavaMap.put("ISO-8859-7",      "ISO8859_7");
-        fIANA2JavaMap.put("ISO-IR-126",      "ISO8859_7");
-        fIANA2JavaMap.put("ISO_8859-7",      "ISO8859_7");
-        fIANA2JavaMap.put("ELOT_928",      "ISO8859_7");
-        fIANA2JavaMap.put("ECMA-118",      "ISO8859_7");
-        fIANA2JavaMap.put("GREEK",      "ISO8859_7");
-        fIANA2JavaMap.put("CSISOLATINGREEK",      "ISO8859_7");
-        fIANA2JavaMap.put("GREEK8",      "ISO8859_7");
-
-        fIANA2JavaMap.put("ISO-8859-8",      "ISO8859_8");
-        fIANA2JavaMap.put("ISO-8859-8-I",      "ISO8859_8"); // added since this encoding only differs w.r.t. presentation
-        fIANA2JavaMap.put("ISO-IR-138",      "ISO8859_8");
-        fIANA2JavaMap.put("ISO_8859-8",      "ISO8859_8");
-        fIANA2JavaMap.put("HEBREW",      "ISO8859_8");
-        fIANA2JavaMap.put("CSISOLATINHEBREW",      "ISO8859_8");
-
-        fIANA2JavaMap.put("ISO-8859-9",      "ISO8859_9");
-        fIANA2JavaMap.put("ISO-IR-148",      "ISO8859_9");
-        fIANA2JavaMap.put("ISO_8859-9",      "ISO8859_9");
-        fIANA2JavaMap.put("LATIN5",      "ISO8859_9");
-        fIANA2JavaMap.put("CSISOLATIN5",      "ISO8859_9");
-        fIANA2JavaMap.put("L5",      "ISO8859_9");
-
-        fIANA2JavaMap.put("ISO-8859-13",      "ISO8859_13");
-
-        fIANA2JavaMap.put("ISO-8859-15",      "ISO8859_15_FDIS");
-        fIANA2JavaMap.put("ISO_8859-15",      "ISO8859_15_FDIS");
-        fIANA2JavaMap.put("LATIN-9",          "ISO8859_15_FDIS");
-
-        fIANA2JavaMap.put("KOI8-R",          "KOI8_R");
-        fIANA2JavaMap.put("CSKOI8R",          "KOI8_R");
-        fIANA2JavaMap.put("US-ASCII",        "ASCII");
-        fIANA2JavaMap.put("ISO-IR-6",        "ASCII");
-        fIANA2JavaMap.put("ANSI_X3.4-1968",        "ASCII");
-        fIANA2JavaMap.put("ANSI_X3.4-1986",        "ASCII");
-        fIANA2JavaMap.put("ISO_646.IRV:1991",        "ASCII");
-        fIANA2JavaMap.put("ASCII",        "ASCII");
-        fIANA2JavaMap.put("CSASCII",        "ASCII");
-        fIANA2JavaMap.put("ISO646-US",        "ASCII");
-        fIANA2JavaMap.put("US",        "ASCII");
-        fIANA2JavaMap.put("IBM367",        "ASCII");
-        fIANA2JavaMap.put("CP367",        "ASCII");
-        fIANA2JavaMap.put("UTF-8",           "UTF8");
-        fIANA2JavaMap.put("UTF-16",           "UTF-16");
-        fIANA2JavaMap.put("UTF-16BE",           "UnicodeBig");
-        fIANA2JavaMap.put("UTF-16LE",           "UnicodeLittle");
+        aIANA2JavaMap.put("WINDOWS-1250",   "Cp1250");
+        aIANA2JavaMap.put("WINDOWS-1251",   "Cp1251");
+        aIANA2JavaMap.put("WINDOWS-1252",   "Cp1252");
+        aIANA2JavaMap.put("WINDOWS-1253",   "Cp1253");
+        aIANA2JavaMap.put("WINDOWS-1254",   "Cp1254");
+        aIANA2JavaMap.put("WINDOWS-1255",   "Cp1255");
+        aIANA2JavaMap.put("WINDOWS-1256",   "Cp1256");
+        aIANA2JavaMap.put("WINDOWS-1257",   "Cp1257");
+        aIANA2JavaMap.put("WINDOWS-1258",   "Cp1258");
+        aIANA2JavaMap.put("TIS-620",   "TIS620");
+
+        aIANA2JavaMap.put("ISO-8859-1",      "ISO8859_1");
+        aIANA2JavaMap.put("ISO-IR-100",      "ISO8859_1");
+        aIANA2JavaMap.put("ISO_8859-1",      "ISO8859_1");
+        aIANA2JavaMap.put("LATIN1",      "ISO8859_1");
+        aIANA2JavaMap.put("CSISOLATIN1",      "ISO8859_1");
+        aIANA2JavaMap.put("L1",      "ISO8859_1");
+        aIANA2JavaMap.put("IBM819",      "ISO8859_1");
+        aIANA2JavaMap.put("CP819",      "ISO8859_1");
+
+        aIANA2JavaMap.put("ISO-8859-2",      "ISO8859_2");
+        aIANA2JavaMap.put("ISO-IR-101",      "ISO8859_2");
+        aIANA2JavaMap.put("ISO_8859-2",      "ISO8859_2");
+        aIANA2JavaMap.put("LATIN2",      "ISO8859_2");
+        aIANA2JavaMap.put("CSISOLATIN2",      "ISO8859_2");
+        aIANA2JavaMap.put("L2",      "ISO8859_2");
+
+        aIANA2JavaMap.put("ISO-8859-3",      "ISO8859_3");
+        aIANA2JavaMap.put("ISO-IR-109",      "ISO8859_3");
+        aIANA2JavaMap.put("ISO_8859-3",      "ISO8859_3");
+        aIANA2JavaMap.put("LATIN3",      "ISO8859_3");
+        aIANA2JavaMap.put("CSISOLATIN3",      "ISO8859_3");
+        aIANA2JavaMap.put("L3",      "ISO8859_3");
+
+        aIANA2JavaMap.put("ISO-8859-4",      "ISO8859_4");
+        aIANA2JavaMap.put("ISO-IR-110",      "ISO8859_4");
+        aIANA2JavaMap.put("ISO_8859-4",      "ISO8859_4");
+        aIANA2JavaMap.put("LATIN4",      "ISO8859_4");
+        aIANA2JavaMap.put("CSISOLATIN4",      "ISO8859_4");
+        aIANA2JavaMap.put("L4",      "ISO8859_4");
+
+        aIANA2JavaMap.put("ISO-8859-5",      "ISO8859_5");
+        aIANA2JavaMap.put("ISO-IR-144",      "ISO8859_5");
+        aIANA2JavaMap.put("ISO_8859-5",      "ISO8859_5");
+        aIANA2JavaMap.put("CYRILLIC",      "ISO8859_5");
+        aIANA2JavaMap.put("CSISOLATINCYRILLIC",      "ISO8859_5");
+
+        aIANA2JavaMap.put("ISO-8859-6",      "ISO8859_6");
+        aIANA2JavaMap.put("ISO-IR-127",      "ISO8859_6");
+        aIANA2JavaMap.put("ISO_8859-6",      "ISO8859_6");
+        aIANA2JavaMap.put("ECMA-114",      "ISO8859_6");
+        aIANA2JavaMap.put("ASMO-708",      "ISO8859_6");
+        aIANA2JavaMap.put("ARABIC",      "ISO8859_6");
+        aIANA2JavaMap.put("CSISOLATINARABIC",      "ISO8859_6");
+
+        aIANA2JavaMap.put("ISO-8859-7",      "ISO8859_7");
+        aIANA2JavaMap.put("ISO-IR-126",      "ISO8859_7");
+        aIANA2JavaMap.put("ISO_8859-7",      "ISO8859_7");
+        aIANA2JavaMap.put("ELOT_928",      "ISO8859_7");
+        aIANA2JavaMap.put("ECMA-118",      "ISO8859_7");
+        aIANA2JavaMap.put("GREEK",      "ISO8859_7");
+        aIANA2JavaMap.put("CSISOLATINGREEK",      "ISO8859_7");
+        aIANA2JavaMap.put("GREEK8",      "ISO8859_7");
+
+        aIANA2JavaMap.put("ISO-8859-8",      "ISO8859_8");
+        aIANA2JavaMap.put("ISO-8859-8-I",      "ISO8859_8"); // added since this encoding only differs w.r.t. presentation
+        aIANA2JavaMap.put("ISO-IR-138",      "ISO8859_8");
+        aIANA2JavaMap.put("ISO_8859-8",      "ISO8859_8");
+        aIANA2JavaMap.put("HEBREW",      "ISO8859_8");
+        aIANA2JavaMap.put("CSISOLATINHEBREW",      "ISO8859_8");
+
+        aIANA2JavaMap.put("ISO-8859-9",      "ISO8859_9");
+        aIANA2JavaMap.put("ISO-IR-148",      "ISO8859_9");
+        aIANA2JavaMap.put("ISO_8859-9",      "ISO8859_9");
+        aIANA2JavaMap.put("LATIN5",      "ISO8859_9");
+        aIANA2JavaMap.put("CSISOLATIN5",      "ISO8859_9");
+        aIANA2JavaMap.put("L5",      "ISO8859_9");
+
+        aIANA2JavaMap.put("ISO-8859-13",      "ISO8859_13");
+
+        aIANA2JavaMap.put("ISO-8859-15",      "ISO8859_15_FDIS");
+        aIANA2JavaMap.put("ISO_8859-15",      "ISO8859_15_FDIS");
+        aIANA2JavaMap.put("LATIN-9",          "ISO8859_15_FDIS");
+
+        aIANA2JavaMap.put("KOI8-R",          "KOI8_R");
+        aIANA2JavaMap.put("CSKOI8R",          "KOI8_R");
+        aIANA2JavaMap.put("US-ASCII",        "ASCII");
+        aIANA2JavaMap.put("ISO-IR-6",        "ASCII");
+        aIANA2JavaMap.put("ANSI_X3.4-1968",        "ASCII");
+        aIANA2JavaMap.put("ANSI_X3.4-1986",        "ASCII");
+        aIANA2JavaMap.put("ISO_646.IRV:1991",        "ASCII");
+        aIANA2JavaMap.put("ASCII",        "ASCII");
+        aIANA2JavaMap.put("CSASCII",        "ASCII");
+        aIANA2JavaMap.put("ISO646-US",        "ASCII");
+        aIANA2JavaMap.put("US",        "ASCII");
+        aIANA2JavaMap.put("IBM367",        "ASCII");
+        aIANA2JavaMap.put("CP367",        "ASCII");
+        aIANA2JavaMap.put("UTF-8",           "UTF8");
+        aIANA2JavaMap.put("UTF-16",           "UTF-16");
+        aIANA2JavaMap.put("UTF-16BE",           "UnicodeBig");
+        aIANA2JavaMap.put("UTF-16LE",           "UnicodeLittle");
 
         // support for 1047, as proposed to be added to the
         // IANA registry in
         // http://lists.w3.org/Archives/Public/ietf-charset/2002JulSep/0049.html
-        fIANA2JavaMap.put("IBM-1047",    "Cp1047");
-        fIANA2JavaMap.put("IBM1047",    "Cp1047");
-        fIANA2JavaMap.put("CP1047",    "Cp1047");
+        aIANA2JavaMap.put("IBM-1047",    "Cp1047");
+        aIANA2JavaMap.put("IBM1047",    "Cp1047");
+        aIANA2JavaMap.put("CP1047",    "Cp1047");
 
         // Adding new aliases as proposed in
         // http://lists.w3.org/Archives/Public/ietf-charset/2002JulSep/0058.html
-        fIANA2JavaMap.put("IBM-37",    "CP037");
-        fIANA2JavaMap.put("IBM-273",    "CP273");
-        fIANA2JavaMap.put("IBM-277",    "CP277");
-        fIANA2JavaMap.put("IBM-278",    "CP278");
-        fIANA2JavaMap.put("IBM-280",    "CP280");
-        fIANA2JavaMap.put("IBM-284",    "CP284");
-        fIANA2JavaMap.put("IBM-285",    "CP285");
-        fIANA2JavaMap.put("IBM-290",    "CP290");
-        fIANA2JavaMap.put("IBM-297",    "CP297");
-        fIANA2JavaMap.put("IBM-420",    "CP420");
-        fIANA2JavaMap.put("IBM-424",    "CP424");
-        fIANA2JavaMap.put("IBM-437",    "CP437");
-        fIANA2JavaMap.put("IBM-500",    "CP500");
-        fIANA2JavaMap.put("IBM-775",    "CP775");
-        fIANA2JavaMap.put("IBM-850",    "CP850");
-        fIANA2JavaMap.put("IBM-852",    "CP852");
-        fIANA2JavaMap.put("IBM-855",    "CP855");
-        fIANA2JavaMap.put("IBM-857",    "CP857");
-        fIANA2JavaMap.put("IBM-858",    "CP858");
-        fIANA2JavaMap.put("IBM-860",    "CP860");
-        fIANA2JavaMap.put("IBM-861",    "CP861");
-        fIANA2JavaMap.put("IBM-862",    "CP862");
-        fIANA2JavaMap.put("IBM-863",    "CP863");
-        fIANA2JavaMap.put("IBM-864",    "CP864");
-        fIANA2JavaMap.put("IBM-865",    "CP865");
-        fIANA2JavaMap.put("IBM-866",    "CP866");
-        fIANA2JavaMap.put("IBM-868",    "CP868");
-        fIANA2JavaMap.put("IBM-869",    "CP869");
-        fIANA2JavaMap.put("IBM-870",    "CP870");
-        fIANA2JavaMap.put("IBM-871",    "CP871");
-        fIANA2JavaMap.put("IBM-918",    "CP918");
-        fIANA2JavaMap.put("IBM-924",    "CP924");
-        fIANA2JavaMap.put("IBM-1026",    "CP1026");
-        fIANA2JavaMap.put("IBM-1140",    "Cp1140");
-        fIANA2JavaMap.put("IBM-1141",    "Cp1141");
-        fIANA2JavaMap.put("IBM-1142",    "Cp1142");
-        fIANA2JavaMap.put("IBM-1143",    "Cp1143");
-        fIANA2JavaMap.put("IBM-1144",    "Cp1144");
-        fIANA2JavaMap.put("IBM-1145",    "Cp1145");
-        fIANA2JavaMap.put("IBM-1146",    "Cp1146");
-        fIANA2JavaMap.put("IBM-1147",    "Cp1147");
-        fIANA2JavaMap.put("IBM-1148",    "Cp1148");
-        fIANA2JavaMap.put("IBM-1149",    "Cp1149");
-        fIANA2JavaMap.put("IBM-819",      "ISO8859_1");
-        fIANA2JavaMap.put("IBM-367",        "ASCII");
+        aIANA2JavaMap.put("IBM-37",    "CP037");
+        aIANA2JavaMap.put("IBM-273",    "CP273");
+        aIANA2JavaMap.put("IBM-277",    "CP277");
+        aIANA2JavaMap.put("IBM-278",    "CP278");
+        aIANA2JavaMap.put("IBM-280",    "CP280");
+        aIANA2JavaMap.put("IBM-284",    "CP284");
+        aIANA2JavaMap.put("IBM-285",    "CP285");
+        aIANA2JavaMap.put("IBM-290",    "CP290");
+        aIANA2JavaMap.put("IBM-297",    "CP297");
+        aIANA2JavaMap.put("IBM-420",    "CP420");
+        aIANA2JavaMap.put("IBM-424",    "CP424");
+        aIANA2JavaMap.put("IBM-437",    "CP437");
+        aIANA2JavaMap.put("IBM-500",    "CP500");
+        aIANA2JavaMap.put("IBM-775",    "CP775");
+        aIANA2JavaMap.put("IBM-850",    "CP850");
+        aIANA2JavaMap.put("IBM-852",    "CP852");
+        aIANA2JavaMap.put("IBM-855",    "CP855");
+        aIANA2JavaMap.put("IBM-857",    "CP857");
+        aIANA2JavaMap.put("IBM-858",    "CP858");
+        aIANA2JavaMap.put("IBM-860",    "CP860");
+        aIANA2JavaMap.put("IBM-861",    "CP861");
+        aIANA2JavaMap.put("IBM-862",    "CP862");
+        aIANA2JavaMap.put("IBM-863",    "CP863");
+        aIANA2JavaMap.put("IBM-864",    "CP864");
+        aIANA2JavaMap.put("IBM-865",    "CP865");
+        aIANA2JavaMap.put("IBM-866",    "CP866");
+        aIANA2JavaMap.put("IBM-868",    "CP868");
+        aIANA2JavaMap.put("IBM-869",    "CP869");
+        aIANA2JavaMap.put("IBM-870",    "CP870");
+        aIANA2JavaMap.put("IBM-871",    "CP871");
+        aIANA2JavaMap.put("IBM-918",    "CP918");
+        aIANA2JavaMap.put("IBM-924",    "CP924");
+        aIANA2JavaMap.put("IBM-1026",    "CP1026");
+        aIANA2JavaMap.put("IBM-1140",    "Cp1140");
+        aIANA2JavaMap.put("IBM-1141",    "Cp1141");
+        aIANA2JavaMap.put("IBM-1142",    "Cp1142");
+        aIANA2JavaMap.put("IBM-1143",    "Cp1143");
+        aIANA2JavaMap.put("IBM-1144",    "Cp1144");
+        aIANA2JavaMap.put("IBM-1145",    "Cp1145");
+        aIANA2JavaMap.put("IBM-1146",    "Cp1146");
+        aIANA2JavaMap.put("IBM-1147",    "Cp1147");
+        aIANA2JavaMap.put("IBM-1148",    "Cp1148");
+        aIANA2JavaMap.put("IBM-1149",    "Cp1149");
+        aIANA2JavaMap.put("IBM-819",      "ISO8859_1");
+        aIANA2JavaMap.put("IBM-367",        "ASCII");
 
+        fIANA2JavaMap = Collections.unmodifiableMap(aIANA2JavaMap);
         // REVISIT:
         //   j:CNS11643 -> EUC-TW?
         //   ISO-2022-CN? ISO-2022-CN-EXT?
 
         // add Java to IANA encoding mappings
-        //fJava2IANAMap.put("8859_1",    "US-ASCII"); // ?
-        fJava2IANAMap.put("ISO8859_1",    "ISO-8859-1");
-        fJava2IANAMap.put("ISO8859_2",    "ISO-8859-2");
-        fJava2IANAMap.put("ISO8859_3",    "ISO-8859-3");
-        fJava2IANAMap.put("ISO8859_4",    "ISO-8859-4");
-        fJava2IANAMap.put("ISO8859_5",    "ISO-8859-5");
-        fJava2IANAMap.put("ISO8859_6",    "ISO-8859-6");
-        fJava2IANAMap.put("ISO8859_7",    "ISO-8859-7");
-        fJava2IANAMap.put("ISO8859_8",    "ISO-8859-8");
-        fJava2IANAMap.put("ISO8859_9",    "ISO-8859-9");
-        fJava2IANAMap.put("ISO8859_13",    "ISO-8859-13");
-        fJava2IANAMap.put("ISO8859_15",    "ISO-8859-15");
-        fJava2IANAMap.put("ISO8859_15_FDIS",    "ISO-8859-15");
-        fJava2IANAMap.put("Big5",      "BIG5");
-        fJava2IANAMap.put("CP037",     "EBCDIC-CP-US");
-        fJava2IANAMap.put("CP273",     "IBM273");
-        fJava2IANAMap.put("CP277",     "EBCDIC-CP-DK");
-        fJava2IANAMap.put("CP278",     "EBCDIC-CP-FI");
-        fJava2IANAMap.put("CP280",     "EBCDIC-CP-IT");
-        fJava2IANAMap.put("CP284",     "EBCDIC-CP-ES");
-        fJava2IANAMap.put("CP285",     "EBCDIC-CP-GB");
-        fJava2IANAMap.put("CP290",     "EBCDIC-JP-KANA");
-        fJava2IANAMap.put("CP297",     "EBCDIC-CP-FR");
-        fJava2IANAMap.put("CP420",     "EBCDIC-CP-AR1");
-        fJava2IANAMap.put("CP424",     "EBCDIC-CP-HE");
-        fJava2IANAMap.put("CP437",     "IBM437");
-        fJava2IANAMap.put("CP500",     "EBCDIC-CP-CH");
-        fJava2IANAMap.put("CP775",     "IBM775");
-        fJava2IANAMap.put("CP850",     "IBM850");
-        fJava2IANAMap.put("CP852",     "IBM852");
-        fJava2IANAMap.put("CP855",     "IBM855");
-        fJava2IANAMap.put("CP857",     "IBM857");
-        fJava2IANAMap.put("CP858",     "IBM00858");
-        fJava2IANAMap.put("CP860",     "IBM860");
-        fJava2IANAMap.put("CP861",     "IBM861");
-        fJava2IANAMap.put("CP862",     "IBM862");
-        fJava2IANAMap.put("CP863",     "IBM863");
-        fJava2IANAMap.put("CP864",     "IBM864");
-        fJava2IANAMap.put("CP865",     "IBM865");
-        fJava2IANAMap.put("CP866",     "IBM866");
-        fJava2IANAMap.put("CP868",     "IBM868");
-        fJava2IANAMap.put("CP869",     "IBM869");
-        fJava2IANAMap.put("CP870",     "EBCDIC-CP-ROECE");
-        fJava2IANAMap.put("CP871",     "EBCDIC-CP-IS");
-        fJava2IANAMap.put("CP918",     "EBCDIC-CP-AR2");
-        fJava2IANAMap.put("CP924",     "IBM00924");
-        fJava2IANAMap.put("CP1026",     "IBM1026");
-        fJava2IANAMap.put("Cp01140",     "IBM01140");
-        fJava2IANAMap.put("Cp01141",     "IBM01141");
-        fJava2IANAMap.put("Cp01142",     "IBM01142");
-        fJava2IANAMap.put("Cp01143",     "IBM01143");
-        fJava2IANAMap.put("Cp01144",     "IBM01144");
-        fJava2IANAMap.put("Cp01145",     "IBM01145");
-        fJava2IANAMap.put("Cp01146",     "IBM01146");
-        fJava2IANAMap.put("Cp01147",     "IBM01147");
-        fJava2IANAMap.put("Cp01148",     "IBM01148");
-        fJava2IANAMap.put("Cp01149",     "IBM01149");
-        fJava2IANAMap.put("EUCJIS",    "EUC-JP");
-        fJava2IANAMap.put("KS_C_5601-1987",          "KS_C_5601-1987");
-        fJava2IANAMap.put("GB2312",    "GB2312");
-        fJava2IANAMap.put("ISO2022KR", "ISO-2022-KR");
-        fJava2IANAMap.put("ISO2022CN", "ISO-2022-CN");
-        fJava2IANAMap.put("JIS",       "ISO-2022-JP");
-        fJava2IANAMap.put("KOI8_R",    "KOI8-R");
-        fJava2IANAMap.put("KSC5601",   "EUC-KR");
-        fJava2IANAMap.put("GB18030",      "GB18030");
-        fJava2IANAMap.put("GBK",       "GBK");
-        fJava2IANAMap.put("SJIS",      "SHIFT_JIS");
-        fJava2IANAMap.put("MS932",      "WINDOWS-31J");
-        fJava2IANAMap.put("UTF8",      "UTF-8");
-        fJava2IANAMap.put("Unicode",   "UTF-16");
-        fJava2IANAMap.put("UnicodeBig",   "UTF-16BE");
-        fJava2IANAMap.put("UnicodeLittle",   "UTF-16LE");
-        fJava2IANAMap.put("JIS0201",  "X0201");
-        fJava2IANAMap.put("JIS0208",  "X0208");
-        fJava2IANAMap.put("JIS0212",  "ISO-IR-159");
+        //aJava2IANAMap.put("8859_1",    "US-ASCII"); // ?
+        aJava2IANAMap.put("ISO8859_1",    "ISO-8859-1");
+        aJava2IANAMap.put("ISO8859_2",    "ISO-8859-2");
+        aJava2IANAMap.put("ISO8859_3",    "ISO-8859-3");
+        aJava2IANAMap.put("ISO8859_4",    "ISO-8859-4");
+        aJava2IANAMap.put("ISO8859_5",    "ISO-8859-5");
+        aJava2IANAMap.put("ISO8859_6",    "ISO-8859-6");
+        aJava2IANAMap.put("ISO8859_7",    "ISO-8859-7");
+        aJava2IANAMap.put("ISO8859_8",    "ISO-8859-8");
+        aJava2IANAMap.put("ISO8859_9",    "ISO-8859-9");
+        aJava2IANAMap.put("ISO8859_13",    "ISO-8859-13");
+        aJava2IANAMap.put("ISO8859_15",    "ISO-8859-15");
+        aJava2IANAMap.put("ISO8859_15_FDIS",    "ISO-8859-15");
+        aJava2IANAMap.put("Big5",      "BIG5");
+        aJava2IANAMap.put("CP037",     "EBCDIC-CP-US");
+        aJava2IANAMap.put("CP273",     "IBM273");
+        aJava2IANAMap.put("CP277",     "EBCDIC-CP-DK");
+        aJava2IANAMap.put("CP278",     "EBCDIC-CP-FI");
+        aJava2IANAMap.put("CP280",     "EBCDIC-CP-IT");
+        aJava2IANAMap.put("CP284",     "EBCDIC-CP-ES");
+        aJava2IANAMap.put("CP285",     "EBCDIC-CP-GB");
+        aJava2IANAMap.put("CP290",     "EBCDIC-JP-KANA");
+        aJava2IANAMap.put("CP297",     "EBCDIC-CP-FR");
+        aJava2IANAMap.put("CP420",     "EBCDIC-CP-AR1");
+        aJava2IANAMap.put("CP424",     "EBCDIC-CP-HE");
+        aJava2IANAMap.put("CP437",     "IBM437");
+        aJava2IANAMap.put("CP500",     "EBCDIC-CP-CH");
+        aJava2IANAMap.put("CP775",     "IBM775");
+        aJava2IANAMap.put("CP850",     "IBM850");
+        aJava2IANAMap.put("CP852",     "IBM852");
+        aJava2IANAMap.put("CP855",     "IBM855");
+        aJava2IANAMap.put("CP857",     "IBM857");
+        aJava2IANAMap.put("CP858",     "IBM00858");
+        aJava2IANAMap.put("CP860",     "IBM860");
+        aJava2IANAMap.put("CP861",     "IBM861");
+        aJava2IANAMap.put("CP862",     "IBM862");
+        aJava2IANAMap.put("CP863",     "IBM863");
+        aJava2IANAMap.put("CP864",     "IBM864");
+        aJava2IANAMap.put("CP865",     "IBM865");
+        aJava2IANAMap.put("CP866",     "IBM866");
+        aJava2IANAMap.put("CP868",     "IBM868");
+        aJava2IANAMap.put("CP869",     "IBM869");
+        aJava2IANAMap.put("CP870",     "EBCDIC-CP-ROECE");
+        aJava2IANAMap.put("CP871",     "EBCDIC-CP-IS");
+        aJava2IANAMap.put("CP918",     "EBCDIC-CP-AR2");
+        aJava2IANAMap.put("CP924",     "IBM00924");
+        aJava2IANAMap.put("CP1026",     "IBM1026");
+        aJava2IANAMap.put("CP1140",     "IBM01140");
+        aJava2IANAMap.put("CP1141",     "IBM01141");
+        aJava2IANAMap.put("CP1142",     "IBM01142");
+        aJava2IANAMap.put("CP1143",     "IBM01143");
+        aJava2IANAMap.put("CP1144",     "IBM01144");
+        aJava2IANAMap.put("CP1145",     "IBM01145");
+        aJava2IANAMap.put("CP1146",     "IBM01146");
+        aJava2IANAMap.put("CP1147",     "IBM01147");
+        aJava2IANAMap.put("CP1148",     "IBM01148");
+        aJava2IANAMap.put("CP1149",     "IBM01149");
+        aJava2IANAMap.put("EUCJIS",    "EUC-JP");
+        aJava2IANAMap.put("KS_C_5601-1987",          "KS_C_5601-1987");
+        aJava2IANAMap.put("GB2312",    "GB2312");
+        aJava2IANAMap.put("ISO2022KR", "ISO-2022-KR");
+        aJava2IANAMap.put("ISO2022CN", "ISO-2022-CN");
+        aJava2IANAMap.put("JIS",       "ISO-2022-JP");
+        aJava2IANAMap.put("KOI8_R",    "KOI8-R");
+        aJava2IANAMap.put("KSC5601",   "EUC-KR");
+        aJava2IANAMap.put("GB18030",      "GB18030");
+        aJava2IANAMap.put("GBK",       "GBK");
+        aJava2IANAMap.put("SJIS",      "SHIFT_JIS");
+        aJava2IANAMap.put("MS932",      "WINDOWS-31J");
+        aJava2IANAMap.put("UTF8",      "UTF-8");
+        aJava2IANAMap.put("Unicode",   "UTF-16");
+        aJava2IANAMap.put("UnicodeBig",   "UTF-16BE");
+        aJava2IANAMap.put("UnicodeLittle",   "UTF-16LE");
+        aJava2IANAMap.put("JIS0201",  "X0201");
+        aJava2IANAMap.put("JIS0208",  "X0208");
+        aJava2IANAMap.put("JIS0212",  "ISO-IR-159");
 
         // proposed addition (see above for details):
-        fJava2IANAMap.put("CP1047",    "IBM1047");
+        aJava2IANAMap.put("CP1047",    "IBM1047");
 
+        fJava2IANAMap = Collections.unmodifiableMap(aIANA2JavaMap);
     } // <clinit>()
 
     //
@@ -954,77 +960,22 @@ public class EncodingMap {
     //
 
     /**
-     * Adds an IANA to Java encoding name mapping.
-     *
-     * @param ianaEncoding The IANA encoding name.
-     * @param javaEncoding The Java encoding name.
-     *
-     * @deprecated Use of this method is not recommended. Its
-     * effect is JVM wide and may cause unforeseen behaviour
-     * for other applications running in the system.
-     */
-    public static void putIANA2JavaMapping(String ianaEncoding,
-                                           String javaEncoding) {
-        fIANA2JavaMap.put(ianaEncoding, javaEncoding);
-    } // putIANA2JavaMapping(String,String)
-
-    /**
      * Returns the Java encoding name for the specified IANA encoding name.
      *
      * @param ianaEncoding The IANA encoding name.
      */
     public static String getIANA2JavaMapping(String ianaEncoding) {
-        return (String)fIANA2JavaMap.get(ianaEncoding);
+        return fIANA2JavaMap.get(ianaEncoding);
     } // getIANA2JavaMapping(String):String
 
     /**
-     * Removes an IANA to Java encoding name mapping.
-     *
-     * @param ianaEncoding The IANA encoding name.
-     *
-     * @deprecated Use of this method is not recommended. Its
-     * effect is JVM wide and may cause unforeseen behaviour
-     * for other applications running in the system.
-     */
-    public static String removeIANA2JavaMapping(String ianaEncoding) {
-        return (String)fIANA2JavaMap.remove(ianaEncoding);
-    } // removeIANA2JavaMapping(String):String
-
-    /**
-     * Adds a Java to IANA encoding name mapping.
-     *
-     * @param javaEncoding The Java encoding name.
-     * @param ianaEncoding The IANA encoding name.
-     *
-     * @deprecated Use of this method is not recommended. Its
-     * effect is JVM wide and may cause unforeseen behaviour
-     * for other applications running in the system.
-     */
-    public static void putJava2IANAMapping(String javaEncoding,
-                                           String ianaEncoding) {
-        fJava2IANAMap.put(javaEncoding, ianaEncoding);
-    } // putJava2IANAMapping(String,String)
-
-    /**
      * Returns the IANA encoding name for the specified Java encoding name.
      *
      * @param javaEncoding The Java encoding name.
      */
     public static String getJava2IANAMapping(String javaEncoding) {
-        return (String)fJava2IANAMap.get(javaEncoding);
+        return fJava2IANAMap.get(javaEncoding);
     } // getJava2IANAMapping(String):String
 
-    /**
-     * Removes a Java to IANA encoding name mapping.
-     *
-     * @param javaEncoding The Java encoding name.
-     *
-     * @deprecated Use of this method is not recommended. Its
-     * effect is JVM wide and may cause unforeseen behaviour
-     * for other applications running in the system.
-     */
-    public static String removeJava2IANAMapping(String javaEncoding) {
-        return (String)fJava2IANAMap.remove(javaEncoding);
-    } // removeJava2IANAMapping
 
 } // class EncodingMap
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/SymbolHash.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/SymbolHash.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/SymbolHash.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2001, 2002,2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -37,25 +37,40 @@ public class SymbolHash {
     //
 
     /** Default table size. */
-    protected int fTableSize = 101;
+    protected static final int TABLE_SIZE = 101;
+
+    /** Maximum hash collisions per bucket. */
+    protected static final int MAX_HASH_COLLISIONS = 40;
+
+    protected static final int MULTIPLIERS_SIZE = 1 << 5;
+    protected static final int MULTIPLIERS_MASK = MULTIPLIERS_SIZE - 1;
 
     //
     // Data
     //
 
+    /** Actual table size **/
+    protected int fTableSize;
+
     /** Buckets. */
     protected Entry[] fBuckets;
 
     /** Number of elements. */
     protected int fNum = 0;
 
+    /**
+     * Array of randomly selected hash function multipliers or <code>null</code>
+     * if the default String.hashCode() function should be used.
+     */
+    protected int[] fHashMultipliers;
+
     //
     // Constructors
     //
 
     /** Constructs a key table with the default size. */
     public SymbolHash() {
-        fBuckets = new Entry[fTableSize];
+        this(TABLE_SIZE);
     }
 
     /**
@@ -81,19 +96,37 @@ public class SymbolHash {
      * @param value
      */
     public void put(Object key, Object value) {
-        int bucket = (key.hashCode() & 0x7FFFFFFF) % fTableSize;
-        Entry entry = search(key, bucket);
 
-        // replace old value
-        if (entry != null) {
-            entry.value = value;
+        // search for identical key
+        int collisionCount = 0;
+        final int hash = hash(key);
+        int bucket = hash % fTableSize;
+        for (Entry entry = fBuckets[bucket]; entry != null; entry = entry.next) {
+            if (key.equals(entry.key)) {
+                // replace old value
+                entry.value = value;
+                return;
+            }
+            ++collisionCount;
         }
-        // create new entry
-        else {
-            entry = new Entry(key, value, fBuckets[bucket]);
-            fBuckets[bucket] = entry;
-            fNum++;
+
+        if (fNum >= fTableSize) {
+            // Rehash the table if the number of entries
+            // would exceed the number of buckets.
+            rehash();
+            bucket = hash % fTableSize;
+        }
+        else if (collisionCount >= MAX_HASH_COLLISIONS && key instanceof String) {
+            // Select a new hash function and rehash the table if
+            // MAX_HASH_COLLISIONS is exceeded.
+            rebalance();
+            bucket = hash(key) % fTableSize;
         }
+
+        // create new entry
+        Entry entry = new Entry(key, value, fBuckets[bucket]);
+        fBuckets[bucket] = entry;
+        ++fNum;
     }
 
     /**
@@ -103,7 +136,7 @@ public class SymbolHash {
      * @return the value associated with the given key.
      */
     public Object get(Object key) {
-        int bucket = (key.hashCode() & 0x7FFFFFFF) % fTableSize;
+        int bucket = hash(key) % fTableSize;
         Entry entry = search(key, bucket);
         if (entry != null) {
             return entry.value;
@@ -158,15 +191,17 @@ public class SymbolHash {
     public SymbolHash makeClone() {
         SymbolHash newTable = new SymbolHash(fTableSize);
         newTable.fNum = fNum;
+        newTable.fHashMultipliers = fHashMultipliers != null ? (int[]) fHashMultipliers.clone() : null;
         for (int i = 0; i < fTableSize; i++) {
-            if (fBuckets[i] != null)
+            if (fBuckets[i] != null) {
                 newTable.fBuckets[i] = fBuckets[i].makeClone();
+            }
         }
         return newTable;
     }
 
     /**
-     * Remove all key/value assocaition. This tries to save a bit of GC'ing
+     * Remove all key/value association. This tries to save a bit of GC'ing
      * by at least keeping the fBuckets array around.
      */
     public void clear() {
@@ -174,6 +209,7 @@ public class SymbolHash {
             fBuckets[i] = null;
         }
         fNum = 0;
+        fHashMultipliers = null;
     } // clear():  void
 
     protected Entry search(Object key, int bucket) {
@@ -185,6 +221,74 @@ public class SymbolHash {
         return null;
     }
 
+    /**
+     * Returns a hashcode value for the specified key.
+     *
+     * @param key The key to hash.
+     */
+    protected int hash(Object key) {
+        if (fHashMultipliers == null || !(key instanceof String)) {
+            return key.hashCode() & 0x7FFFFFFF;
+        }
+        return hash0((String) key);
+    } // hash(Object):int
+
+    private int hash0(String symbol) {
+        int code = 0;
+        final int length = symbol.length();
+        final int[] multipliers = fHashMultipliers;
+        for (int i = 0; i < length; ++i) {
+            code = code * multipliers[i & MULTIPLIERS_MASK] + symbol.charAt(i);
+        }
+        return code & 0x7FFFFFFF;
+    } // hash0(String):int
+
+    /**
+     * Increases the capacity of and internally reorganizes this
+     * SymbolHash, in order to accommodate and access its entries more
+     * efficiently.  This method is called automatically when the
+     * number of keys in the SymbolHash exceeds its number of buckets.
+     */
+    protected void rehash() {
+        rehashCommon((fBuckets.length << 1) + 1);
+    }
+
+    /**
+     * Randomly selects a new hash function and reorganizes this SymbolHash
+     * in order to more evenly distribute its entries across the table. This
+     * method is called automatically when the number keys in one of the
+     * SymbolHash's buckets exceeds MAX_HASH_COLLISIONS.
+     */
+    protected void rebalance() {
+        if (fHashMultipliers == null) {
+            fHashMultipliers = new int[MULTIPLIERS_SIZE];
+        }
+        PrimeNumberSequenceGenerator.generateSequence(fHashMultipliers);
+        rehashCommon(fBuckets.length);
+    }
+
+    private void rehashCommon(final int newCapacity) {
+
+        final int oldCapacity = fBuckets.length;
+        final Entry[] oldTable = fBuckets;
+
+        final Entry[] newTable = new Entry[newCapacity];
+
+        fBuckets = newTable;
+        fTableSize = fBuckets.length;
+
+        for (int i = oldCapacity; i-- > 0;) {
+            for (Entry old = oldTable[i]; old != null; ) {
+                Entry e = old;
+                old = old.next;
+
+                int index = hash(e.key) % newCapacity;
+                e.next = newTable[index];
+                newTable[index] = e;
+            }
+        }
+    }
+
     //
     // Classes
     //
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/SymbolTable.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/SymbolTable.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/SymbolTable.java
@@ -1,13 +1,13 @@
 /*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
-
 /*
- * Copyright 2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -55,28 +55,99 @@ public class SymbolTable {
     //
 
     /** Default table size. */
-    protected static final int TABLE_SIZE = 173;
+    protected static final int TABLE_SIZE = 101;
+
+    /** Maximum hash collisions per bucket for a table with load factor == 1. */
+    protected static final int MAX_HASH_COLLISIONS = 40;
 
+    protected static final int MULTIPLIERS_SIZE = 1 << 5;
+    protected static final int MULTIPLIERS_MASK = MULTIPLIERS_SIZE - 1;
+
+    //
+    // Data
+    //
 
     /** Buckets. */
     protected Entry[] fBuckets = null;
 
-    // actual table size
+    /** actual table size */
     protected int fTableSize;
 
+    /** The total number of entries in the hash table. */
+    protected transient int fCount;
+
+    /** The table is rehashed when its size exceeds this threshold.  (The
+     * value of this field is (int)(capacity * loadFactor).) */
+    protected int fThreshold;
+
+    /** The load factor for the SymbolTable. */
+    protected float fLoadFactor;
+
+    /**
+     * A new hash function is selected and the table is rehashed when
+     * the number of keys in the bucket exceeds this threshold.
+     */
+    protected final int fCollisionThreshold;
+
+    /**
+     * Array of randomly selected hash function multipliers or <code>null</code>
+     * if the default String.hashCode() function should be used.
+     */
+    protected int[] fHashMultipliers;
+
     //
     // Constructors
     //
 
-    /** Constructs a symbol table with a default number of buckets. */
-    public SymbolTable() {
-        this(TABLE_SIZE);
-    }
+    /**
+     * Constructs a new, empty SymbolTable with the specified initial
+     * capacity and the specified load factor.
+     *
+     * @param      initialCapacity   the initial capacity of the SymbolTable.
+     * @param      loadFactor        the load factor of the SymbolTable.
+     * @throws     IllegalArgumentException  if the initial capacity is less
+     *             than zero, or if the load factor is nonpositive.
+     */
+    public SymbolTable(int initialCapacity, float loadFactor) {
+
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
+        }
+
+        if (loadFactor <= 0 || Float.isNaN(loadFactor)) {
+            throw new IllegalArgumentException("Illegal Load: " + loadFactor);
+        }
+
+        if (initialCapacity == 0) {
+            initialCapacity = 1;
+        }
 
-    /** Constructs a symbol table with a specified number of buckets. */
-    public SymbolTable(int tableSize) {
-        fTableSize = tableSize;
+        fLoadFactor = loadFactor;
+        fTableSize = initialCapacity;
         fBuckets = new Entry[fTableSize];
+        fThreshold = (int)(fTableSize * loadFactor);
+        fCollisionThreshold = (int)(MAX_HASH_COLLISIONS * loadFactor);
+        fCount = 0;
+    }
+
+    /**
+     * Constructs a new, empty SymbolTable with the specified initial capacity
+     * and default load factor, which is <tt>0.75</tt>.
+     *
+     * @param     initialCapacity   the initial capacity of the hashtable.
+     * @throws    IllegalArgumentException if the initial capacity is less
+     *            than zero.
+     */
+    public SymbolTable(int initialCapacity) {
+        this(initialCapacity, 0.75f);
+    }
+
+    /**
+     * Constructs a new, empty SymbolTable with a default initial capacity (101)
+     * and load factor, which is <tt>0.75</tt>.
+     */
+    public SymbolTable() {
+        this(TABLE_SIZE, 0.75f);
     }
 
     //
@@ -94,36 +165,39 @@ public class SymbolTable {
     public String addSymbol(String symbol) {
 
         // search for identical symbol
-        final int hash = hash(symbol);
-        final int bucket = hash % fTableSize;
-        final int length = symbol.length();
-        OUTER: for (Entry entry = fBuckets[bucket]; entry != null; entry = entry.next) {
-            if (length == entry.characters.length && hash == entry.hashCode) {
-                if(symbol.regionMatches(0,entry.symbol,0,length)){
-                    return entry.symbol;
-                }
-                else{
-                    continue OUTER;
-                }
-                /**
-                for (int i = 0; i < length; i++) {
-                    if (symbol.charAt(i) != entry.characters[i]) {
-                        continue OUTER;
-                    }
-                }
-                symbolAsArray = entry.characters;
+        int collisionCount = 0;
+        int bucket = hash(symbol) % fTableSize;
+        for (Entry entry = fBuckets[bucket]; entry != null; entry = entry.next) {
+            if (entry.symbol.equals(symbol)) {
                 return entry.symbol;
-                 */
             }
+            ++collisionCount;
+        }
+        return addSymbol0(symbol, bucket, collisionCount);
+
+    } // addSymbol(String):String
+
+    private String addSymbol0(String symbol, int bucket, int collisionCount) {
+
+        if (fCount >= fThreshold) {
+            // Rehash the table if the threshold is exceeded
+            rehash();
+            bucket = hash(symbol) % fTableSize;
+        }
+        else if (collisionCount >= fCollisionThreshold) {
+            // Select a new hash function and rehash the table if
+            // the collision threshold is exceeded.
+            rebalance();
+            bucket = hash(symbol) % fTableSize;
         }
 
         // create new entry
         Entry entry = new Entry(symbol, fBuckets[bucket]);
-        entry.hashCode = hash;
         fBuckets[bucket] = entry;
+        ++fCount;
         return entry.symbol;
 
-    } // addSymbol(String):String
+    } // addSymbol0(String,int,int):String
 
     /**
      * Adds the specified symbol to the symbol table and returns a
@@ -136,27 +210,47 @@ public class SymbolTable {
      * @param length The length of the new symbol in the buffer.
      */
     public String addSymbol(char[] buffer, int offset, int length) {
+
         // search for identical symbol
-        int hash = hash(buffer, offset, length);
-        int bucket = hash % fTableSize;
+        int collisionCount = 0;
+        int bucket = hash(buffer, offset, length) % fTableSize;
         OUTER: for (Entry entry = fBuckets[bucket]; entry != null; entry = entry.next) {
-            if (length == entry.characters.length && hash ==entry.hashCode) {
+            if (length == entry.characters.length) {
                 for (int i = 0; i < length; i++) {
                     if (buffer[offset + i] != entry.characters[i]) {
+                        ++collisionCount;
                         continue OUTER;
                     }
                 }
                 return entry.symbol;
             }
+            ++collisionCount;
+        }
+        return addSymbol0(buffer, offset, length, bucket, collisionCount);
+
+    } // addSymbol(char[],int,int):String
+
+    private String addSymbol0(char[] buffer, int offset, int length, int bucket, int collisionCount) {
+
+        if (fCount >= fThreshold) {
+            // Rehash the table if the threshold is exceeded
+            rehash();
+            bucket = hash(buffer, offset, length) % fTableSize;
+        }
+        else if (collisionCount >= fCollisionThreshold) {
+            // Select a new hash function and rehash the table if
+            // the collision threshold is exceeded.
+            rebalance();
+            bucket = hash(buffer, offset, length) % fTableSize;
         }
 
         // add new entry
         Entry entry = new Entry(buffer, offset, length, fBuckets[bucket]);
         fBuckets[bucket] = entry;
-        entry.hashCode = hash;
+        ++fCount;
         return entry.symbol;
 
-    } // addSymbol(char[],int,int):String
+    } // addSymbol0(char[],int,int,int,int):String
 
     /**
      * Returns a hashcode value for the specified symbol. The value
@@ -167,15 +261,21 @@ public class SymbolTable {
      * @param symbol The symbol to hash.
      */
     public int hash(String symbol) {
+        if (fHashMultipliers == null) {
+            return symbol.hashCode() & 0x7FFFFFFF;
+        }
+        return hash0(symbol);
+    } // hash(String):int
 
+    private int hash0(String symbol) {
         int code = 0;
-        int length = symbol.length();
-        for (int i = 0; i < length; i++) {
-            code = code * 37 + symbol.charAt(i);
+        final int length = symbol.length();
+        final int[] multipliers = fHashMultipliers;
+        for (int i = 0; i < length; ++i) {
+            code = code * multipliers[i & MULTIPLIERS_MASK] + symbol.charAt(i);
         }
         return code & 0x7FFFFFFF;
-
-    } // hash(String):int
+    } // hash0(String):int
 
     /**
      * Returns a hashcode value for the specified symbol information.
@@ -189,14 +289,73 @@ public class SymbolTable {
      * @param length The length of the symbol.
      */
     public int hash(char[] buffer, int offset, int length) {
+        if (fHashMultipliers == null) {
+            int code = 0;
+            for (int i = 0; i < length; ++i) {
+                code = code * 31 + buffer[offset + i];
+            }
+            return code & 0x7FFFFFFF;
+        }
+        return hash0(buffer, offset, length);
+
+    } // hash(char[],int,int):int
 
+    private int hash0(char[] buffer, int offset, int length) {
         int code = 0;
-        for (int i = 0; i < length; i++) {
-            code = code * 37 + buffer[offset + i];
+        final int[] multipliers = fHashMultipliers;
+        for (int i = 0; i < length; ++i) {
+            code = code * multipliers[i & MULTIPLIERS_MASK] + buffer[offset + i];
         }
         return code & 0x7FFFFFFF;
+    } // hash0(char[],int,int):int
 
-    } // hash(char[],int,int):int
+    /**
+     * Increases the capacity of and internally reorganizes this
+     * SymbolTable, in order to accommodate and access its entries more
+     * efficiently.  This method is called automatically when the
+     * number of keys in the SymbolTable exceeds this hashtable's capacity
+     * and load factor.
+     */
+    protected void rehash() {
+        rehashCommon(fBuckets.length * 2 + 1);
+    }
+
+    /**
+     * Randomly selects a new hash function and reorganizes this SymbolTable
+     * in order to more evenly distribute its entries across the table. This
+     * method is called automatically when the number keys in one of the
+     * SymbolTable's buckets exceeds the given collision threshold.
+     */
+    protected void rebalance() {
+        if (fHashMultipliers == null) {
+            fHashMultipliers = new int[MULTIPLIERS_SIZE];
+        }
+        PrimeNumberSequenceGenerator.generateSequence(fHashMultipliers);
+        rehashCommon(fBuckets.length);
+    }
+
+    private void rehashCommon(final int newCapacity) {
+
+        int oldCapacity = fBuckets.length;
+        Entry[] oldTable = fBuckets;
+
+        Entry[] newTable = new Entry[newCapacity];
+
+        fThreshold = (int)(newCapacity * fLoadFactor);
+        fBuckets = newTable;
+        fTableSize = fBuckets.length;
+
+        for (int i = oldCapacity ; i-- > 0 ;) {
+            for (Entry old = oldTable[i] ; old != null ; ) {
+                Entry e = old;
+                old = old.next;
+
+                int index = hash(e.symbol) % newCapacity;
+                e.next = newTable[index];
+                newTable[index] = e;
+            }
+        }
+    }
 
     /**
      * Returns true if the symbol table already contains the specified
@@ -207,25 +366,16 @@ public class SymbolTable {
     public boolean containsSymbol(String symbol) {
 
         // search for identical symbol
-        int hash = hash(symbol);
-        int bucket = hash % fTableSize;
+        int bucket = hash(symbol) % fTableSize;
         int length = symbol.length();
         OUTER: for (Entry entry = fBuckets[bucket]; entry != null; entry = entry.next) {
-            if (length == entry.characters.length && hash == entry.hashCode) {
-                if(symbol.regionMatches(0,entry.symbol,0,length)){
-                    return true;
-                }
-                else {
-                    continue OUTER;
-                }
-                /**
+            if (length == entry.characters.length) {
                 for (int i = 0; i < length; i++) {
                     if (symbol.charAt(i) != entry.characters[i]) {
                         continue OUTER;
                     }
                 }
-                 return true;
-                 */
+                return true;
             }
         }
 
@@ -244,10 +394,9 @@ public class SymbolTable {
     public boolean containsSymbol(char[] buffer, int offset, int length) {
 
         // search for identical symbol
-        int hash = hash(buffer, offset, length) ;
-        int bucket = hash % fTableSize;
+        int bucket = hash(buffer, offset, length) % fTableSize;
         OUTER: for (Entry entry = fBuckets[bucket]; entry != null; entry = entry.next) {
-            if (length == entry.characters.length && hash == entry.hashCode) {
+            if (length == entry.characters.length) {
                 for (int i = 0; i < length; i++) {
                     if (buffer[offset + i] != entry.characters[i]) {
                         continue OUTER;
@@ -261,7 +410,6 @@ public class SymbolTable {
 
     } // containsSymbol(char[],int,int):boolean
 
-
     //
     // Classes
     //
@@ -277,14 +425,13 @@ public class SymbolTable {
         //
 
         /** Symbol. */
-        public String symbol;
-        int hashCode = 0;
+        public final String symbol;
 
         /**
          * Symbol characters. This information is duplicated here for
          * comparison performance.
          */
-        public char[] characters;
+        public final char[] characters;
 
         /** The next entry. */
         public Entry next;
Index: openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/XMLAttributesImpl.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/XMLAttributesImpl.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xerces/internal/util/XMLAttributesImpl.java
@@ -1,71 +1,30 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * The Apache Software License, Version 1.1
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Xerces" and "Apache Software Foundation" must
- *    not be used to endorse or promote products derived from this
- *    software without prior written permission. For written
- *    permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    nor may "Apache" appear in their name, without prior written
- *    permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation and was
- * originally based on software copyright (c) 1999, International
- * Business Machines, Inc., http://www.apache.org.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 package com.sun.org.apache.xerces.internal.util;
 
-import com.sun.xml.internal.stream.XMLBufferListener;
 import com.sun.org.apache.xerces.internal.xni.Augmentations;
 import com.sun.org.apache.xerces.internal.xni.QName;
 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
 import com.sun.org.apache.xerces.internal.xni.XMLString;
+import com.sun.xml.internal.stream.XMLBufferListener;
 /**
  * The XMLAttributesImpl class is an implementation of the XMLAttributes
  * interface which defines a collection of attributes for an element.
@@ -95,6 +54,12 @@ implements XMLAttributes, XMLBufferListe
     /** Default table size. */
     protected static final int TABLE_SIZE = 101;
 
+    /** Maximum hash collisions per bucket. */
+    protected static final int MAX_HASH_COLLISIONS = 40;
+
+    protected static final int MULTIPLIERS_SIZE = 1 << 5;
+    protected static final int MULTIPLIERS_MASK = MULTIPLIERS_SIZE - 1;
+
     /**
      * Threshold at which an instance is treated
      * as a large attribute list.
@@ -126,7 +91,6 @@ implements XMLAttributes, XMLBufferListe
     protected Attribute[] fAttributes = new Attribute[4];
 
     /**
-     * Hashtable of attribute information.
      * Provides an alternate view of the attribute specification.
      */
     protected Attribute[] fAttributeTableView;
@@ -149,6 +113,12 @@ implements XMLAttributes, XMLBufferListe
      */
     protected boolean fIsTableViewConsistent;
 
+    /**
+     * Array of randomly selected hash function multipliers or <code>null</code>
+     * if the default String.hashCode() function should be used.
+     */
+    protected int[] fHashMultipliers;
+
     //
     // Constructors
     //
@@ -251,7 +221,8 @@ implements XMLAttributes, XMLBufferListe
              * the user of this class adds attributes, removes them, and
              * then adds more.
              */
-            if (!fIsTableViewConsistent || fLength == SIZE_LIMIT) {
+            if (!fIsTableViewConsistent || fLength == SIZE_LIMIT ||
+                (fLength > SIZE_LIMIT && fLength > fTableViewBuckets)) {
                 prepareAndPopulateTableView();
                 fIsTableViewConsistent = true;
             }
@@ -280,12 +251,14 @@ implements XMLAttributes, XMLBufferListe
             // We need to check if any of the attributes has the same rawname.
             else {
                 // Search the table.
+                int collisionCount = 0;
                 Attribute found = fAttributeTableView[bucket];
                 while (found != null) {
                     if (found.name.rawname == name.rawname) {
                         break;
                     }
                     found = found.next;
+                    ++collisionCount;
                 }
                 // This attribute is unique.
                 if (found == null) {
@@ -299,9 +272,19 @@ implements XMLAttributes, XMLBufferListe
                         fAttributes = attributes;
                     }
 
-                    // Update table view
-                    fAttributes[index].next = fAttributeTableView[bucket];
-                    fAttributeTableView[bucket] = fAttributes[index];
+                    // Select a new hash function and rehash the table view
+                    // if the collision threshold is exceeded.
+                    if (collisionCount >= MAX_HASH_COLLISIONS) {
+                        // The current attribute will be processed in the rehash.
+                        // Need to set its name first.
+                        fAttributes[index].name.setValues(name);
+                        rebalanceTableView(fLength);
+                    }
+                    else {
+                        // Update table view
+                        fAttributes[index].next = fAttributeTableView[bucket];
+                        fAttributeTableView[bucket] = fAttributes[index];
+                    }
                 }
                 // Duplicate. We still need to find the index.
                 else {
@@ -807,56 +790,79 @@ implements XMLAttributes, XMLBufferListe
      */
     public QName checkDuplicatesNS() {
         // If the list is small check for duplicates using pairwise comparison.
-        if (fLength <= SIZE_LIMIT) {
-            for (int i = 0; i < fLength - 1; ++i) {
-                Attribute att1 = fAttributes[i];
-                for (int j = i + 1; j < fLength; ++j) {
-                    Attribute att2 = fAttributes[j];
+        final int length = fLength;
+        if (length <= SIZE_LIMIT) {
+            final Attribute[] attributes = fAttributes;
+            for (int i = 0; i < length - 1; ++i) {
+                Attribute att1 = attributes[i];
+                for (int j = i + 1; j < length; ++j) {
+                    Attribute att2 = attributes[j];
                     if (att1.name.localpart == att2.name.localpart &&
                         att1.name.uri == att2.name.uri) {
                         return att2.name;
                     }
                 }
             }
+            return null;
         }
         // If the list is large check duplicates using a hash table.
         else {
-            // We don't want this table view to be read if someone calls
-            // addAttribute so we invalidate it up front.
-            fIsTableViewConsistent = false;
-
-            prepareTableView();
-
-            Attribute attr;
-            int bucket;
-
-            for (int i = fLength - 1; i >= 0; --i) {
-                attr = fAttributes[i];
-                bucket = getTableViewBucket(attr.name.localpart, attr.name.uri);
-
-                // The chain is stale.
-                // This must be a unique attribute.
-                if (fAttributeTableViewChainState[bucket] != fLargeCount) {
-                    fAttributeTableViewChainState[bucket] = fLargeCount;
-                    attr.next = null;
-                    fAttributeTableView[bucket] = attr;
+            return checkManyDuplicatesNS();
+        }
+    }
+
+    private QName checkManyDuplicatesNS() {
+        // We don't want this table view to be read if someone calls
+        // addAttribute so we invalidate it up front.
+        fIsTableViewConsistent = false;
+
+        prepareTableView();
+
+        Attribute attr;
+        int bucket;
+
+        final int length = fLength;
+        final Attribute[] attributes = fAttributes;
+        final Attribute[] attributeTableView = fAttributeTableView;
+        final int[] attributeTableViewChainState = fAttributeTableViewChainState;
+        int largeCount = fLargeCount;
+
+        for (int i = 0; i < length; ++i) {
+            attr = attributes[i];
+            bucket = getTableViewBucket(attr.name.localpart, attr.name.uri);
+
+            // The chain is stale.
+            // This must be a unique attribute.
+            if (attributeTableViewChainState[bucket] != largeCount) {
+                attributeTableViewChainState[bucket] = largeCount;
+                attr.next = null;
+                attributeTableView[bucket] = attr;
+            }
+            // This chain is active.
+            // We need to check if any of the attributes has the same name.
+            else {
+                // Search the table.
+                int collisionCount = 0;
+                Attribute found = attributeTableView[bucket];
+                while (found != null) {
+                    if (found.name.localpart == attr.name.localpart &&
+                        found.name.uri == attr.name.uri) {
+                        return attr.name;
+                    }
+                    found = found.next;
+                    ++collisionCount;
+                }
+                // Select a new hash function and rehash the table view
+                // if the collision threshold is exceeded.
+                if (collisionCount >= MAX_HASH_COLLISIONS) {
+                    // The current attribute will be processed in the rehash.
+                    rebalanceTableViewNS(i+1);
+                    largeCount = fLargeCount;
                 }
-                // This chain is active.
-                // We need to check if any of the attributes has the same name.
                 else {
-                    // Search the table.
-                    Attribute found = fAttributeTableView[bucket];
-                    while (found != null) {
-                        if (found.name.localpart == attr.name.localpart &&
-                            found.name.uri == attr.name.uri) {
-                            return attr.name;
-                        }
-                        found = found.next;
-                    }
-
                     // Update table view
-                    attr.next = fAttributeTableView[bucket];
-                    fAttributeTableView[bucket] = attr;
+                    attr.next = attributeTableView[bucket];
+                    attributeTableView[bucket] = attr;
                 }
             }
         }
@@ -911,7 +917,7 @@ implements XMLAttributes, XMLBufferListe
      * would be hashed
      */
     protected int getTableViewBucket(String qname) {
-        return (qname.hashCode() & 0x7FFFFFFF) % fTableViewBuckets;
+        return (hash(qname) & 0x7FFFFFFF) % fTableViewBuckets;
     }
 
     /**
@@ -925,14 +931,37 @@ implements XMLAttributes, XMLBufferListe
      */
     protected int getTableViewBucket(String localpart, String uri) {
         if (uri == null) {
-            return (localpart.hashCode() & 0x7FFFFFFF) % fTableViewBuckets;
+            return (hash(localpart) & 0x7FFFFFFF) % fTableViewBuckets;
         }
         else {
-            return ((localpart.hashCode() + uri.hashCode())
-               & 0x7FFFFFFF) % fTableViewBuckets;
+            return (hash(localpart, uri) & 0x7FFFFFFF) % fTableViewBuckets;
         }
     }
 
+    private int hash(String localpart) {
+        if (fHashMultipliers == null) {
+            return localpart.hashCode();
+        }
+        return hash0(localpart);
+    } // hash(String):int
+
+    private int hash(String localpart, String uri) {
+        if (fHashMultipliers == null) {
+            return localpart.hashCode() + uri.hashCode() * 31;
+        }
+        return hash0(localpart) + hash0(uri) * fHashMultipliers[MULTIPLIERS_SIZE];
+    } // hash(String,String):int
+
+    private int hash0(String symbol) {
+        int code = 0;
+        final int length = symbol.length();
+        final int[] multipliers = fHashMultipliers;
+        for (int i = 0; i < length; ++i) {
+            code = code * multipliers[i & MULTIPLIERS_MASK] + symbol.charAt(i);
+        }
+        return code;
+    } // hash0(String):int
+
     /**
      * Purges all elements from the table view.
      */
@@ -948,10 +977,32 @@ implements XMLAttributes, XMLBufferListe
         }
     }
 
+     /**
+     * Increases the capacity of the table view.
+     */
+    private void growTableView() {
+        final int length = fLength;
+        int tableViewBuckets = fTableViewBuckets;
+        do {
+            tableViewBuckets = (tableViewBuckets << 1) + 1;
+            if (tableViewBuckets < 0) {
+                tableViewBuckets = Integer.MAX_VALUE;
+                break;
+            }
+        }
+       while (length > tableViewBuckets);
+        fTableViewBuckets = tableViewBuckets;
+        fAttributeTableView = null;
+        fLargeCount = 1;
+    }
+
     /**
      * Prepares the table view of the attributes list for use.
      */
     protected void prepareTableView() {
+        if (fLength > fTableViewBuckets) {
+            growTableView();
+        }
         if (fAttributeTableView == null) {
             fAttributeTableView = new Attribute[fTableViewBuckets];
             fAttributeTableViewChainState = new int[fTableViewBuckets];
@@ -967,11 +1018,15 @@ implements XMLAttributes, XMLBufferListe
      * previously read.
      */
     protected void prepareAndPopulateTableView() {
+        prepareAndPopulateTableView(fLength);
+    }
+
+    private void prepareAndPopulateTableView(final int count) {
         prepareTableView();
-        // Need to populate the hash table with the attributes we've scanned so far.
+        // Need to populate the hash table with the attributes we've processed so far.
         Attribute attr;
         int bucket;
-        for (int i = 0; i < fLength; ++i) {
+        for (int i = 0; i < count; ++i) {
             attr = fAttributes[i];
             bucket = getTableViewBucket(attr.name.rawname);
             if (fAttributeTableViewChainState[bucket] != fLargeCount) {
@@ -1135,7 +1190,56 @@ implements XMLAttributes, XMLBufferListe
         }
     }
     public void refresh(int pos) {
+    }
+
+    private void prepareAndPopulateTableViewNS(final int count) {
+        prepareTableView();
+        // Need to populate the hash table with the attributes we've processed so far.
+        Attribute attr;
+        int bucket;
+        for (int i = 0; i < count; ++i) {
+            attr = fAttributes[i];
+            bucket = getTableViewBucket(attr.name.localpart, attr.name.uri);
+            if (fAttributeTableViewChainState[bucket] != fLargeCount) {
+                fAttributeTableViewChainState[bucket] = fLargeCount;
+                attr.next = null;
+                fAttributeTableView[bucket] = attr;
+            }
+            else {
+                // Update table view
+                attr.next = fAttributeTableView[bucket];
+                fAttributeTableView[bucket] = attr;
+            }
+        }
+    }
+
+    /**
+     * Randomly selects a new hash function and reorganizes the table view
+     * in order to more evenly distribute its entries. This method is called
+     * automatically when the number of attributes in one bucket exceeds
+     * MAX_HASH_COLLISIONS.
+     */
+    private void rebalanceTableView(final int count) {
+        if (fHashMultipliers == null) {
+            fHashMultipliers = new int[MULTIPLIERS_SIZE + 1];
         }
+        PrimeNumberSequenceGenerator.generateSequence(fHashMultipliers);
+        prepareAndPopulateTableView(count);
+    }
+
+    /**
+     * Randomly selects a new hash function and reorganizes the table view
+     * in order to more evenly distribute its entries. This method is called
+     * automatically when the number of attributes in one bucket exceeds
+     * MAX_HASH_COLLISIONS.
+     */
+    private void rebalanceTableViewNS(final int count) {
+        if (fHashMultipliers == null) {
+            fHashMultipliers = new int[MULTIPLIERS_SIZE + 1];
+        }
+        PrimeNumberSequenceGenerator.generateSequence(fHashMultipliers);
+        prepareAndPopulateTableViewNS(count);
+    }
 
     //
     // Classes
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/CustomStringPool.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/CustomStringPool.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/CustomStringPool.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,18 +20,20 @@
 /*
  * $Id: CustomStringPool.java,v 1.2.4.1 2005/09/15 08:14:59 suresh_emailid Exp $
  */
-
 package com.sun.org.apache.xml.internal.dtm.ref;
-import java.util.Hashtable;
 
-/** <p>CustomStringPool is an example of appliction provided data structure
- * for a DTM implementation to hold symbol references, e.g. elelment names.
- * It will follow the DTMDStringPool interface and use two simple methods
- * indexToString(int i) and stringToIndex(Sring s) to map between a set of
- * string values and a set of integer index values.  Therefore, an application
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * CustomStringPool is an example of an application-provided data structure for a
+ * DTM implementation to hold symbol references, e.g. element names. It will
+ * follow the DTMStringPool interface and use two simple methods
+ * indexToString(int i) and stringToIndex(String s) to map between a set of
+ * string values and a set of integer index values. Therefore, an application
  * may improve DTM processing speed by substituting the DTM symbol resolution
- * tables with application specific quick symbol resolution tables.</p>
- *
+ * tables with application specific quick symbol resolution tables.
+ * <p>
  * %REVIEW% The only difference between this an DTMStringPool seems to be that
  * it uses a java.lang.Hashtable full of Integers rather than implementing its
  * own hashing. Joe deliberately avoided that approach when writing
@@ -39,52 +41,51 @@ import java.util.Hashtable;
  * -- especially in JDK 1.1.x, where Hashtable is synchronized. We need to
  * either justify this implementation or discard it.
  *
- * <p>Status: In progress, under discussion.</p>
- * */
+ * <p>
+ * Status: In progress, under discussion.
+ *
+ */
 public class CustomStringPool extends DTMStringPool {
-        //final Vector m_intToString;
-        //static final int HASHPRIME=101;
-        //int[] m_hashStart=new int[HASHPRIME];
-        final Hashtable m_stringToInt = new Hashtable();
-        public static final int NULL=-1;
-
-        public CustomStringPool()
-        {
-                super();
-                /*m_intToString=new Vector();
-                System.out.println("In constructor m_intToString is " +
-                                                                                         ((null == m_intToString) ? "null" : "not null"));*/
-                //m_stringToInt=new Hashtable();
-                //removeAllElements();
-        }
 
-        public void removeAllElements()
-        {
-                m_intToString.removeAllElements();
-                if (m_stringToInt != null)
-                        m_stringToInt.clear();
-        }
+    final Map<String, Integer> m_stringToInt = new HashMap<>();
+    public static final int NULL = -1;
 
-        /** @return string whose value is uniquely identified by this integer index.
-         * @throws java.lang.ArrayIndexOutOfBoundsException
-         *  if index doesn't map to a string.
-         * */
-        public String indexToString(int i)
-        throws java.lang.ArrayIndexOutOfBoundsException
-        {
-                return(String) m_intToString.elementAt(i);
+    public CustomStringPool() {
+        super();
+    }
+
+    public void removeAllElements() {
+        m_intToString.removeAllElements();
+        if (m_stringToInt != null) {
+            m_stringToInt.clear();
         }
+    }
 
-        /** @return integer index uniquely identifying the value of this string. */
-        public int stringToIndex(String s)
-        {
-                if (s==null) return NULL;
-                Integer iobj=(Integer)m_stringToInt.get(s);
-                if (iobj==null) {
-                        m_intToString.addElement(s);
-                        iobj=new Integer(m_intToString.size());
-                        m_stringToInt.put(s,iobj);
-                }
-                return iobj.intValue();
+    /**
+     * @return string whose value is uniquely identified by this integer index.
+     * @throws java.lang.ArrayIndexOutOfBoundsException if index doesn't map to
+     * a string.
+     */
+    @Override
+    public String indexToString(int i)
+            throws java.lang.ArrayIndexOutOfBoundsException {
+        return (String) m_intToString.elementAt(i);
+    }
+
+    /**
+     * @return integer index uniquely identifying the value of this string.
+     */
+    @Override
+    public int stringToIndex(String s) {
+        if (s == null) {
+            return NULL;
+        }
+        Integer iobj = m_stringToInt.get(s);
+        if (iobj == null) {
+            m_intToString.addElement(s);
+            iobj = m_intToString.size();
+            m_stringToInt.put(s, iobj);
         }
+        return iobj;
+    }
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/sax2dtm/SAX2DTM.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/sax2dtm/SAX2DTM.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/sax2dtm/SAX2DTM.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,26 +22,43 @@
  */
 package com.sun.org.apache.xml.internal.dtm.ref.sax2dtm;
 
-import java.util.Hashtable;
-import java.util.Vector;
-import javax.xml.transform.Source;
-import javax.xml.transform.SourceLocator;
 
-import com.sun.org.apache.xml.internal.dtm.*;
-import com.sun.org.apache.xml.internal.dtm.ref.*;
-import com.sun.org.apache.xml.internal.utils.StringVector;
-import com.sun.org.apache.xml.internal.utils.IntVector;
+import com.sun.org.apache.xml.internal.dtm.DTM;
+import com.sun.org.apache.xml.internal.dtm.DTMManager;
+import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
+import com.sun.org.apache.xml.internal.dtm.ref.DTMDefaultBaseIterators;
+import com.sun.org.apache.xml.internal.dtm.ref.DTMManagerDefault;
+import com.sun.org.apache.xml.internal.dtm.ref.DTMStringPool;
+import com.sun.org.apache.xml.internal.dtm.ref.DTMTreeWalker;
+import com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource;
+import com.sun.org.apache.xml.internal.dtm.ref.NodeLocator;
+import com.sun.org.apache.xml.internal.res.XMLErrorResources;
+import com.sun.org.apache.xml.internal.res.XMLMessages;
 import com.sun.org.apache.xml.internal.utils.FastStringBuffer;
 import com.sun.org.apache.xml.internal.utils.IntStack;
+import com.sun.org.apache.xml.internal.utils.IntVector;
+import com.sun.org.apache.xml.internal.utils.StringVector;
 import com.sun.org.apache.xml.internal.utils.SuballocatedIntVector;
 import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
 import com.sun.org.apache.xml.internal.utils.WrappedRuntimeException;
 import com.sun.org.apache.xml.internal.utils.XMLString;
 import com.sun.org.apache.xml.internal.utils.XMLStringFactory;
-import com.sun.org.apache.xml.internal.res.XMLErrorResources;
-import com.sun.org.apache.xml.internal.res.XMLMessages;
-import org.xml.sax.*;
-import org.xml.sax.ext.*;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Vector;
+import javax.xml.transform.Source;
+import javax.xml.transform.SourceLocator;
+import org.xml.sax.Attributes;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.DTDHandler;
+import org.xml.sax.EntityResolver;
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.InputSource;
+import org.xml.sax.Locator;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+import org.xml.sax.ext.DeclHandler;
+import org.xml.sax.ext.LexicalHandler;
 
 /**
  * This class implements a DTM that tends to be optimized more for speed than
@@ -145,7 +162,7 @@ public class SAX2DTM extends DTMDefaultB
    * This table holds the ID string to node associations, for
    * XML IDs.
    */
-  protected Hashtable m_idAttributes = new Hashtable();
+  protected Map<String, Integer> m_idAttributes = new HashMap<>();
 
   /**
    * fixed dom-style names.
@@ -1375,7 +1392,7 @@ public class SAX2DTM extends DTMDefaultB
 
     do
     {
-      intObj = (Integer) m_idAttributes.get(elementId);
+      intObj = m_idAttributes.get(elementId);
 
       if (null != intObj)
         return makeNodeHandle(intObj.intValue());
@@ -1513,7 +1530,7 @@ public class SAX2DTM extends DTMDefaultB
    */
   public void setIDAttribute(String id, int elem)
   {
-    m_idAttributes.put(id, new Integer(elem));
+    m_idAttributes.put(id, elem);
   }
 
   /**
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/Catalog.java
@@ -1,18 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
-// Catalog.java - Represents OASIS Open Catalog files.
-
 /*
- * Copyright 2001-2004 The Apache Software Foundation or its licensors,
- * as applicable.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,34 +17,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+// Catalog.java - Represents OASIS Open Catalog files.
 package com.sun.org.apache.xml.internal.resolver;
 
 import com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl;
 import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
-import java.io.IOException;
+import com.sun.org.apache.xml.internal.resolver.helpers.FileURL;
+import com.sun.org.apache.xml.internal.resolver.helpers.PublicId;
+import com.sun.org.apache.xml.internal.resolver.readers.CatalogReader;
+import com.sun.org.apache.xml.internal.resolver.readers.OASISXMLCatalogReader;
+import com.sun.org.apache.xml.internal.resolver.readers.SAXCatalogReader;
+import com.sun.org.apache.xml.internal.resolver.readers.TR9401CatalogReader;
+
+import java.io.DataInputStream;
 import java.io.FileNotFoundException;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
-import java.io.DataInputStream;
-
+import java.net.MalformedURLException;
+import java.net.URL;
 import java.util.Enumeration;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Vector;
-
-import java.net.URL;
-import java.net.MalformedURLException;
-
 import javax.xml.parsers.SAXParserFactory;
 
-import com.sun.org.apache.xml.internal.resolver.CatalogManager;
-import com.sun.org.apache.xml.internal.resolver.helpers.PublicId;
-import com.sun.org.apache.xml.internal.resolver.readers.CatalogReader;
-import com.sun.org.apache.xml.internal.resolver.readers.SAXCatalogReader;
-import com.sun.org.apache.xml.internal.resolver.readers.TR9401CatalogReader;
-import com.sun.org.apache.xml.internal.resolver.readers.OASISXMLCatalogReader;
-import com.sun.org.apache.xml.internal.resolver.helpers.FileURL;
-
 /**
  * Represents OASIS Open Catalog files.
  *
@@ -347,7 +341,7 @@ public class Catalog {
    * vector. This allows the Catalog to quickly locate the reader
    * for a particular MIME type.</p>
    */
-  protected Hashtable readerMap = new Hashtable();
+  protected Map<String, Integer> readerMap = new HashMap<>();
 
   /**
    * A vector of CatalogReaders.
@@ -443,11 +437,11 @@ public class Catalog {
    */
   public void addReader(String mimeType, CatalogReader reader) {
     if (readerMap.containsKey(mimeType)) {
-      Integer pos = (Integer) readerMap.get(mimeType);
-      readerArr.set(pos.intValue(), reader);
+      Integer pos = readerMap.get(mimeType);
+      readerArr.set(pos, reader);
     } else {
       readerArr.add(reader);
-      Integer pos = new Integer(readerArr.size()-1);
+      Integer pos = readerArr.size()-1;
       readerMap.put(mimeType, pos);
     }
   }
@@ -470,19 +464,16 @@ public class Catalog {
       mapArr.add(null);
     }
 
-    Enumeration en = readerMap.keys();
-    while (en.hasMoreElements()) {
-      String mimeType = (String) en.nextElement();
-      Integer pos = (Integer) readerMap.get(mimeType);
-      mapArr.set(pos.intValue(), mimeType);
+    for (Map.Entry<String, Integer> entry : readerMap.entrySet()) {
+        mapArr.set(entry.getValue(), entry.getKey());
     }
 
     for (int count = 0; count < mapArr.size(); count++) {
       String mimeType = (String) mapArr.get(count);
-      Integer pos = (Integer) readerMap.get(mimeType);
+      Integer pos = readerMap.get(mimeType);
       newCatalog.addReader(mimeType,
                            (CatalogReader)
-                           readerArr.get(pos.intValue()));
+                           readerArr.get(pos));
     }
   }
 
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogEntry.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogEntry.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/CatalogEntry.java
@@ -1,18 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
-// CatalogEntry.java - Represents Catalog entries
-
 /*
- * Copyright 2001-2004 The Apache Software Foundation or its licensors,
- * as applicable.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,11 +17,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+// CatalogEntry.java - Represents Catalog entries
 package com.sun.org.apache.xml.internal.resolver;
 
-import java.util.Hashtable;
+import java.util.Map;
 import java.util.Vector;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Represents a Catalog entry.
@@ -53,14 +52,14 @@ import java.util.Vector;
  */
 public class CatalogEntry {
   /** The nextEntry is the ordinal number of the next entry type. */
-  protected static int nextEntry = 0;
+  protected static AtomicInteger nextEntry = new AtomicInteger(0);
 
   /**
    * The entryTypes vector maps catalog entry names
    * (e.g., 'BASE' or 'SYSTEM') to their type (1, 2, etc.).
    * Names are case sensitive.
    */
-  protected static Hashtable entryTypes = new Hashtable();
+  protected static final Map<String, Integer> entryTypes = new ConcurrentHashMap<>();
 
   /** The entryTypes vector maps catalog entry types to the
       number of arguments they're required to have. */
@@ -77,12 +76,12 @@ public class CatalogEntry {
    * of arguments.
    * @return The type for the new entry.
    */
-  public static int addEntryType(String name, int numArgs) {
-    entryTypes.put(name, new Integer(nextEntry));
-    entryArgs.add(nextEntry, new Integer(numArgs));
-    nextEntry++;
+  static int addEntryType(String name, int numArgs) {
+    final int index = nextEntry.getAndIncrement();
+    entryTypes.put(name, index);
+    entryArgs.add(index, numArgs);
 
-    return nextEntry-1;
+    return index;
   }
 
   /**
@@ -99,13 +98,13 @@ public class CatalogEntry {
       throw new CatalogException(CatalogException.INVALID_ENTRY_TYPE);
     }
 
-    Integer iType = (Integer) entryTypes.get(name);
+    Integer iType = entryTypes.get(name);
 
     if (iType == null) {
       throw new CatalogException(CatalogException.INVALID_ENTRY_TYPE);
     }
 
-    return iType.intValue();
+    return iType;
   }
 
   /**
@@ -161,13 +160,13 @@ public class CatalogEntry {
    */
   public CatalogEntry(String name, Vector args)
     throws CatalogException {
-    Integer iType = (Integer) entryTypes.get(name);
+    Integer iType = entryTypes.get(name);
 
     if (iType == null) {
       throw new CatalogException(CatalogException.INVALID_ENTRY_TYPE);
     }
 
-    int type = iType.intValue();
+    int type = iType;
 
     try {
       Integer iArgs = (Integer) entryArgs.get(type);
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/helpers/BootstrapResolver.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/helpers/BootstrapResolver.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/helpers/BootstrapResolver.java
@@ -1,18 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
-// BootstrapResolver.java - Resolve entities and URIs internally
-
 /*
- * Copyright 2001-2004 The Apache Software Foundation or its licensors,
- * as applicable.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,19 +17,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+// BootstrapResolver.java - Resolve entities and URIs internally
 
 package com.sun.org.apache.xml.internal.resolver.helpers;
 
-import java.util.Hashtable;
-import java.net.URL;
-import java.net.MalformedURLException;
 import java.io.InputStream;
-
-import javax.xml.transform.URIResolver;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
 import javax.xml.transform.Source;
-import javax.xml.transform.sax.SAXSource;
 import javax.xml.transform.TransformerException;
-
+import javax.xml.transform.URIResolver;
+import javax.xml.transform.sax.SAXSource;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 
@@ -66,13 +63,13 @@ public class BootstrapResolver implement
   public static final String xmlCatalogSysId = "http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd";
 
   /** Private hash used for public identifiers. */
-  private Hashtable publicMap = new Hashtable();
+  private final Map<String, String> publicMap = new HashMap<>();
 
   /** Private hash used for system identifiers. */
-  private Hashtable systemMap = new Hashtable();
+  private final Map<String, String> systemMap = new HashMap<>();
 
   /** Private hash used for URIs. */
-  private Hashtable uriMap = new Hashtable();
+  private final Map<String, String> uriMap = new HashMap<>();
 
   /** Constructor. */
   public BootstrapResolver() {
@@ -98,9 +95,9 @@ public class BootstrapResolver implement
     String resolved = null;
 
     if (systemId != null && systemMap.containsKey(systemId)) {
-      resolved = (String) systemMap.get(systemId);
+      resolved = systemMap.get(systemId);
     } else if (publicId != null && publicMap.containsKey(publicId)) {
-      resolved = (String) publicMap.get(publicId);
+      resolved = publicMap.get(publicId);
     }
 
     if (resolved != null) {
@@ -147,7 +144,7 @@ public class BootstrapResolver implement
 
     String result = null;
     if (href != null && uriMap.containsKey(href)) {
-      result = (String) uriMap.get(href);
+      result = uriMap.get(href);
     }
 
     if (result == null) {
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/DOMCatalogReader.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/DOMCatalogReader.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/DOMCatalogReader.java
@@ -1,18 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
-// DOMCatalogReader.java - Read XML Catalog files
-
 /*
- * Copyright 2001-2004 The Apache Software Foundation or its licensors,
- * as applicable.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,6 +17,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+// DOMCatalogReader.java - Read XML Catalog files
 
 package com.sun.org.apache.xml.internal.resolver.readers;
 
@@ -31,11 +29,14 @@ import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLConnection;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
-import org.w3c.dom.*;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
 import org.xml.sax.SAXException;
 import sun.reflect.misc.ReflectUtil;
 
@@ -77,7 +78,7 @@ public class DOMCatalogReader implements
    * or "{namespaceuri}elementname". The former is used if the
    * namespace URI is null.</p>
    */
-  protected Hashtable namespaceMap = new Hashtable();
+  protected Map<String, String> namespaceMap = new HashMap<>();
 
   /**
    * Add a new parser to the reader.
@@ -113,9 +114,9 @@ public class DOMCatalogReader implements
   public String getCatalogParser(String namespaceURI,
                                  String rootElement) {
     if (namespaceURI == null) {
-      return (String) namespaceMap.get(rootElement);
+      return namespaceMap.get(rootElement);
     } else {
-      return (String) namespaceMap.get("{"+namespaceURI+"}"+rootElement);
+      return namespaceMap.get("{"+namespaceURI+"}"+rootElement);
     }
   }
 
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/SAXCatalogReader.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/SAXCatalogReader.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/resolver/readers/SAXCatalogReader.java
@@ -1,18 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
-// SAXCatalogReader.java - Read XML Catalog files
-
 /*
- * Copyright 2001-2004 The Apache Software Foundation or its licensors,
- * as applicable.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,6 +17,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+// SAXCatalogReader.java - Read XML Catalog files
 
 package com.sun.org.apache.xml.internal.resolver.readers;
 
@@ -34,7 +32,8 @@ import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
@@ -90,7 +89,7 @@ public class SAXCatalogReader implements
      * or "{namespaceuri}elementname". The former is used if the
      * namespace URI is null.</p>
      */
-  protected Hashtable namespaceMap = new Hashtable();
+  protected Map<String, String> namespaceMap = new HashMap<>();
 
   /** The parser in use for the current catalog. */
   private SAXCatalogParser saxParser = null;
@@ -171,9 +170,9 @@ public class SAXCatalogReader implements
   public String getCatalogParser(String namespaceURI,
                                  String rootElement) {
     if (namespaceURI == null) {
-      return (String) namespaceMap.get(rootElement);
+      return namespaceMap.get(rootElement);
     } else {
-      return (String) namespaceMap.get("{"+namespaceURI+"}"+rootElement);
+      return namespaceMap.get("{"+namespaceURI+"}"+rootElement);
     }
   }
 
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/BaseMarkupSerializer.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/BaseMarkupSerializer.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/BaseMarkupSerializer.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -18,7 +18,6 @@
  * limitations under the License.
  */
 
-
 // Sep 14, 2000:
 //  Fixed comments to preserve whitespaces and add a line break
 //  when indenting. Reported by Gervase Markham <gerv@gerv.net>
@@ -46,23 +45,23 @@
 
 package com.sun.org.apache.xml.internal.serialize;
 
-
+import com.sun.org.apache.xerces.internal.dom.DOMErrorImpl;
+import com.sun.org.apache.xerces.internal.dom.DOMLocatorImpl;
+import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
+import com.sun.org.apache.xerces.internal.util.XMLChar;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.Writer;
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Vector;
 
-import com.sun.org.apache.xerces.internal.dom.DOMErrorImpl;
-import com.sun.org.apache.xerces.internal.dom.DOMLocatorImpl;
-import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
-import com.sun.org.apache.xerces.internal.util.XMLChar;
+import org.w3c.dom.DOMError;
+import org.w3c.dom.DOMErrorHandler;
 import org.w3c.dom.DOMImplementation;
 import org.w3c.dom.Document;
 import org.w3c.dom.DocumentFragment;
 import org.w3c.dom.DocumentType;
-import org.w3c.dom.DOMError;
-import org.w3c.dom.DOMErrorHandler;
 import org.w3c.dom.Element;
 import org.w3c.dom.Entity;
 import org.w3c.dom.NamedNodeMap;
@@ -186,7 +185,7 @@ public abstract class BaseMarkupSerializ
      * Accumulated here prior to starting an element and placing this
      * list in the element state.
      */
-    protected Hashtable     _prefixes;
+    protected Map<String, String>  _prefixes;
 
 
     /**
@@ -821,7 +820,7 @@ public abstract class BaseMarkupSerializ
         throws SAXException
     {
         if ( _prefixes == null )
-            _prefixes = new Hashtable();
+            _prefixes = new HashMap<>();
         _prefixes.put( uri, prefix == null ? "" : prefix );
     }
 
@@ -1909,7 +1908,7 @@ public abstract class BaseMarkupSerializ
         String    prefix;
 
         if ( _prefixes != null ) {
-            prefix = (String) _prefixes.get( namespaceURI );
+            prefix = _prefixes.get( namespaceURI );
             if ( prefix != null )
                 return prefix;
         }
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/ElementState.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/ElementState.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/ElementState.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -22,7 +22,7 @@
 package com.sun.org.apache.xml.internal.serialize;
 
 
-import java.util.Hashtable;
+import java.util.Map;
 
 
 /**
@@ -102,7 +102,7 @@ public class ElementState
     /**
      * Association between namespace URIs (keys) and prefixes (values).
      */
-    public Hashtable prefixes;
+    public Map<String, String> prefixes;
 
 
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/Encodings.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/Encodings.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/Encodings.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -22,11 +22,11 @@
 package com.sun.org.apache.xml.internal.serialize;
 
 
+import com.sun.org.apache.xerces.internal.util.EncodingMap;
 import java.io.UnsupportedEncodingException;
-import java.util.Hashtable;
 import java.util.Locale;
-
-import com.sun.org.apache.xerces.internal.util.EncodingMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 
 /**
@@ -37,7 +37,7 @@ import com.sun.org.apache.xerces.interna
  *
  * @author <a href="mailto:arkin@intalio.com">Assaf Arkin</a>
  */
-public class Encodings
+class Encodings
 {
 
 
@@ -55,10 +55,10 @@ public class Encodings
     // default (Java) encoding if none supplied:
     static final String DEFAULT_ENCODING = "UTF8";
 
-    // note that the size of this Hashtable
+    // note that the size of this Map
     // is bounded by the number of encodings recognized by EncodingMap;
     // therefore it poses no static mutability risk.
-    static Hashtable _encodings = new Hashtable();
+    private static final Map<String, EncodingInfo> _encodings = new ConcurrentHashMap();
 
     /**
      * @param encoding a MIME charset name, or null.
@@ -66,7 +66,7 @@ public class Encodings
     static EncodingInfo getEncodingInfo(String encoding, boolean allowJavaNames) throws UnsupportedEncodingException {
         EncodingInfo eInfo = null;
         if (encoding == null) {
-            if((eInfo = (EncodingInfo)_encodings.get(DEFAULT_ENCODING)) != null)
+            if((eInfo = _encodings.get(DEFAULT_ENCODING)) != null)
                 return eInfo;
             eInfo = new EncodingInfo(EncodingMap.getJava2IANAMapping(DEFAULT_ENCODING), DEFAULT_ENCODING, LAST_PRINTABLE_UNICODE);
             _encodings.put(DEFAULT_ENCODING, eInfo);
@@ -79,7 +79,7 @@ public class Encodings
             // see if the encoding passed in is a Java encoding name.
             if(allowJavaNames ) {
                 EncodingInfo.testJavaEncodingName(encoding);
-                if((eInfo = (EncodingInfo)_encodings.get(encoding)) != null)
+                if((eInfo = _encodings.get(encoding)) != null)
                     return eInfo;
                 // is it known to be unicode-compliant?
                 int i=0;
@@ -98,7 +98,7 @@ public class Encodings
                 throw new UnsupportedEncodingException(encoding);
             }
         }
-        if ((eInfo = (EncodingInfo)_encodings.get(jName)) != null)
+        if ((eInfo = _encodings.get(jName)) != null)
             return eInfo;
         // have to create one...
         // is it known to be unicode-compliant?
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLSerializer.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLSerializer.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLSerializer.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -37,13 +37,11 @@
 package com.sun.org.apache.xml.internal.serialize;
 
 import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
-
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.Writer;
-import java.util.Enumeration;
 import java.util.Locale;
-
+import java.util.Map;
 import org.w3c.dom.Attr;
 import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
@@ -320,13 +318,10 @@ public class HTMLSerializer
                 preserveSpace = true;
 
             if ( addNSAttr ) {
-                Enumeration keys;
-
-                keys = _prefixes.keys();
-                while ( keys.hasMoreElements() ) {
+                for (Map.Entry<String, String> entry : _prefixes.entrySet()) {
                     _printer.printSpace();
-                    value = (String) keys.nextElement();
-                    name = (String) _prefixes.get( value );
+                    value = entry.getKey(); //The prefixes map uses the URI value as key.
+                    name = entry.getValue(); //and prefix name as value
                     if ( name.length() == 0 ) {
                         _printer.printText( "xmlns=\"" );
                         printEscaped( value );
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLdtd.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLdtd.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/HTMLdtd.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -18,7 +18,6 @@
  * limitations under the License.
  */
 
-
 // Aug 21, 2000:
 //   Fixed bug in isElement and made HTMLdtd public.
 //   Contributed by Eric SCHAEFFER" <eschaeffer@posterconseil.com>
@@ -27,12 +26,12 @@
 package com.sun.org.apache.xml.internal.serialize;
 
 import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
-
+import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.BufferedReader;
-import java.util.Hashtable;
+import java.util.HashMap;
 import java.util.Locale;
+import java.util.Map;
 
 
 /**
@@ -78,23 +77,23 @@ public final class HTMLdtd
      * Table of reverse character reference mapping. Character codes are held
      * as single-character strings, mapped to their reference name.
      */
-    private static Hashtable        _byChar;
+    private static Map<Integer, String> _byChar;
 
 
     /**
      * Table of entity name to value mapping. Entities are held as strings,
      * character references as <TT>Character</TT> objects.
      */
-    private static Hashtable        _byName;
+    private static Map<String, Integer> _byName;
 
 
-    private static Hashtable        _boolAttrs;
+    private static final Map<String, String[]> _boolAttrs;
 
 
     /**
      * Holds element definitions.
      */
-    private static Hashtable        _elemDefs;
+    private static final Map<String, Integer> _elemDefs;
 
 
     /**
@@ -300,7 +299,7 @@ public final class HTMLdtd
     {
         String[] attrNames;
 
-        attrNames = (String[]) _boolAttrs.get( tagName.toUpperCase(Locale.ENGLISH) );
+        attrNames = _boolAttrs.get( tagName.toUpperCase(Locale.ENGLISH) );
         if ( attrNames == null )
             return false;
         for ( int i = 0 ; i < attrNames.length ; ++i )
@@ -347,7 +346,7 @@ public final class HTMLdtd
         String name;
 
         initialize();
-        name = (String) _byChar.get( new Integer( value ) );
+        name = _byChar.get(value);
         return name;
     }
 
@@ -372,8 +371,8 @@ public final class HTMLdtd
         if ( _byName != null )
             return;
         try {
-            _byName = new Hashtable();
-            _byChar = new Hashtable();
+            _byName = new HashMap<>();
+            _byChar = new HashMap<>();
             is = HTMLdtd.class.getResourceAsStream( ENTITIES_RESOURCE );
             if ( is == null ) {
                 throw new RuntimeException(
@@ -442,7 +441,7 @@ public final class HTMLdtd
 
     private static void defineElement( String name, int flags )
     {
-        _elemDefs.put( name, new Integer( flags ) );
+        _elemDefs.put(name, flags);
     }
 
 
@@ -462,7 +461,7 @@ public final class HTMLdtd
     {
         Integer flags;
 
-        flags = (Integer) _elemDefs.get( name.toUpperCase(Locale.ENGLISH) );
+        flags = _elemDefs.get( name.toUpperCase(Locale.ENGLISH) );
         if ( flags == null )
             return false;
         else
@@ -472,7 +471,7 @@ public final class HTMLdtd
 
     static
     {
-        _elemDefs = new Hashtable();
+        _elemDefs = new HashMap<>();
         defineElement( "ADDRESS", CLOSE_P );
         defineElement( "AREA", EMPTY );
         defineElement( "BASE",  EMPTY | ALLOWED_HEAD );
@@ -526,7 +525,7 @@ public final class HTMLdtd
         defineElement( "TR", ELEM_CONTENT | OPT_CLOSING | CLOSE_TABLE );
         defineElement( "UL", ELEM_CONTENT | CLOSE_P );
 
-        _boolAttrs = new Hashtable();
+        _boolAttrs = new HashMap<>();
         defineBoolean( "AREA", "href" );
         defineBoolean( "BUTTON", "disabled" );
         defineBoolean( "DIR", "compact" );
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/SerializerFactory.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/SerializerFactory.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/SerializerFactory.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -24,9 +24,11 @@ package com.sun.org.apache.xml.internal.
 import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
 import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import java.io.OutputStream;
-import java.io.Writer;
 import java.io.UnsupportedEncodingException;
-import java.util.Hashtable;
+import java.io.Writer;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.StringTokenizer;
 
 /**
@@ -43,7 +45,7 @@ public abstract class SerializerFactory
     public static final String FactoriesProperty = "com.sun.org.apache.xml.internal.serialize.factories";
 
 
-    private static Hashtable  _factories = new Hashtable();
+    private static final Map<String, SerializerFactory>  _factories = Collections.synchronizedMap(new HashMap());
 
 
     static
@@ -89,9 +91,9 @@ public abstract class SerializerFactory
         String method;
 
         synchronized ( _factories ) {
-            method = factory.getSupportedMethod();
-            _factories.put( method, factory );
-        }
+        method = factory.getSupportedMethod();
+        _factories.put( method, factory );
+    }
     }
 
 
@@ -101,7 +103,7 @@ public abstract class SerializerFactory
      */
     public static SerializerFactory getSerializerFactory( String method )
     {
-        return (SerializerFactory) _factories.get( method );
+        return _factories.get( method );
     }
 
 
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/XMLSerializer.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/XMLSerializer.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serialize/XMLSerializer.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2002,2004,2005 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -36,18 +36,16 @@
 
 package com.sun.org.apache.xml.internal.serialize;
 
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.Writer;
-import java.util.Enumeration;
-
 import com.sun.org.apache.xerces.internal.dom.DOMMessageFormatter;
 import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
 import com.sun.org.apache.xerces.internal.util.XMLChar;
 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Map;
 import org.w3c.dom.Attr;
 import org.w3c.dom.DOMError;
 import org.w3c.dom.Element;
@@ -334,13 +332,10 @@ extends BaseMarkupSerializer {
             }
 
             if (_prefixes != null) {
-                Enumeration keys;
-
-                keys = _prefixes.keys();
-                while (keys.hasMoreElements()) {
+                for (Map.Entry<String, String> entry : _prefixes.entrySet()) {
                     _printer.printSpace();
-                    value = (String) keys.nextElement();
-                    name = (String) _prefixes.get( value );
+                    value = entry.getKey(); //The prefixes map uses the URI value as key.
+                    name = entry.getValue(); //and prefix name as value
                     if (name.length() == 0) {
                         _printer.printText( "xmlns=\"" );
                         printEscaped( value );
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/AttributesImplSerializer.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/AttributesImplSerializer.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/AttributesImplSerializer.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2003-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -23,14 +23,14 @@
 
 package com.sun.org.apache.xml.internal.serializer;
 
-import java.util.Hashtable;
-
+import java.util.HashMap;
+import java.util.Map;
 import org.xml.sax.Attributes;
 import org.xml.sax.helpers.AttributesImpl;
 
 /**
  * This class extends org.xml.sax.helpers.AttributesImpl which implements org.
- * xml.sax.Attributes. But for optimization this class adds a Hashtable for
+ * xml.sax.Attributes. But for optimization this class adds a Map for
  * faster lookup of an index by qName, which is commonly done in the stream
  * serializer.
  *
@@ -48,7 +48,7 @@ public final class AttributesImplSeriali
      * The keys to the hashtable to find the index are either
      * "prefix:localName"  or "{uri}localName".
      */
-    private final Hashtable m_indexFromQName = new Hashtable();
+    private final Map<String, Integer> m_indexFromQName = new HashMap<>();
 
     private final StringBuffer m_buff = new StringBuffer();
 
@@ -60,7 +60,7 @@ public final class AttributesImplSeriali
 
     /**
      * One less than the number of attributes before switching to
-     * the Hashtable.
+     * the Map.
      */
     private static final int MAXMinus1 = MAX - 1;
 
@@ -82,8 +82,8 @@ public final class AttributesImplSeriali
             return index;
         }
         // we have too many attributes and the super class is slow
-        // so find it quickly using our Hashtable.
-        Integer i = (Integer)m_indexFromQName.get(qname);
+        // so find it quickly using our Map.
+        Integer i = m_indexFromQName.get(qname);
         if (i == null)
             index = -1;
         else
@@ -126,7 +126,7 @@ public final class AttributesImplSeriali
         {
             /* add the key with the format of "prefix:localName" */
             /* we have just added the attibute, its index is the old length */
-            Integer i = new Integer(index);
+            Integer i = index;
             m_indexFromQName.put(qname, i);
 
             /* now add with key of the format "{uri}localName" */
@@ -135,14 +135,13 @@ public final class AttributesImplSeriali
             String key = m_buff.toString();
             m_indexFromQName.put(key, i);
         }
-        return;
     }
 
     /**
      * We are switching over to having a hash table for quick look
      * up of attributes, but up until now we haven't kept any
-     * information in the Hashtable, so we now update the Hashtable.
-     * Future additional attributes will update the Hashtable as
+     * information in the Map, so we now update the Map.
+     * Future additional attributes will update the Map as
      * they are added.
      * @param numAtts
      */
@@ -151,7 +150,7 @@ public final class AttributesImplSeriali
         for (int index = 0; index < numAtts; index++)
         {
             String qName = super.getQName(index);
-            Integer i = new Integer(index);
+            Integer i = index;
             m_indexFromQName.put(qName, i);
 
             // Add quick look-up to find with uri/local name pair
@@ -177,7 +176,7 @@ public final class AttributesImplSeriali
         if (MAX <= len)
         {
             // if we have had enough attributes and are
-            // using the Hashtable, then clear the Hashtable too.
+            // using the Map, then clear the Map too.
             m_indexFromQName.clear();
         }
 
@@ -224,16 +223,16 @@ public final class AttributesImplSeriali
             return index;
         }
         // we have too many attributes and the super class is slow
-        // so find it quickly using our Hashtable.
+        // so find it quickly using our Map.
         // Form the key of format "{uri}localName"
         m_buff.setLength(0);
         m_buff.append('{').append(uri).append('}').append(localName);
         String key = m_buff.toString();
-        Integer i = (Integer)m_indexFromQName.get(key);
+        Integer i = m_indexFromQName.get(key);
         if (i == null)
             index = -1;
         else
-            index = i.intValue();
+            index = i;
         return index;
     }
 }
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/EmptySerializer.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/EmptySerializer.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/EmptySerializer.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2003-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -25,13 +25,10 @@ package com.sun.org.apache.xml.internal.
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.Writer;
-import java.util.Hashtable;
 import java.util.Properties;
 import java.util.Vector;
-
 import javax.xml.transform.SourceLocator;
 import javax.xml.transform.Transformer;
-
 import org.w3c.dom.Node;
 import org.xml.sax.Attributes;
 import org.xml.sax.ContentHandler;
@@ -39,6 +36,7 @@ import org.xml.sax.Locator;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 
+
 /**
  * This class is an adapter class. Its only purpose is to be extended and
  * for that extended class to over-ride all methods that are to be used.
@@ -75,11 +73,6 @@ public class EmptySerializer implements
         return; // don't do anything.
     }
 
-    protected void couldThrowException() throws Exception
-    {
-        return; // don't do anything.
-    }
-
     void aMethodIsCalled()
     {
 
@@ -568,13 +561,6 @@ public class EmptySerializer implements
         return null;
     }
     /**
-     * @see XSLOutputAttributes#setCdataSectionElements
-     */
-    public void setCdataSectionElements(Hashtable h) throws Exception
-    {
-        couldThrowException();
-    }
-    /**
      * @see XSLOutputAttributes#setDoctype(java.lang.String, java.lang.String)
      */
     public void setDoctype(String system, String pub)
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/SerializerFactory.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/SerializerFactory.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/SerializerFactory.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,14 +22,11 @@
  */
 package com.sun.org.apache.xml.internal.serializer;
 
-import java.util.Hashtable;
-import java.util.Properties;
-
-import javax.xml.transform.OutputKeys;
-
+import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
-import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
+import java.util.Properties;
+import javax.xml.transform.OutputKeys;
 import org.xml.sax.ContentHandler;
 
 /**
@@ -70,10 +67,6 @@ public final class SerializerFactory
   private SerializerFactory() {
 
   }
-  /**
-   * Associates output methods to default output formats.
-   */
-  private static Hashtable m_formats = new Hashtable();
 
   /**
    * Returns a serializer for the specified output method. The output method
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/utils/Utils.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/utils/Utils.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/serializer/utils/Utils.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 2003-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,8 +22,6 @@
  */
 package com.sun.org.apache.xml.internal.serializer.utils;
 
-import java.util.Hashtable;
-
 /**
  * This class contains utilities used by the serializer.
  *
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/utils/DOMHelper.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/utils/DOMHelper.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/utils/DOMHelper.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,18 +22,16 @@
  */
 package com.sun.org.apache.xml.internal.utils;
 
-import java.util.Hashtable;
+import com.sun.org.apache.xml.internal.dtm.ref.DTMNodeProxy;
+import com.sun.org.apache.xml.internal.res.XMLErrorResources;
+import com.sun.org.apache.xml.internal.res.XMLMessages;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Vector;
-
 import javax.xml.XMLConstants;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
-
-import com.sun.org.apache.xml.internal.dtm.ref.DTMNodeProxy;
-import com.sun.org.apache.xml.internal.res.XMLErrorResources;
-import com.sun.org.apache.xml.internal.res.XMLMessages;
-
 import org.w3c.dom.Attr;
 import org.w3c.dom.DOMImplementation;
 import org.w3c.dom.Document;
@@ -565,7 +563,7 @@ public class DOMHelper
   /**
    * An experiment for the moment.
    */
-  Hashtable m_NSInfos = new Hashtable();
+  Map<Node, NSInfo> m_NSInfos = new HashMap<>();
 
   /** Object to put into the m_NSInfos table that tells that a node has not been
    *  processed, but has xmlns namespace decls.  */
@@ -623,9 +621,7 @@ public class DOMHelper
 
     if (Node.ATTRIBUTE_NODE != ntype)
     {
-      Object nsObj = m_NSInfos.get(n);  // return value
-
-      nsInfo = (nsObj == null) ? null : (NSInfo) nsObj;
+      nsInfo = m_NSInfos.get(n);
       hasProcessedNS = (nsInfo == null) ? false : nsInfo.m_hasProcessedNS;
     }
     else
@@ -751,9 +747,7 @@ public class DOMHelper
 
           if (null != parent)
           {
-            Object nsObj = m_NSInfos.get(parent);  // return value
-
-            nsInfo = (nsObj == null) ? null : (NSInfo) nsObj;
+            nsInfo = m_NSInfos.get(parent);
           }
         }
 
@@ -770,12 +764,12 @@ public class DOMHelper
 
               if (candidateInfo == m_NSInfoUnProcWithoutXMLNS)
               {
-                m_NSInfos.put(m_candidateNoAncestorXMLNS.elementAt(i),
+                m_NSInfos.put((Node)m_candidateNoAncestorXMLNS.elementAt(i),
                               m_NSInfoUnProcNoAncestorXMLNS);
               }
               else if (candidateInfo == m_NSInfoNullWithoutXMLNS)
               {
-                m_NSInfos.put(m_candidateNoAncestorXMLNS.elementAt(i),
+                m_NSInfos.put((Node)m_candidateNoAncestorXMLNS.elementAt(i),
                               m_NSInfoNullNoAncestorXMLNS);
               }
             }
Index: openjdk/jaxp/src/com/sun/org/apache/xml/internal/utils/ElemDesc.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xml/internal/utils/ElemDesc.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xml/internal/utils/ElemDesc.java
@@ -1,13 +1,13 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -22,7 +22,9 @@
  */
 package com.sun.org.apache.xml.internal.utils;
 
-import java.util.Hashtable;
+import java.util.HashMap;
+import java.util.Map;
+
 
 /**
  * This class is in support of SerializerToHTML, and acts as a sort
@@ -33,7 +35,7 @@ class ElemDesc
 {
 
   /** Table of attributes for the element */
-  Hashtable m_attrs = null;
+  Map<String, Integer> m_attrs = null;
 
   /** Element's flags, describing the role this element plays during
    * formatting of the document. This is used as a bitvector; more than one flag
@@ -157,9 +159,9 @@ class ElemDesc
   {
 
     if (null == m_attrs)
-      m_attrs = new Hashtable();
+      m_attrs = new HashMap<>();
 
-    m_attrs.put(name, new Integer(flags));
+    m_attrs.put(name, flags);
   }
 
   /**
@@ -178,11 +180,11 @@ class ElemDesc
 
     if (null != m_attrs)
     {
-      Integer _flags = (Integer) m_attrs.get(name);
+      Integer _flags = m_attrs.get(name);
 
       if (null != _flags)
       {
-        return (_flags.intValue() & flags) != 0;
+        return (_flags & flags) != 0;
       }
     }
 
Index: openjdk/jaxp/src/com/sun/org/apache/xpath/internal/compiler/Keywords.java
===================================================================
--- openjdk/jaxp/src/com/sun/org/apache/xpath/internal/compiler/Keywords.java.orig
+++ openjdk/jaxp/src/com/sun/org/apache/xpath/internal/compiler/Keywords.java
@@ -1,15 +1,15 @@
 /*
- * reserved comment block
- * DO NOT REMOVE OR ALTER!
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright 1999-2005 The Apache Software Foundation.
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -22,267 +22,369 @@
  */
 package com.sun.org.apache.xpath.internal.compiler;
 
-import java.util.Hashtable;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * Table of strings to operation code lookups.
+ *
  * @xsl.usage internal
  */
-public class Keywords
-{
-
-  /** Table of keywords to opcode associations. */
-  private static Hashtable m_keywords = new Hashtable();
-
-  /** Table of axes names to opcode associations. */
-  private static Hashtable m_axisnames = new Hashtable();
-
-  /** Table of function name to function ID associations. */
-  private static Hashtable m_nodetests = new Hashtable();
-
-  /** Table of node type strings to opcode associations. */
-  private static Hashtable m_nodetypes = new Hashtable();
-
-  /** ancestor axes string. */
-  private static final String FROM_ANCESTORS_STRING = "ancestor";
-
-  /** ancestor-or-self axes string. */
-  private static final String FROM_ANCESTORS_OR_SELF_STRING =
-    "ancestor-or-self";
-
-  /** attribute axes string. */
-  private static final String FROM_ATTRIBUTES_STRING = "attribute";
-
-  /** child axes string. */
-  private static final String FROM_CHILDREN_STRING = "child";
-
-  /** descendant-or-self axes string. */
-  private static final String FROM_DESCENDANTS_STRING = "descendant";
-
-  /** ancestor axes string. */
-  private static final String FROM_DESCENDANTS_OR_SELF_STRING =
-    "descendant-or-self";
-
-  /** following axes string. */
-  private static final String FROM_FOLLOWING_STRING = "following";
-
-  /** following-sibling axes string. */
-  private static final String FROM_FOLLOWING_SIBLINGS_STRING =
-    "following-sibling";
-
-  /** parent axes string. */
-  private static final String FROM_PARENT_STRING = "parent";
-
-  /** preceding axes string. */
-  private static final String FROM_PRECEDING_STRING = "preceding";
-
-  /** preceding-sibling axes string. */
-  private static final String FROM_PRECEDING_SIBLINGS_STRING =
-    "preceding-sibling";
-
-  /** self axes string. */
-  private static final String FROM_SELF_STRING = "self";
-
-  /** namespace axes string. */
-  private static final String FROM_NAMESPACE_STRING = "namespace";
-
-  /** self axes abreviated string. */
-  private static final String FROM_SELF_ABBREVIATED_STRING = ".";
-
-  /** comment node test string. */
-  private static final String NODETYPE_COMMENT_STRING = "comment";
-
-  /** text node test string. */
-  private static final String NODETYPE_TEXT_STRING = "text";
-
-  /** processing-instruction node test string. */
-  private static final String NODETYPE_PI_STRING = "processing-instruction";
-
-  /** Any node test string. */
-  private static final String NODETYPE_NODE_STRING = "node";
-
-  /** Wildcard element string. */
-  private static final String NODETYPE_ANYELEMENT_STRING = "*";
-
-  /** current function string. */
-  public static final String FUNC_CURRENT_STRING = "current";
-
-  /** last function string. */
-  public static final String FUNC_LAST_STRING = "last";
-
-  /** position function string. */
-  public static final String FUNC_POSITION_STRING = "position";
-
-  /** count function string. */
-  public static final String FUNC_COUNT_STRING = "count";
-
-  /** id function string. */
-  static final String FUNC_ID_STRING = "id";
+public class Keywords {
 
-  /** key function string (XSLT). */
-  public static final String FUNC_KEY_STRING = "key";
-
-  /** local-name function string. */
-  public static final String FUNC_LOCAL_PART_STRING = "local-name";
-
-  /** namespace-uri function string. */
-  public static final String FUNC_NAMESPACE_STRING = "namespace-uri";
-
-  /** name function string. */
-  public static final String FUNC_NAME_STRING = "name";
-
-  /** generate-id function string (XSLT). */
-  public static final String FUNC_GENERATE_ID_STRING = "generate-id";
-
-  /** not function string. */
-  public static final String FUNC_NOT_STRING = "not";
-
-  /** true function string. */
-  public static final String FUNC_TRUE_STRING = "true";
-
-  /** false function string. */
-  public static final String FUNC_FALSE_STRING = "false";
-
-  /** boolean function string. */
-  public static final String FUNC_BOOLEAN_STRING = "boolean";
-
-  /** lang function string. */
-  public static final String FUNC_LANG_STRING = "lang";
-
-  /** number function string. */
-  public static final String FUNC_NUMBER_STRING = "number";
-
-  /** floor function string. */
-  public static final String FUNC_FLOOR_STRING = "floor";
-
-  /** ceiling function string. */
-  public static final String FUNC_CEILING_STRING = "ceiling";
-
-  /** round function string. */
-  public static final String FUNC_ROUND_STRING = "round";
-
-  /** sum function string. */
-  public static final String FUNC_SUM_STRING = "sum";
-
-  /** string function string. */
-  public static final String FUNC_STRING_STRING = "string";
-
-  /** starts-with function string. */
-  public static final String FUNC_STARTS_WITH_STRING = "starts-with";
-
-  /** contains function string. */
-  public static final String FUNC_CONTAINS_STRING = "contains";
-
-  /** substring-before function string. */
-  public static final String FUNC_SUBSTRING_BEFORE_STRING =
-    "substring-before";
-
-  /** substring-after function string. */
-  public static final String FUNC_SUBSTRING_AFTER_STRING = "substring-after";
-
-  /** normalize-space function string. */
-  public static final String FUNC_NORMALIZE_SPACE_STRING = "normalize-space";
-
-  /** translate function string. */
-  public static final String FUNC_TRANSLATE_STRING = "translate";
-
-  /** concat function string. */
-  public static final String FUNC_CONCAT_STRING = "concat";
-
-  /** system-property function string. */
-  public static final String FUNC_SYSTEM_PROPERTY_STRING = "system-property";
-
-  /** function-available function string (XSLT). */
-  public static final String FUNC_EXT_FUNCTION_AVAILABLE_STRING =
-    "function-available";
-
-  /** element-available function string (XSLT). */
-  public static final String FUNC_EXT_ELEM_AVAILABLE_STRING =
-    "element-available";
-
-  /** substring function string. */
-  public static final String FUNC_SUBSTRING_STRING = "substring";
-
-  /** string-length function string. */
-  public static final String FUNC_STRING_LENGTH_STRING = "string-length";
-
-  /** unparsed-entity-uri function string (XSLT). */
-  public static final String FUNC_UNPARSED_ENTITY_URI_STRING =
-    "unparsed-entity-uri";
+    /**
+     * Table of keywords to opcode associations.
+     */
+    private static final Map<String, Integer> m_keywords;
+
+    /**
+     * Table of axes names to opcode associations.
+     */
+    private static final Map<String, Integer> m_axisnames;
+
+    /**
+     * Table of function name to function ID associations.
+     */
+    private static final Map<String, Integer> m_nodetests;
+
+    /**
+     * Table of node type strings to opcode associations.
+     */
+    private static final Map<String, Integer> m_nodetypes;
+
+    /**
+     * ancestor axes string.
+     */
+    private static final String FROM_ANCESTORS_STRING = "ancestor";
+
+    /**
+     * ancestor-or-self axes string.
+     */
+    private static final String FROM_ANCESTORS_OR_SELF_STRING
+            = "ancestor-or-self";
+
+    /**
+     * attribute axes string.
+     */
+    private static final String FROM_ATTRIBUTES_STRING = "attribute";
+
+    /**
+     * child axes string.
+     */
+    private static final String FROM_CHILDREN_STRING = "child";
+
+    /**
+     * descendant-or-self axes string.
+     */
+    private static final String FROM_DESCENDANTS_STRING = "descendant";
+
+    /**
+     * ancestor axes string.
+     */
+    private static final String FROM_DESCENDANTS_OR_SELF_STRING
+            = "descendant-or-self";
+
+    /**
+     * following axes string.
+     */
+    private static final String FROM_FOLLOWING_STRING = "following";
+
+    /**
+     * following-sibling axes string.
+     */
+    private static final String FROM_FOLLOWING_SIBLINGS_STRING
+            = "following-sibling";
+
+    /**
+     * parent axes string.
+     */
+    private static final String FROM_PARENT_STRING = "parent";
+
+    /**
+     * preceding axes string.
+     */
+    private static final String FROM_PRECEDING_STRING = "preceding";
+
+    /**
+     * preceding-sibling axes string.
+     */
+    private static final String FROM_PRECEDING_SIBLINGS_STRING
+            = "preceding-sibling";
+
+    /**
+     * self axes string.
+     */
+    private static final String FROM_SELF_STRING = "self";
+
+    /**
+     * namespace axes string.
+     */
+    private static final String FROM_NAMESPACE_STRING = "namespace";
+
+    /**
+     * self axes abreviated string.
+     */
+    private static final String FROM_SELF_ABBREVIATED_STRING = ".";
+
+    /**
+     * comment node test string.
+     */
+    private static final String NODETYPE_COMMENT_STRING = "comment";
+
+    /**
+     * text node test string.
+     */
+    private static final String NODETYPE_TEXT_STRING = "text";
+
+    /**
+     * processing-instruction node test string.
+     */
+    private static final String NODETYPE_PI_STRING = "processing-instruction";
+
+    /**
+     * Any node test string.
+     */
+    private static final String NODETYPE_NODE_STRING = "node";
+
+    /**
+     * Wildcard element string.
+     */
+    private static final String NODETYPE_ANYELEMENT_STRING = "*";
+
+    /**
+     * current function string.
+     */
+    public static final String FUNC_CURRENT_STRING = "current";
+
+    /**
+     * last function string.
+     */
+    public static final String FUNC_LAST_STRING = "last";
+
+    /**
+     * position function string.
+     */
+    public static final String FUNC_POSITION_STRING = "position";
+
+    /**
+     * count function string.
+     */
+    public static final String FUNC_COUNT_STRING = "count";
+
+    /**
+     * id function string.
+     */
+    static final String FUNC_ID_STRING = "id";
+
+    /**
+     * key function string (XSLT).
+     */
+    public static final String FUNC_KEY_STRING = "key";
+
+    /**
+     * local-name function string.
+     */
+    public static final String FUNC_LOCAL_PART_STRING = "local-name";
+
+    /**
+     * namespace-uri function string.
+     */
+    public static final String FUNC_NAMESPACE_STRING = "namespace-uri";
+
+    /**
+     * name function string.
+     */
+    public static final String FUNC_NAME_STRING = "name";
+
+    /**
+     * generate-id function string (XSLT).
+     */
+    public static final String FUNC_GENERATE_ID_STRING = "generate-id";
+
+    /**
+     * not function string.
+     */
+    public static final String FUNC_NOT_STRING = "not";
+
+    /**
+     * true function string.
+     */
+    public static final String FUNC_TRUE_STRING = "true";
+
+    /**
+     * false function string.
+     */
+    public static final String FUNC_FALSE_STRING = "false";
+
+    /**
+     * boolean function string.
+     */
+    public static final String FUNC_BOOLEAN_STRING = "boolean";
+
+    /**
+     * lang function string.
+     */
+    public static final String FUNC_LANG_STRING = "lang";
+
+    /**
+     * number function string.
+     */
+    public static final String FUNC_NUMBER_STRING = "number";
+
+    /**
+     * floor function string.
+     */
+    public static final String FUNC_FLOOR_STRING = "floor";
+
+    /**
+     * ceiling function string.
+     */
+    public static final String FUNC_CEILING_STRING = "ceiling";
+
+    /**
+     * round function string.
+     */
+    public static final String FUNC_ROUND_STRING = "round";
+
+    /**
+     * sum function string.
+     */
+    public static final String FUNC_SUM_STRING = "sum";
+
+    /**
+     * string function string.
+     */
+    public static final String FUNC_STRING_STRING = "string";
+
+    /**
+     * starts-with function string.
+     */
+    public static final String FUNC_STARTS_WITH_STRING = "starts-with";
+
+    /**
+     * contains function string.
+     */
+    public static final String FUNC_CONTAINS_STRING = "contains";
+
+    /**
+     * substring-before function string.
+     */
+    public static final String FUNC_SUBSTRING_BEFORE_STRING
+            = "substring-before";
+
+    /**
+     * substring-after function string.
+     */
+    public static final String FUNC_SUBSTRING_AFTER_STRING = "substring-after";
+
+    /**
+     * normalize-space function string.
+     */
+    public static final String FUNC_NORMALIZE_SPACE_STRING = "normalize-space";
+
+    /**
+     * translate function string.
+     */
+    public static final String FUNC_TRANSLATE_STRING = "translate";
+
+    /**
+     * concat function string.
+     */
+    public static final String FUNC_CONCAT_STRING = "concat";
+
+    /**
+     * system-property function string.
+     */
+    public static final String FUNC_SYSTEM_PROPERTY_STRING = "system-property";
+
+    /**
+     * function-available function string (XSLT).
+     */
+    public static final String FUNC_EXT_FUNCTION_AVAILABLE_STRING
+            = "function-available";
+
+    /**
+     * element-available function string (XSLT).
+     */
+    public static final String FUNC_EXT_ELEM_AVAILABLE_STRING
+            = "element-available";
+
+    /**
+     * substring function string.
+     */
+    public static final String FUNC_SUBSTRING_STRING = "substring";
+
+    /**
+     * string-length function string.
+     */
+    public static final String FUNC_STRING_LENGTH_STRING = "string-length";
+
+    /**
+     * unparsed-entity-uri function string (XSLT).
+     */
+    public static final String FUNC_UNPARSED_ENTITY_URI_STRING
+            = "unparsed-entity-uri";
 
   // Proprietary, built in functions
-
-  /** current function string (Proprietary). */
-  public static final String FUNC_DOCLOCATION_STRING = "document-location";
-
-  static
-  {
-    m_axisnames.put(FROM_ANCESTORS_STRING,
-                    new Integer(OpCodes.FROM_ANCESTORS));
-    m_axisnames.put(FROM_ANCESTORS_OR_SELF_STRING,
-                    new Integer(OpCodes.FROM_ANCESTORS_OR_SELF));
-    m_axisnames.put(FROM_ATTRIBUTES_STRING,
-                    new Integer(OpCodes.FROM_ATTRIBUTES));
-    m_axisnames.put(FROM_CHILDREN_STRING,
-                    new Integer(OpCodes.FROM_CHILDREN));
-    m_axisnames.put(FROM_DESCENDANTS_STRING,
-                    new Integer(OpCodes.FROM_DESCENDANTS));
-    m_axisnames.put(FROM_DESCENDANTS_OR_SELF_STRING,
-                    new Integer(OpCodes.FROM_DESCENDANTS_OR_SELF));
-    m_axisnames.put(FROM_FOLLOWING_STRING,
-                    new Integer(OpCodes.FROM_FOLLOWING));
-    m_axisnames.put(FROM_FOLLOWING_SIBLINGS_STRING,
-                    new Integer(OpCodes.FROM_FOLLOWING_SIBLINGS));
-    m_axisnames.put(FROM_PARENT_STRING,
-                    new Integer(OpCodes.FROM_PARENT));
-    m_axisnames.put(FROM_PRECEDING_STRING,
-                    new Integer(OpCodes.FROM_PRECEDING));
-    m_axisnames.put(FROM_PRECEDING_SIBLINGS_STRING,
-                    new Integer(OpCodes.FROM_PRECEDING_SIBLINGS));
-    m_axisnames.put(FROM_SELF_STRING,
-                    new Integer(OpCodes.FROM_SELF));
-    m_axisnames.put(FROM_NAMESPACE_STRING,
-                    new Integer(OpCodes.FROM_NAMESPACE));
-    m_nodetypes.put(NODETYPE_COMMENT_STRING,
-                    new Integer(OpCodes.NODETYPE_COMMENT));
-    m_nodetypes.put(NODETYPE_TEXT_STRING,
-                    new Integer(OpCodes.NODETYPE_TEXT));
-    m_nodetypes.put(NODETYPE_PI_STRING,
-                    new Integer(OpCodes.NODETYPE_PI));
-    m_nodetypes.put(NODETYPE_NODE_STRING,
-                    new Integer(OpCodes.NODETYPE_NODE));
-    m_nodetypes.put(NODETYPE_ANYELEMENT_STRING,
-                    new Integer(OpCodes.NODETYPE_ANYELEMENT));
-    m_keywords.put(FROM_SELF_ABBREVIATED_STRING,
-                   new Integer(OpCodes.FROM_SELF));
-    m_keywords.put(FUNC_ID_STRING,
-                   new Integer(FunctionTable.FUNC_ID));
-    m_keywords.put(FUNC_KEY_STRING,
-                   new Integer(FunctionTable.FUNC_KEY));
-
-    m_nodetests.put(NODETYPE_COMMENT_STRING,
-                    new Integer(OpCodes.NODETYPE_COMMENT));
-    m_nodetests.put(NODETYPE_TEXT_STRING,
-                    new Integer(OpCodes.NODETYPE_TEXT));
-    m_nodetests.put(NODETYPE_PI_STRING,
-                    new Integer(OpCodes.NODETYPE_PI));
-    m_nodetests.put(NODETYPE_NODE_STRING,
-                    new Integer(OpCodes.NODETYPE_NODE));
-  }
-
-  static Object getAxisName(String key){
-          return m_axisnames.get(key);
-  }
-
-  static Object lookupNodeTest(String key){
-          return m_nodetests.get(key);
-  }
-
-  static Object getKeyWord(String key){
-          return m_keywords.get(key);
-  }
-
-  static Object getNodeType(String key){
-          return m_nodetypes.get(key);
-  }
+    /**
+     * current function string (Proprietary).
+     */
+    public static final String FUNC_DOCLOCATION_STRING = "document-location";
+
+    static {
+        Map<String, Integer> keywords = new HashMap<>();
+        Map<String, Integer> axisnames = new HashMap<>();
+        Map<String, Integer> nodetests = new HashMap<>();
+        Map<String, Integer> nodetypes = new HashMap<>();
+
+        axisnames.put(FROM_ANCESTORS_STRING, OpCodes.FROM_ANCESTORS);
+        axisnames.put(FROM_ANCESTORS_OR_SELF_STRING, OpCodes.FROM_ANCESTORS_OR_SELF);
+        axisnames.put(FROM_ATTRIBUTES_STRING, OpCodes.FROM_ATTRIBUTES);
+        axisnames.put(FROM_CHILDREN_STRING, OpCodes.FROM_CHILDREN);
+        axisnames.put(FROM_DESCENDANTS_STRING, OpCodes.FROM_DESCENDANTS);
+        axisnames.put(FROM_DESCENDANTS_OR_SELF_STRING, OpCodes.FROM_DESCENDANTS_OR_SELF);
+        axisnames.put(FROM_FOLLOWING_STRING, OpCodes.FROM_FOLLOWING);
+        axisnames.put(FROM_FOLLOWING_SIBLINGS_STRING, OpCodes.FROM_FOLLOWING_SIBLINGS);
+        axisnames.put(FROM_PARENT_STRING, OpCodes.FROM_PARENT);
+        axisnames.put(FROM_PRECEDING_STRING, OpCodes.FROM_PRECEDING);
+        axisnames.put(FROM_PRECEDING_SIBLINGS_STRING, OpCodes.FROM_PRECEDING_SIBLINGS);
+        axisnames.put(FROM_SELF_STRING, OpCodes.FROM_SELF);
+        axisnames.put(FROM_NAMESPACE_STRING, OpCodes.FROM_NAMESPACE);
+        m_axisnames = Collections.unmodifiableMap(axisnames);
+
+        nodetypes.put(NODETYPE_COMMENT_STRING, OpCodes.NODETYPE_COMMENT);
+        nodetypes.put(NODETYPE_TEXT_STRING, OpCodes.NODETYPE_TEXT);
+        nodetypes.put(NODETYPE_PI_STRING, OpCodes.NODETYPE_PI);
+        nodetypes.put(NODETYPE_NODE_STRING, OpCodes.NODETYPE_NODE);
+        nodetypes.put(NODETYPE_ANYELEMENT_STRING, OpCodes.NODETYPE_ANYELEMENT);
+        m_nodetypes = Collections.unmodifiableMap(nodetypes);
+
+        keywords.put(FROM_SELF_ABBREVIATED_STRING, OpCodes.FROM_SELF);
+        keywords.put(FUNC_ID_STRING, FunctionTable.FUNC_ID);
+        keywords.put(FUNC_KEY_STRING, FunctionTable.FUNC_KEY);
+        m_keywords = Collections.unmodifiableMap(keywords);
+
+        nodetests.put(NODETYPE_COMMENT_STRING, OpCodes.NODETYPE_COMMENT);
+        nodetests.put(NODETYPE_TEXT_STRING, OpCodes.NODETYPE_TEXT);
+        nodetests.put(NODETYPE_PI_STRING, OpCodes.NODETYPE_PI);
+        nodetests.put(NODETYPE_NODE_STRING, OpCodes.NODETYPE_NODE);
+        m_nodetests = Collections.unmodifiableMap(nodetests);
+    }
+
+    static Integer getAxisName(String key) {
+        return m_axisnames.get(key);
+    }
+
+    static Integer lookupNodeTest(String key) {
+        return m_nodetests.get(key);
+    }
+
+    static Integer getKeyWord(String key) {
+        return m_keywords.get(key);
+    }
+
+    static Integer getNodeType(String key) {
+        return m_nodetypes.get(key);
+    }
 }
Index: openjdk/jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java
===================================================================
--- openjdk/jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java.orig
+++ openjdk/jaxp/src/com/sun/xml/internal/stream/XMLEntityStorage.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,19 +25,20 @@
 
 package com.sun.xml.internal.stream;
 
-import java.util.Hashtable;
-
+import com.sun.org.apache.xerces.internal.impl.Constants;
+import com.sun.org.apache.xerces.internal.impl.PropertyManager;
+import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
+import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
 import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
 import com.sun.org.apache.xerces.internal.util.URI;
 import com.sun.org.apache.xerces.internal.util.XMLResourceIdentifierImpl;
+import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponentManager;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
-import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
-import com.sun.org.apache.xerces.internal.impl.PropertyManager;
-import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
-import com.sun.org.apache.xerces.internal.impl.Constants;
-import com.sun.org.apache.xerces.internal.utils.SecuritySupport;
+import java.util.Collections;
 import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  *
@@ -62,7 +63,7 @@ public class XMLEntityStorage {
     protected boolean fWarnDuplicateEntityDef;
 
     /** Entities. */
-    protected Hashtable fEntities = new Hashtable();
+    protected Map<String, Entity> fEntities = new HashMap<>();
 
     protected Entity.ScannedEntity fCurrentEntity ;
 
@@ -138,7 +139,7 @@ public class XMLEntityStorage {
      * @see SymbolTable
      */
     public Entity getEntity(String name) {
-        return (Entity)fEntities.get(name);
+        return fEntities.get(name);
     } // getEntity(String)
 
     public boolean hasEntities() {
@@ -150,7 +151,7 @@ public class XMLEntityStorage {
     } // getEntity(String)
 
     public Enumeration getEntityKeys() {
-        return fEntities.keys();
+        return Collections.enumeration(fEntities.keySet());
     }
     /**
      * Adds an internal entity declaration.
@@ -263,7 +264,7 @@ public class XMLEntityStorage {
      */
     public boolean isExternalEntity(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         if (entity == null) {
             return false;
         }
@@ -280,7 +281,7 @@ public class XMLEntityStorage {
      */
     public boolean isEntityDeclInExternalSubset(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         if (entity == null) {
             return false;
         }
@@ -333,7 +334,7 @@ public class XMLEntityStorage {
      */
     public boolean isUnparsedEntity(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         if (entity == null) {
             return false;
         }
@@ -348,7 +349,7 @@ public class XMLEntityStorage {
      */
     public boolean isDeclaredEntity(String entityName) {
 
-        Entity entity = (Entity)fEntities.get(entityName);
+        Entity entity = fEntities.get(entityName);
         return entity != null;
     }
     /**
Index: openjdk/jaxp/src/com/sun/xml/internal/stream/dtd/nonvalidating/DTDGrammar.java
===================================================================
--- openjdk/jaxp/src/com/sun/xml/internal/stream/dtd/nonvalidating/DTDGrammar.java.orig
+++ openjdk/jaxp/src/com/sun/xml/internal/stream/dtd/nonvalidating/DTDGrammar.java
@@ -1,15 +1,15 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  */
-
 /*
- * Copyright 2005 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -20,20 +20,20 @@
 
 package com.sun.xml.internal.stream.dtd.nonvalidating;
 
-import java.util.Hashtable;
-import java.util.ArrayList;
-import java.util.List;
-
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
+import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.xni.Augmentations;
 import com.sun.org.apache.xerces.internal.xni.QName;
-import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.xni.XMLLocator;
 import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
 import com.sun.org.apache.xerces.internal.xni.XMLString;
 import com.sun.org.apache.xerces.internal.xni.XNIException;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLDTDContentModelSource;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLDTDSource;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A DTD grammar. This class implements the XNI handler interfaces
@@ -140,10 +140,10 @@ public class DTDGrammar {
     private int fAttributeDeclNextAttributeDeclIndex[][] = new int[INITIAL_CHUNK_COUNT][];
 
     /** Element index mapping table. */
-    private QNameHashtable fElementIndexMap = new QNameHashtable();
+    private final Map<String, Integer> fElementIndexMap = new HashMap<>();
 
     /** Temporary qualified name. */
-    private QName fQName = new QName();
+    private final QName fQName = new QName();
 
     /** Temporary Attribute decl. */
     protected XMLAttributeDecl fAttributeDecl = new XMLAttributeDecl();
@@ -156,7 +156,7 @@ public class DTDGrammar {
 
 
     /** table of XMLElementDecl   */
-    Hashtable   fElementDeclTab     = new Hashtable();
+    Map<String, XMLElementDecl> fElementDeclTab = new HashMap<>();
 
     /** Default constructor. */
     public DTDGrammar(SymbolTable symbolTable) {
@@ -213,7 +213,7 @@ public class DTDGrammar {
     public void elementDecl(String name, String contentModel, Augmentations augs)
     throws XNIException {
 
-        XMLElementDecl tmpElementDecl = (XMLElementDecl) fElementDeclTab.get(name) ;
+        XMLElementDecl tmpElementDecl = fElementDeclTab.get(name) ;
         if ( tmpElementDecl != null ) {
             if (tmpElementDecl.type == -1) {
                 fCurrentElementIndex = getElementDeclIndex(name);
@@ -299,7 +299,7 @@ public class DTDGrammar {
             normalizeDefaultAttrValue(defaultValue);
         }
 
-        if ( this.fElementDeclTab.containsKey( (String) elementName) ) {
+        if ( this.fElementDeclTab.containsKey(elementName)) {
             //if ElementDecl has already being created in the Grammar then remove from table,
             //this.fElementDeclTab.remove( (String) elementName );
         }
@@ -431,7 +431,10 @@ public class DTDGrammar {
      * @return index of the elementDeclName in scope
      */
     public int getElementDeclIndex(String elementDeclName) {
-        int mapping = fElementIndexMap.get(elementDeclName);
+        Integer mapping = fElementIndexMap.get(elementDeclName);
+        if (mapping == null) {
+            mapping = -1;
+        }
         //System.out.println("getElementDeclIndex("+elementDeclName+") -> "+mapping);
         return mapping;
     } // getElementDeclIndex(String):int
@@ -824,127 +827,6 @@ public class DTDGrammar {
         return newarray;
     }
 
-    //
-    // Classes
-    //
-
-
-    /**
-     * A simple Hashtable implementation that takes a tuple (String, String)
-     * as the key and a int as value.
-     *
-     * @author Eric Ye, IBM
-     * @author Andy Clark, IBM
-     */
-    protected static final class QNameHashtable {
-
-        //
-        // Constants
-        //
-        public static final boolean UNIQUE_STRINGS = true;
-
-        /** Initial bucket size (4). */
-        private static final int INITIAL_BUCKET_SIZE = 4;
-
-        // NOTE: Changed previous hashtable size from 512 to 101 so
-        //       that we get a better distribution for hashing. -Ac
-        /** Hashtable size (101). */
-        private static final int HASHTABLE_SIZE = 101;
-
-        //
-        // Data
-        //
-        private Object[][] fHashTable = new Object[HASHTABLE_SIZE][];
-
-        //
-        // Public methods
-        //
-        /** Associates the given value with the specified key tuple. */
-        public void put(String key, int value) {
-
-            // REVISIT: Why +2? -Ac
-            int hash = (hash(key)+2) % HASHTABLE_SIZE;
-            Object[] bucket = fHashTable[hash];
-
-            if (bucket == null) {
-                bucket = new Object[1 + 2*INITIAL_BUCKET_SIZE];
-                bucket[0] = new int[]{1};
-                bucket[1] = key;
-                bucket[2] = new int[]{value};
-                fHashTable[hash] = bucket;
-            } else {
-                int count = ((int[])bucket[0])[0];
-                int offset = 1 + 2*count;
-                if (offset == bucket.length) {
-                    int newSize = count + INITIAL_BUCKET_SIZE;
-                    Object[] newBucket = new Object[1 + 2*newSize];
-                    System.arraycopy(bucket, 0, newBucket, 0, offset);
-                    bucket = newBucket;
-                    fHashTable[hash] = bucket;
-                }
-                boolean found = false;
-                int j=1;
-                for (int i=0; i<count; i++){
-                    if ((String)bucket[j] == key) {
-                        ((int[])bucket[j+1])[0] = value;
-                        found = true;
-                        break;
-                    }
-                    j += 2;
-                }
-                if (! found) {
-                    bucket[offset++] = key;
-                    bucket[offset]= new int[]{value};
-                    ((int[])bucket[0])[0] = ++count;
-                }
-
-            }
-            //System.out.println("put("+key+" -> "+value+')');
-            //System.out.println("get("+key+") -> "+get(key));
-
-        } // put(int,String,String,int)
-
-        /** Returns the value associated with the specified key tuple. */
-        public int get(String key) {
-            int hash = (hash(key)+2) % HASHTABLE_SIZE;
-            Object[] bucket = fHashTable[hash];
-
-            if (bucket == null) {
-                return -1;
-            }
-            int count = ((int[])bucket[0])[0];
-
-            int j=1;
-            for (int i=0; i<count; i++){
-                if ((String)bucket[j] == key) {
-                    return ((int[])bucket[j+1])[0];
-                }
-                j += 2;
-            }
-            return -1;
-
-        } // get(int,String,String)
-
-        //
-        // Protected methods
-        //
-
-        /** Returns a hash value for the specified symbol. */
-        protected int hash(String symbol) {
-
-            if (symbol == null) {
-                return 0;
-            }
-            int code = 0;
-            int length = symbol.length();
-            for (int i = 0; i < length; i++) {
-                code = code * 37 + symbol.charAt(i);
-            }
-            return code & 0x7FFFFFF;
-
-        } // hash(String):int
-
-    }  // class QNameHashtable
     /**
      * Normalize the attribute value of a non CDATA default attribute
      * collapsing sequences of space characters (x20)
Index: openjdk/jaxp/src/org/xml/sax/helpers/NamespaceSupport.java
===================================================================
--- openjdk/jaxp/src/org/xml/sax/helpers/NamespaceSupport.java.orig
+++ openjdk/jaxp/src/org/xml/sax/helpers/NamespaceSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,10 +31,13 @@
 
 package org.xml.sax.helpers;
 
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EmptyStackException;
 import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Vector;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 
 /**
@@ -138,7 +141,7 @@ public class NamespaceSupport
      * An empty enumeration.
      */
     private final static Enumeration EMPTY_ENUMERATION =
-        new Vector().elements();
+            Collections.enumeration(new ArrayList<String>());
 
 
     ////////////////////////////////////////////////////////////////////
@@ -462,15 +465,15 @@ public class NamespaceSupport
      */
     public Enumeration getPrefixes (String uri)
     {
-        Vector prefixes = new Vector();
+        List<String> prefixes = new ArrayList<>();
         Enumeration allPrefixes = getPrefixes();
         while (allPrefixes.hasMoreElements()) {
             String prefix = (String)allPrefixes.nextElement();
             if (uri.equals(getURI(prefix))) {
-                prefixes.addElement(prefix);
+                prefixes.add(prefix);
             }
         }
-        return prefixes.elements();
+        return Collections.enumeration(prefixes);
     }
 
 
@@ -618,7 +621,7 @@ public class NamespaceSupport
                 copyTables();
             }
             if (declarations == null) {
-                declarations = new Vector();
+                declarations = new ArrayList<>();
             }
 
             prefix = prefix.intern();
@@ -633,7 +636,7 @@ public class NamespaceSupport
                 prefixTable.put(prefix, uri);
                 uriTable.put(uri, prefix); // may wipe out another prefix
             }
-            declarations.addElement(prefix);
+            declarations.add(prefix);
         }
 
 
@@ -651,33 +654,33 @@ public class NamespaceSupport
         String [] processName (String qName, boolean isAttribute)
         {
             String name[];
-            Hashtable table;
+            Map<String, String[]> table;
 
-                                // Select the appropriate table.
+            // Select the appropriate table.
             if (isAttribute) {
                 table = attributeNameTable;
             } else {
                 table = elementNameTable;
             }
 
-                                // Start by looking in the cache, and
-                                // return immediately if the name
-                                // is already known in this content
+            // Start by looking in the cache, and
+            // return immediately if the name
+            // is already known in this content
             name = (String[])table.get(qName);
             if (name != null) {
                 return name;
             }
 
-                                // We haven't seen this name in this
-                                // context before.  Maybe in the parent
-                                // context, but we can't assume prefix
-                                // bindings are the same.
+            // We haven't seen this name in this
+            // context before.  Maybe in the parent
+            // context, but we can't assume prefix
+            // bindings are the same.
             name = new String[3];
             name[2] = qName.intern();
             int index = qName.indexOf(':');
 
 
-                                // No prefix.
+            // No prefix.
             if (index == -1) {
                 if (isAttribute) {
                     if (qName == "xmlns" && namespaceDeclUris)
@@ -692,7 +695,7 @@ public class NamespaceSupport
                 name[1] = name[2];
             }
 
-                                // Prefix
+            // Prefix
             else {
                 String prefix = qName.substring(0, index);
                 String local = qName.substring(index+1);
@@ -710,8 +713,8 @@ public class NamespaceSupport
                 name[1] = local.intern();
             }
 
-                                // Save in the cache for future use.
-                                // (Could be shared with parent context...)
+            // Save in the cache for future use.
+            // (Could be shared with parent context...)
             table.put(name[2], name);
             return name;
         }
@@ -768,11 +771,10 @@ public class NamespaceSupport
             if (declarations == null) {
                 return EMPTY_ENUMERATION;
             } else {
-                return declarations.elements();
+                return Collections.enumeration(declarations);
             }
         }
 
-
         /**
          * Return an enumeration of all prefixes currently in force.
          *
@@ -787,7 +789,7 @@ public class NamespaceSupport
             if (prefixTable == null) {
                 return EMPTY_ENUMERATION;
             } else {
-                return prefixTable.keys();
+                return Collections.enumeration(prefixTable.keySet());
             }
         }
 
@@ -807,17 +809,17 @@ public class NamespaceSupport
         private void copyTables ()
         {
             if (prefixTable != null) {
-                prefixTable = (Hashtable)prefixTable.clone();
+                prefixTable = new HashMap<>(prefixTable);
             } else {
-                prefixTable = new Hashtable();
+                prefixTable = new HashMap<>();
             }
             if (uriTable != null) {
-                uriTable = (Hashtable)uriTable.clone();
+                uriTable = new HashMap<>(uriTable);
             } else {
-                uriTable = new Hashtable();
+                uriTable = new HashMap<>();
             }
-            elementNameTable = new Hashtable();
-            attributeNameTable = new Hashtable();
+            elementNameTable = new HashMap<>();
+            attributeNameTable = new HashMap<>();
             declSeen = true;
         }
 
@@ -827,10 +829,10 @@ public class NamespaceSupport
         // Protected state.
         ////////////////////////////////////////////////////////////////
 
-        Hashtable prefixTable;
-        Hashtable uriTable;
-        Hashtable elementNameTable;
-        Hashtable attributeNameTable;
+        Map<String, String> prefixTable;
+        Map<String, String> uriTable;
+        Map<String, String[]> elementNameTable;
+        Map<String, String[]> attributeNameTable;
         String defaultNS = null;
 
 
@@ -839,7 +841,7 @@ public class NamespaceSupport
         // Internal state.
         ////////////////////////////////////////////////////////////////
 
-        private Vector declarations = null;
+        private List<String> declarations = null;
         private boolean declSeen = false;
         private Context parent = null;
     }
